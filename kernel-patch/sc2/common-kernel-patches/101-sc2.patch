From c5415f8cc42ed0d8b309b54a809c47155e43dae6 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 16:22:02 +0200
Subject: [PATCH 01/26] dt-bindings: i2c-gpio: Add property
 i2c-gpio,sda-output-only

This documents new property i2c-gpio,sda-output-only.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 Documentation/devicetree/bindings/i2c/i2c-gpio.yaml | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/Documentation/devicetree/bindings/i2c/i2c-gpio.yaml b/Documentation/devicetree/bindings/i2c/i2c-gpio.yaml
index fd0402845..25cd1b260 100644
--- a/Documentation/devicetree/bindings/i2c/i2c-gpio.yaml
+++ b/Documentation/devicetree/bindings/i2c/i2c-gpio.yaml
@@ -33,6 +33,10 @@ properties:
       open drain.
     maxItems: 1

+  i2c-gpio,sda-output-only:
+    description: sda as output only
+    type: boolean
+
   i2c-gpio,scl-output-only:
     description: scl as output only
     type: boolean
--
2.43.0.windows.1


From babb996768fb0097e42abc3da85553f820b73cef Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 16:27:27 +0200
Subject: [PATCH 02/26] i2c: algo: bit: allow getsda to be NULL This is in
 preparation of supporting write-only SDA in i2c-gpio.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/i2c/algos/i2c-algo-bit.c | 16 +++++++++++++---
 1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/drivers/i2c/algos/i2c-algo-bit.c b/drivers/i2c/algos/i2c-algo-bit.c
index fc90293af..f311b0595 100644
--- a/drivers/i2c/algos/i2c-algo-bit.c
+++ b/drivers/i2c/algos/i2c-algo-bit.c
@@ -184,8 +184,9 @@ static int i2c_outb(struct i2c_adapter *i2c_adap, unsigned char c)

 	/* read ack: SDA should be pulled down by slave, or it may
 	 * NAK (usually to report problems with the data we wrote).
+         * Report ACK if SDA is write-only.
 	 */
-	ack = !getsda(adap);    /* ack: sda is pulled low -> success */
+        ack = !adap->getsda || !getsda(adap); /* ack: sda is pulled low -> success */
 	bit_dbg(2, &i2c_adap->dev, "i2c_outb: 0x%02x %s\n", (int)c,
 		ack ? "A" : "NA");

@@ -203,6 +204,9 @@ static int i2c_inb(struct i2c_adapter *i2c_adap)
 	unsigned char indata = 0;
 	struct i2c_algo_bit_data *adap = i2c_adap->algo_data;

+	if (!adap->getsda)
+		return -EOPNOTSUPP;
+
 	/* assert: scl is low */
 	sdahi(adap);
 	for (i = 0; i < 8; i++) {
@@ -232,6 +236,10 @@ static int test_bus(struct i2c_adapter *i2c_adap)
 	const char *name = i2c_adap->name;
 	int scl, sda, ret;

+	/* Testing not possible if both pins are write-only. */
+	if (adap->getscl == NULL && adap->getsda == NULL)
+		return 0;
+
 	if (adap->pre_xfer) {
 		ret = adap->pre_xfer(i2c_adap);
 		if (ret < 0)
@@ -670,8 +678,10 @@ static int __i2c_bit_add_bus(struct i2c_adapter *adap,
 	if (ret < 0)
 		return ret;

-	/* Complain if SCL can't be read */
-	if (bit_adap->getscl == NULL) {
+	if (bit_adap->getscl == NULL && bit_adap->getsda == NULL)
+		dev_info(&adap->dev, "I2C-like interface, SDA and SCL are write-only\n");
+	else if (bit_adap->getscl == NULL) {
+		/* Complain if SCL can't be read */
 		dev_warn(&adap->dev, "Not I2C compliant: can't read SCL\n");
 		dev_warn(&adap->dev, "Bus may be unreliable\n");
 	}
--
2.43.0.windows.1


From a3b889cf32811076014f6608273b4f032ca0f7e6 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 16:32:29 +0200
Subject: [PATCH 03/26] i2c: gpio: support write-only sda There are slave
 devices that understand I2C but have read-only SDA and SCL. Examples are
 FD650 7-segment LED controller and its derivatives. Typical board designs
 don't even have a pull-up for both pins. This patch makes i2c-gpio usable
 with such devices, based on new DT property i2c-gpio,sda-output-only.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/i2c/busses/i2c-gpio.c          | 14 +++++++++++---
 include/linux/platform_data/i2c-gpio.h |  1 +
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/drivers/i2c/busses/i2c-gpio.c b/drivers/i2c/busses/i2c-gpio.c
index b1985c166..15be06cc2 100644
--- a/drivers/i2c/busses/i2c-gpio.c
+++ b/drivers/i2c/busses/i2c-gpio.c
@@ -316,6 +316,8 @@ static void of_i2c_gpio_get_props(struct device_node *np,
 		of_property_read_bool(np, "i2c-gpio,scl-open-drain");
 	pdata->scl_is_output_only =
 		of_property_read_bool(np, "i2c-gpio,scl-output-only");
+	pdata->sda_is_output_only =
+		of_property_read_bool(np, "i2c-gpio,sda-output-only");
 }

 static struct gpio_desc *i2c_gpio_get_desc(struct device *dev,
@@ -363,6 +365,7 @@ static int i2c_gpio_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
 	enum gpiod_flags gflags;
+	bool sda_scl_output_only;
 	int ret;

 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
@@ -391,8 +394,12 @@ static int i2c_gpio_probe(struct platform_device *pdev)
 	 * marking these lines to be handled as open drain, and we should just
 	 * handle them as we handle any other output. Else we enforce open
 	 * drain as this is required for an I2C bus.
+	 * If SCL/SDA both are write-only, then this indicates I2C-like slaves
+	 * with read-only SCL/SDA. Such slaves don't need open-drain, and partially
+	 * don't even work with open-drain.
 	 */
-	if (pdata->sda_is_open_drain)
+	sda_scl_output_only = pdata->sda_is_output_only && pdata->scl_is_output_only;
+	if (pdata->sda_is_open_drain || sda_scl_output_only)
 		gflags = GPIOD_OUT_HIGH;
 	else
 		gflags = GPIOD_OUT_HIGH_OPEN_DRAIN;
@@ -400,7 +407,7 @@ static int i2c_gpio_probe(struct platform_device *pdev)
 	if (IS_ERR(priv->sda))
 		return PTR_ERR(priv->sda);

-	if (pdata->scl_is_open_drain)
+	if (pdata->scl_is_open_drain || sda_scl_output_only)
 		gflags = GPIOD_OUT_HIGH;
 	else
 		gflags = GPIOD_OUT_HIGH_OPEN_DRAIN;
@@ -418,7 +425,8 @@ static int i2c_gpio_probe(struct platform_device *pdev)

 	if (!pdata->scl_is_output_only)
 		bit_data->getscl = i2c_gpio_getscl;
-	bit_data->getsda = i2c_gpio_getsda;
+	if (!pdata->sda_is_output_only)
+		bit_data->getsda = i2c_gpio_getsda;

 	if (pdata->udelay)
 		bit_data->udelay = pdata->udelay;
diff --git a/include/linux/platform_data/i2c-gpio.h b/include/linux/platform_data/i2c-gpio.h
index a907774fd..312589bc7 100644
--- a/include/linux/platform_data/i2c-gpio.h
+++ b/include/linux/platform_data/i2c-gpio.h
@@ -24,6 +24,7 @@ struct i2c_gpio_platform_data {
 	int		udelay;
 	int		timeout;
 	unsigned int	sda_is_open_drain:1;
+	unsigned int    sda_is_output_only:1;
 	unsigned int	scl_is_open_drain:1;
 	unsigned int	scl_is_output_only:1;
 };
--
2.43.0.windows.1


From 0fe4552a26e8ad96169ce6378bd6d183cf42cd2e Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 16:34:56 +0200
Subject: [PATCH 04/26] dt-bindings: serial: amlogic, meson-uart: support GXL
 and remove reverted S4 support

Add a compatible for GXL that supports AML_UART_BAUD_XTAL_DIV2.
Whilst we're touching this file, remove the S4 compatible.
It's a leftover after S4 uart support was reverted with
16b3ac9 ("Revert "tty: serial: meson: *"").

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 .../devicetree/bindings/serial/amlogic,meson-uart.yaml        | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Documentation/devicetree/bindings/serial/amlogic,meson-uart.yaml b/Documentation/devicetree/bindings/serial/amlogic,meson-uart.yaml
index 7822705ad..378224497 100644
--- a/Documentation/devicetree/bindings/serial/amlogic,meson-uart.yaml
+++ b/Documentation/devicetree/bindings/serial/amlogic,meson-uart.yaml
@@ -29,7 +29,7 @@ properties:
               - amlogic,meson8-uart
               - amlogic,meson8b-uart
               - amlogic,meson-gx-uart
-              - amlogic,meson-s4-uart
+              - amlogic,meson-gxl-uart
           - const: amlogic,meson-ao-uart
       - description: Everything-Else power domain UART controller
         enum:
@@ -37,7 +37,7 @@ properties:
           - amlogic,meson8-uart
           - amlogic,meson8b-uart
           - amlogic,meson-gx-uart
-          - amlogic,meson-s4-uart
+          - amlogic,meson-gxl-uart

   reg:
     maxItems: 1
--
2.43.0.windows.1


From 1a5a691cd3ee1f3ce8252f6dd5a755a13bf2ba74 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 16:50:39 +0200
Subject: [PATCH 05/26] tty: serial: meson: add new compatible for gxl uart
 Newer SoC versions support using XTAL / 2 (12MHz) as clock source for the
 UART. This clock source allows to support 921600 bps as used by vendor uboot
 on certain systems like ah212 ref board.

12MHz / 13 = 923076 bps
With the currently used 8MHz clock source only 888888bps or
1000000 bps are possible.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/tty/serial/meson_uart.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/drivers/tty/serial/meson_uart.c b/drivers/tty/serial/meson_uart.c
index 056243c12..58ad825eb 100644
--- a/drivers/tty/serial/meson_uart.c
+++ b/drivers/tty/serial/meson_uart.c
@@ -780,7 +780,7 @@ static int meson_uart_remove(struct platform_device *pdev)
 	return 0;
 }

-static struct meson_uart_data s4_uart_data = {
+static struct meson_uart_data meson_g12a_uart_data = {
 	.has_xtal_div2 = true,
 };

@@ -790,8 +790,12 @@ static const struct of_device_id meson_uart_dt_match[] = {
 	{ .compatible = "amlogic,meson8b-uart" },
 	{ .compatible = "amlogic,meson-gx-uart" },
 	{
-		.compatible = "amlogic,meson-s4-uart",
-		.data = (void *)&s4_uart_data,
+		.compatible = "amlogic,meson-g12a-uart",
+		.data = (void *)&meson_g12a_uart_data,
+	},
+	{
+		.compatible = "amlogic,meson-gxl-uart",
+		.data = (void *)&meson_g12a_uart_data,
 	},
 	{ /* sentinel */ },
 };
--
2.43.0.windows.1


From 739c209666a5d751d9acc584033384bdbfb7d1fc Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 16:53:25 +0200
Subject: [PATCH 06/26] mmc:meson-gx: make clock initialization work on SC2 To
 configure the initial 400khz rate we need xtal as one parent. At least on my
 SC2 system that's not the case per default. Therefore set it explicitly. See
 sc2_sd_emmc_clk0_parent_data[] in drivers/clk/meson/sc2.c for the selectable
 parents.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/mmc/host/meson-gx-mmc.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/mmc/host/meson-gx-mmc.c b/drivers/mmc/host/meson-gx-mmc.c
index bfa25624e..00c0649c3 100644
--- a/drivers/mmc/host/meson-gx-mmc.c
+++ b/drivers/mmc/host/meson-gx-mmc.c
@@ -443,6 +443,12 @@ static int meson_mmc_clk_init(struct meson_host *host)
 			return dev_err_probe(host->dev, PTR_ERR(clk),
 					     "Missing clock %s\n", name);

+		/* clkin0 hierarchy includes dividers and muxes, and bootloader
+		 * may have left whatever settings. Set to XTAL rate.
+		 */
+		if (i == 0)
+			clk_set_rate(clk, 24000000);
+
 		mux_parent_names[i] = __clk_get_name(clk);
 	}

--
2.43.0.windows.1


From b62b93288fb5a4ccee2f728f50ce443189590f2c Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:03:50 +0200
Subject: [PATCH 07/26] mmc: meson-gx: add SDIO interrupt support This adds
 SDIO interrupt support. Successfully tested on S905X4-based system with a
 BRCM4334 wifi module (brcmfmac driver).

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/mmc/host/meson-gx-mmc.c | 43 +++++++++++++++++++++++++++------
 1 file changed, 35 insertions(+), 8 deletions(-)

diff --git a/drivers/mmc/host/meson-gx-mmc.c b/drivers/mmc/host/meson-gx-mmc.c
index 00c0649c3..3f0bd1501 100644
--- a/drivers/mmc/host/meson-gx-mmc.c
+++ b/drivers/mmc/host/meson-gx-mmc.c
@@ -41,14 +41,17 @@
 #define   CLK_V2_TX_DELAY_MASK GENMASK(19, 16)
 #define   CLK_V2_RX_DELAY_MASK GENMASK(23, 20)
 #define   CLK_V2_ALWAYS_ON BIT(24)
+#define   CLK_V2_IRQ_SDIO_SLEEP BIT(29)

 #define   CLK_V3_TX_DELAY_MASK GENMASK(21, 16)
 #define   CLK_V3_RX_DELAY_MASK GENMASK(27, 22)
 #define   CLK_V3_ALWAYS_ON BIT(28)
+#define   CLK_V3_IRQ_SDIO_SLEEP BIT(29)

 #define   CLK_TX_DELAY_MASK(h)		(h->data->tx_delay_mask)
 #define   CLK_RX_DELAY_MASK(h)		(h->data->rx_delay_mask)
 #define   CLK_ALWAYS_ON(h)		(h->data->always_on)
+#define   CLK_IRQ_SDIO_SLEEP(h)         (h->data->irq_sdio_sleep)

 #define SD_EMMC_DELAY 0x4
 #define SD_EMMC_ADJUST 0x8
@@ -85,6 +88,7 @@
 #define   STATUS_BUSY BIT(31)
 #define   STATUS_DESC_BUSY BIT(30)
 #define   STATUS_DATI GENMASK(23, 16)
+#define   STATUS_DAT1 BIT(17)

 #define SD_EMMC_IRQ_EN 0x4c
 #define   IRQ_RXD_ERR_MASK GENMASK(7, 0)
@@ -135,6 +139,7 @@ struct meson_mmc_data {
 	unsigned int rx_delay_mask;
 	unsigned int always_on;
 	unsigned int adjust;
+        unsigned int irq_sdio_sleep;
 };

 struct sd_emmc_desc {
@@ -430,6 +435,7 @@ static int meson_mmc_clk_init(struct meson_host *host)
 	clk_reg |= FIELD_PREP(CLK_CORE_PHASE_MASK, CLK_PHASE_180);
 	clk_reg |= FIELD_PREP(CLK_TX_PHASE_MASK, CLK_PHASE_0);
 	clk_reg |= FIELD_PREP(CLK_RX_PHASE_MASK, CLK_PHASE_0);
+	clk_reg |= CLK_IRQ_SDIO_SLEEP(host);
 	writel(clk_reg, host->regs + SD_EMMC_CLOCK);

 	/* get the mux parents */
@@ -938,7 +944,6 @@ static irqreturn_t meson_mmc_irq(int irq, void *dev_id)
 {
 	struct meson_host *host = dev_id;
 	struct mmc_command *cmd;
-	struct mmc_data *data;
 	u32 status, raw_status;
 	irqreturn_t ret = IRQ_NONE;

@@ -952,14 +957,24 @@ static irqreturn_t meson_mmc_irq(int irq, void *dev_id)
 		return IRQ_NONE;
 	}

-	if (WARN_ON(!host) || WARN_ON(!host->cmd))
+	if (WARN_ON(!host))
 		return IRQ_NONE;

 	/* ack all raised interrupts */
 	writel(status, host->regs + SD_EMMC_STATUS);

 	cmd = host->cmd;
-	data = cmd->data;
+
+	if (status & IRQ_SDIO) {
+		mmc_signal_sdio_irq(host->mmc);
+		status &= ~IRQ_SDIO;
+		if (!status)
+			return IRQ_HANDLED;
+	}
+
+	if (WARN_ON(!cmd))
+		return IRQ_NONE;
+
 	cmd->error = 0;
 	if (status & IRQ_CRC_ERR) {
 		dev_dbg(host->dev, "CRC Error - status 0x%08x\n", status);
@@ -977,12 +992,9 @@ static irqreturn_t meson_mmc_irq(int irq, void *dev_id)

 	meson_mmc_read_resp(host->mmc, cmd);

-	if (status & IRQ_SDIO) {
-		dev_dbg(host->dev, "IRQ: SDIO TODO.\n");
-		ret = IRQ_HANDLED;
-	}
-
 	if (status & (IRQ_END_OF_CHAIN | IRQ_RESP_STATUS)) {
+		struct mmc_data *data = cmd->data;
+
 		if (data && !cmd->error)
 			data->bytes_xfered = data->blksz * data->blocks;

@@ -1119,6 +1131,18 @@ static int meson_mmc_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)
 	return -EINVAL;
 }

+static void meson_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 reg_irqen;
+
+	reg_irqen = readl(host->regs + SD_EMMC_IRQ_EN);
+	reg_irqen &= ~IRQ_SDIO;
+	if (enable)
+		reg_irqen |= IRQ_SDIO;
+	writel(reg_irqen, host->regs + SD_EMMC_IRQ_EN);
+}
+
 static const struct mmc_host_ops meson_mmc_ops = {
 	.request	= meson_mmc_request,
 	.set_ios	= meson_mmc_set_ios,
@@ -1128,6 +1152,7 @@ static const struct mmc_host_ops meson_mmc_ops = {
 	.execute_tuning = meson_mmc_resampling_tuning,
 	.card_busy	= meson_mmc_card_busy,
 	.start_signal_voltage_switch = meson_mmc_voltage_switch,
+	.enable_sdio_irq = meson_mmc_enable_sdio_irq,
 };

 static int meson_mmc_probe(struct platform_device *pdev)
@@ -1331,6 +1356,7 @@ static const struct meson_mmc_data meson_gx_data = {
 	.rx_delay_mask	= CLK_V2_RX_DELAY_MASK,
 	.always_on	= CLK_V2_ALWAYS_ON,
 	.adjust		= SD_EMMC_ADJUST,
+	.irq_sdio_sleep = CLK_V2_IRQ_SDIO_SLEEP,
 };

 static const struct meson_mmc_data meson_axg_data = {
@@ -1338,6 +1364,7 @@ static const struct meson_mmc_data meson_axg_data = {
 	.rx_delay_mask	= CLK_V3_RX_DELAY_MASK,
 	.always_on	= CLK_V3_ALWAYS_ON,
 	.adjust		= SD_EMMC_V3_ADJUST,
+	.irq_sdio_sleep = CLK_V3_IRQ_SDIO_SLEEP,
 };

 static const struct of_device_id meson_mmc_of_match[] = {
--
2.43.0.windows.1


From 50b73aa8ebde05d0b92440f09b0f9c903ed1a240 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:06:10 +0200
Subject: [PATCH 08/26] clk: meson: pll: copy retry workaround from vendor
 driver On a S905X4-based system this calls fails randomly. The vendor driver
 has a retry mechanism and on my system the second attempt is successful
 always.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/clk/meson/clk-pll.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/drivers/clk/meson/clk-pll.c b/drivers/clk/meson/clk-pll.c
index 9e55617bc..daa025b6d 100644
--- a/drivers/clk/meson/clk-pll.c
+++ b/drivers/clk/meson/clk-pll.c
@@ -320,12 +320,16 @@ static int meson_clk_pll_is_enabled(struct clk_hw *hw)

 static int meson_clk_pcie_pll_enable(struct clk_hw *hw)
 {
-	meson_clk_pll_init(hw);
+	int retries;

-	if (meson_clk_pll_wait_lock(hw))
-		return -EIO;
+	for (retries = 0; retries < 10; retries ++) {
+		meson_clk_pll_init(hw);
+		if (!meson_clk_pll_wait_lock(hw))
+			return 0;
+		pr_info("PCIe PLL clock, retry enabling ..\n");
+	}

-	return 0;
+	return -EIO;
 }

 static int meson_clk_pll_enable(struct clk_hw *hw)
--
2.43.0.windows.1


From 54d686c606b27d3da3b223112bb83458ba3c7ae3 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:07:40 +0200
Subject: [PATCH 09/26] clk: meson: pll: adjust timeout in
 meson_clk_pll_wait_lock Currently we loop over meson_parm_read() up to 24mln
 times. This results in a unpredictable timeout period. In my case it's over
 5s on a S905X4-based system. Make the timeout period predictable and set it
 to 100ms.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/clk/meson/clk-pll.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/clk/meson/clk-pll.c b/drivers/clk/meson/clk-pll.c
index daa025b6d..53b8e17e4 100644
--- a/drivers/clk/meson/clk-pll.c
+++ b/drivers/clk/meson/clk-pll.c
@@ -277,15 +277,15 @@ static int meson_clk_pll_wait_lock(struct clk_hw *hw)
 {
 	struct clk_regmap *clk = to_clk_regmap(hw);
 	struct meson_clk_pll_data *pll = meson_clk_pll_data(clk);
-	int delay = 24000000;
+	int delay = 5000;

 	do {
-		/* Is the clock locked now ? */
+		/* Is the clock locked now ? Time out after 100ms. */
 		if (meson_parm_read(clk->map, &pll->l))
 			return 0;

-		delay--;
-	} while (delay > 0);
+		udelay(20);
+	} while (--delay);

 	return -ETIMEDOUT;
 }
--
2.43.0.windows.1


From 988ed57518f3d0dead05692e1f4cd56d15e4c818 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:12:09 +0200
Subject: [PATCH 10/26] soc: amlogic: meson-gx-socinfo: Add support for S905X4
 Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>

---
 drivers/soc/amlogic/meson-gx-socinfo.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/soc/amlogic/meson-gx-socinfo.c b/drivers/soc/amlogic/meson-gx-socinfo.c
index 165f75484..87b07a73a 100644
--- a/drivers/soc/amlogic/meson-gx-socinfo.c
+++ b/drivers/soc/amlogic/meson-gx-socinfo.c
@@ -41,6 +41,7 @@ static const struct meson_gx_soc_id {
 	{ "G12B", 0x29 },
 	{ "SM1", 0x2b },
 	{ "A1", 0x2c },
+	{ "SC2", 0x32 },
 };

 static const struct meson_gx_package_id {
@@ -74,6 +75,7 @@ static const struct meson_gx_package_id {
 	{ "S905X3", 0x2b, 0x10, 0x3f },
 	{ "S905D3", 0x2b, 0x30, 0x3f },
 	{ "A113L", 0x2c, 0x0, 0xf8 },
+	{ "S905X4", 0x32, 0x2, 0xff },
 };

 static inline unsigned int socinfo_to_major(u32 socinfo)
--
2.43.0.windows.1


From 06b053714d3ff608f24239f1a5e58e3e94ee0973 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:13:13 +0200
Subject: [PATCH 11/26] dt-bindings: clk: meson: add sc2 periph clock
 controller bindings Add binding for SC2 (S905X4) platform.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 Documentation/devicetree/bindings/clock/amlogic,gxbb-clkc.txt | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Documentation/devicetree/bindings/clock/amlogic,gxbb-clkc.txt b/Documentation/devicetree/bindings/clock/amlogic,gxbb-clkc.txt
index 7ccecd5c0..c0ff74ebc 100644
--- a/Documentation/devicetree/bindings/clock/amlogic,gxbb-clkc.txt
+++ b/Documentation/devicetree/bindings/clock/amlogic,gxbb-clkc.txt
@@ -12,6 +12,7 @@ Required Properties:
 		"amlogic,g12a-clkc" for G12A SoC.
 		"amlogic,g12b-clkc" for G12B SoC.
 		"amlogic,sm1-clkc" for SM1 SoC.
+		"amlogic,sc2-clkc" for SC2 SoC.
 - clocks : list of clock phandle, one for each entry clock-names.
 - clock-names : should contain the following:
   * "xtal": the platform xtal
--
2.43.0.windows.1


From 7c842d3c4552bfbdec8cf74195022f5e3dfec210 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:22:02 +0200
Subject: [PATCH 12/26] clk: meson: Add support for SC2 This adds clk support
 for the SC2 platform (S905X4). Code is copied from the vendor driver, with
 minor non-functional improvements.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/clk/meson/Kconfig                    |   14 +
 drivers/clk/meson/Makefile                   |    2 +
 drivers/clk/meson/clk-pll.c                  |   97 +
 drivers/clk/meson/clk-secure.h               |   47 +
 drivers/clk/meson/sc2.c                      | 6176 ++++++++++++++++++
 drivers/clk/meson/sc2.h                      |  320 +
 drivers/clk/meson/sc2_clk_regmap.c           |  236 +
 include/dt-bindings/clock/amlogic,sc2-clkc.h |  365 ++
 8 files changed, 7257 insertions(+)
 create mode 100644 drivers/clk/meson/clk-secure.h
 create mode 100644 drivers/clk/meson/sc2.c
 create mode 100644 drivers/clk/meson/sc2.h
 create mode 100644 drivers/clk/meson/sc2_clk_regmap.c
 create mode 100644 include/dt-bindings/clock/amlogic,sc2-clkc.h

diff --git a/drivers/clk/meson/Kconfig b/drivers/clk/meson/Kconfig
index fc002c155..873a75dbe 100644
--- a/drivers/clk/meson/Kconfig
+++ b/drivers/clk/meson/Kconfig
@@ -115,4 +115,18 @@ config COMMON_CLK_G12A
 	help
 	  Support for the clock controller on Amlogic S905D2, S905X2 and S905Y2
 	  devices, aka g12a. Say Y if you want peripherals to work.
+
+config COMMON_CLK_SC2
+	tristate "SC2 SoC clock controllers support"
+	depends on ARM64
+	default y
+	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_MESON_DUALDIV
+	select COMMON_CLK_MESON_MPLL
+	select COMMON_CLK_MESON_PLL
+	select COMMON_CLK_MESON_CPU_DYNDIV
+	select COMMON_CLK_MESON_VID_PLL_DIV
+	help
+	  Support for the clock controller on Amlogic S905X4 devices,
+	  aka sc2. Say Y if you want peripherals to work.
 endmenu
diff --git a/drivers/clk/meson/Makefile b/drivers/clk/meson/Makefile
index 6eca2a406..8dbad181e 100644
--- a/drivers/clk/meson/Makefile
+++ b/drivers/clk/meson/Makefile
@@ -19,3 +19,5 @@ obj-$(CONFIG_COMMON_CLK_AXG_AUDIO) += axg-audio.o
 obj-$(CONFIG_COMMON_CLK_GXBB) += gxbb.o gxbb-aoclk.o
 obj-$(CONFIG_COMMON_CLK_G12A) += g12a.o g12a-aoclk.o
 obj-$(CONFIG_COMMON_CLK_MESON8B) += meson8b.o meson8-ddr.o
+obj-$(CONFIG_COMMON_CLK_SC2) += sc2.o sc2_clk_regmap.o
+
diff --git a/drivers/clk/meson/clk-pll.c b/drivers/clk/meson/clk-pll.c
index 53b8e17e4..cc19943e3 100644
--- a/drivers/clk/meson/clk-pll.c
+++ b/drivers/clk/meson/clk-pll.c
@@ -35,6 +35,7 @@
 #include <linux/rational.h>

 #include "clk-regmap.h"
+#include "clk-secure.h"
 #include "clk-pll.h"

 static inline struct meson_clk_pll_data *
@@ -418,6 +419,93 @@ static int meson_clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,
 	return ret;
 }

+
+static int __meson_secure_clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+					   unsigned long parent_rate)
+{
+	struct arm_smccc_res res;
+
+	if (!strcmp(clk_hw_get_name(hw), "sys_pll_dco")) {
+		arm_smccc_smc(CLK_SECURE_RW, SYS_PLL_STEP0, rate, 0, 0, 0, 0, 0, &res);
+	} else if (!strcmp(clk_hw_get_name(hw), "gp1_pll_dco")) {
+		arm_smccc_smc(CLK_SECURE_RW, GP1_PLL_STEP0, rate, 0, 0, 0, 0, 0, &res);
+	} else {
+		pr_err("%s: %s pll not found!!!\n", __func__, clk_hw_get_name(hw));
+		return -EINVAL;
+	}
+
+	/* waiting for 10us to rewrite */
+	udelay(10);
+
+	if (!strcmp(clk_hw_get_name(hw), "sys_pll_dco"))
+		arm_smccc_smc(CLK_SECURE_RW, SYS_PLL_STEP1, 0, 0, 0, 0, 0, 0, &res);
+	else
+		arm_smccc_smc(CLK_SECURE_RW, GP1_PLL_STEP1, 0, 0, 0, 0, 0, 0, &res);
+
+	return meson_clk_pll_wait_lock(hw);
+}
+
+static int meson_secure_clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+					 unsigned long parent_rate)
+{
+	int ret = __meson_secure_clk_pll_set_rate(hw, rate, parent_rate);
+
+	if (ret == -ETIMEDOUT) {
+		pr_info("%s: %s did not lock, trying to lock rate %lu again\n",
+			__func__, clk_hw_get_name(hw), rate);
+		ret = __meson_secure_clk_pll_set_rate(hw, rate, parent_rate);
+	}
+
+	return ret;
+}
+
+static long meson_secure_clk_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+					    unsigned long *parent_rate)
+{
+	return rate;
+}
+
+static int meson_secure_clk_pll_enable(struct clk_hw *hw)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct meson_clk_pll_data *pll = meson_clk_pll_data(clk);
+	unsigned int val;
+	struct clk_hw *parent = clk_hw_get_parent(hw);
+	bool first_set = true;
+	u64 rate;
+
+	if (meson_parm_read(clk->map, &pll->en))
+		return 0;
+
+	if (!strcmp(clk_hw_get_name(hw), "sys_pll_dco") ||
+	    !strcmp(clk_hw_get_name(hw), "gp1_pll_dco")) {
+		regmap_read(clk->map, (&pll->en)->reg_off + (6 * 4), &val);
+		if (val == 0x56540000)
+			first_set = false;
+	}
+
+	/*First init, just set minimal rate.*/
+	if (first_set) {
+		rate = __pll_params_to_rate(clk_hw_get_rate(parent), pll->table[0].m,
+					    pll->table[0].n, 0, pll);
+	} else {
+		rate = meson_clk_pll_recalc_rate(hw, clk_hw_get_rate(parent));
+		rate = meson_secure_clk_pll_round_rate(hw, rate, NULL);
+	}
+
+	return meson_secure_clk_pll_set_rate(hw, rate, clk_hw_get_rate(parent));
+}
+
+static void meson_secure_clk_pll_disable(struct clk_hw *hw)
+{
+	struct arm_smccc_res res;
+
+	if (!strcmp(clk_hw_get_name(hw), "sys_pll_dco"))
+		arm_smccc_smc(CLK_SECURE_RW, SYS_PLL_DISABLE, 0, 0, 0, 0, 0, 0, &res);
+	else
+		arm_smccc_smc(CLK_SECURE_RW, GP1_PLL_DISABLE, 0, 0, 0, 0, 0, 0, &res);
+}
+
 /*
  * The Meson G12A PCIE PLL is fined tuned to deliver a very precise
  * 100MHz reference clock for the PCIe Analog PHY, and thus requires
@@ -451,6 +539,15 @@ const struct clk_ops meson_clk_pll_ro_ops = {
 };
 EXPORT_SYMBOL_GPL(meson_clk_pll_ro_ops);

+const struct clk_ops meson_secure_clk_pll_ops = {
+	.recalc_rate	= meson_clk_pll_recalc_rate,
+	.round_rate	= meson_secure_clk_pll_round_rate,
+	.set_rate	= meson_secure_clk_pll_set_rate,
+	.enable		= meson_secure_clk_pll_enable,
+	.disable	= meson_secure_clk_pll_disable
+};
+EXPORT_SYMBOL_GPL(meson_secure_clk_pll_ops);
+
 MODULE_DESCRIPTION("Amlogic PLL driver");
 MODULE_AUTHOR("Carlo Caione <carlo@endlessm.com>");
 MODULE_AUTHOR("Jerome Brunet <jbrunet@baylibre.com>");
diff --git a/drivers/clk/meson/clk-secure.h b/drivers/clk/meson/clk-secure.h
new file mode 100644
index 000000000..d6fcbb0f9
--- /dev/null
+++ b/drivers/clk/meson/clk-secure.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ *
+ * Copyright (c) 2018 Amlogic, inc.
+ *
+ */
+
+#ifndef __CLK_SECURE_H
+#define __CLK_SECURE_H
+
+/*for sc2 secure*/
+#define CLK_SECURE_RW		0x8200009A
+#define CPUCLK_SECURE_RW	0x8200009B
+
+#define CLK_SMC_READ 0
+#define CLK_SMC_WRITE 1
+
+#define SYS_PLL_STEP0 0
+#define SYS_PLL_STEP1 1
+#define SYS_PLL_DISABLE 2
+#define GP1_PLL_STEP0 3
+#define GP1_PLL_STEP1 4
+#define GP1_PLL_DISABLE 5
+#define CLK_REG_RW 6
+
+#define CLK_CPU_REG_RW 0
+#define CLK_DSU_REG_RW 1
+#define CPU_CLK_SET_PARENT 2
+#define DSU_CLK_SET_PARENT 3
+#define CPU_CLK_SET_RATE 4
+#define DSU_CLK_SET_RATE 5
+#define CLK_CPU_DSU_REG_RW 6
+#define SET_CPU0_MUX_PARENT 7
+#define SET_CPU123_DSU_MUX_PARENT 8
+#define SET_DSU_PRE_MUX_PARENT 9
+#define DSU_DIVIDER_SET_RATE 10
+#define CPU_DIVIDER_SET_RATE 11
+
+extern const struct clk_ops meson_secure_clk_pll_ops; /* for sc2 secure pll*/
+extern const struct clk_ops meson_clk_regmap_secure_divider_ops;
+extern const struct clk_ops meson_clk_regmap_secure_divider_ro_ops;
+extern const struct clk_ops meson_clk_regmap_secure_mux_ops;
+extern const struct clk_ops meson_clk_regmap_secure_mux_ro_ops;
+extern const struct clk_ops meson_secure_clk_cpu_dyndiv_ops;
+
+#endif /* __CLK_SECURE_H */
+
diff --git a/drivers/clk/meson/sc2.c b/drivers/clk/meson/sc2.c
new file mode 100644
index 000000000..21b9067df
--- /dev/null
+++ b/drivers/clk/meson/sc2.c
@@ -0,0 +1,6176 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Amlogic Meson-SC2 Clock Controller Driver
+ *
+ * Copyright (c) 2018 Amlogic, inc.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/init.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+
+#include "clk-mpll.h"
+#include "clk-pll.h"
+#include "clk-regmap.h"
+#include "clk-secure.h"
+#include "clk-cpu-dyndiv.h"
+#include "vid-pll-div.h"
+#include "clk-dualdiv.h"
+#include "sc2.h"
+#include <dt-bindings/clock/amlogic,sc2-clkc.h>
+
+static DEFINE_SPINLOCK(meson_clk_lock);
+
+static struct clk_regmap sc2_fixed_pll_dco = {
+	.data = &(struct meson_clk_pll_data){
+		.en = {
+			.reg_off = ANACTRL_FIXPLL_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.m = {
+			.reg_off = ANACTRL_FIXPLL_CTRL0,
+			.shift   = 0,
+			.width   = 8,
+		},
+		.n = {
+			.reg_off = ANACTRL_FIXPLL_CTRL0,
+			.shift   = 10,
+			.width   = 5,
+		},
+		.frac = {
+			.reg_off = ANACTRL_FIXPLL_CTRL1,
+			.shift   = 0,
+			.width   = 19,
+		},
+		.l = {
+			.reg_off = ANACTRL_FIXPLL_CTRL0,
+			.shift   = 31,
+			.width   = 1,
+		},
+		.rst = {
+			.reg_off = ANACTRL_FIXPLL_CTRL0,
+			.shift   = 29,
+			.width   = 1,
+		},
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "fixed_pll_dco",
+		.ops = &meson_clk_pll_ro_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+		.flags = CLK_IS_CRITICAL | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_fixed_pll = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = ANACTRL_FIXPLL_CTRL0,
+		.shift = 16,
+		.width = 2,
+		.flags = CLK_DIVIDER_POWER_OF_TWO,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "fixed_pll",
+		.ops = &clk_regmap_divider_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fixed_pll_dco.hw
+		},
+		.num_parents = 1,
+		/*
+		 * This clock won't ever change at runtime so
+		 * CLK_SET_RATE_PARENT is not required
+		 */
+		.flags = CLK_IS_CRITICAL | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static const struct clk_ops meson_pll_clk_no_ops = {};
+
+/*
+ * the sys pll DCO value should be 3G~6G,
+ * otherwise the sys pll can not lock.
+ * od is for 32 bit.
+ */
+
+static const struct pll_params_table sc2_sys_pll_params_table[] = {
+	PLL_PARAMS(168, 1), /*DCO=4032M OD=1008M*/
+	PLL_PARAMS(184, 1), /*DCO=4416M OD=1104M*/
+	PLL_PARAMS(200, 1), /*DCO=4800M OD=1200M*/
+	PLL_PARAMS(216, 1), /*DCO=5184M OD=1296M*/
+	PLL_PARAMS(233, 1), /*DCO=5592M OD=1398M*/
+	PLL_PARAMS(234, 1), /*DCO=5616M OD=1404M*/
+	PLL_PARAMS(249, 1), /*DCO=5976M OD=1494M*/
+	PLL_PARAMS(125, 1), /*DCO=3000M OD=1500M*/
+	PLL_PARAMS(126, 1), /*DCO=3024M OD=1512M*/
+	PLL_PARAMS(134, 1), /*DCO=3216M OD=1608M*/
+	PLL_PARAMS(142, 1), /*DCO=3408M OD=1704M*/
+	PLL_PARAMS(150, 1), /*DCO=3600M OD=1800M*/
+	PLL_PARAMS(158, 1), /*DCO=3792M OD=1896M*/
+	PLL_PARAMS(159, 1), /*DCO=3816M OD=1908*/
+	PLL_PARAMS(160, 1), /*DCO=3840M OD=1920M*/
+	PLL_PARAMS(167, 1), /*DCO=4008M OD=2004M*/
+	{ /* sentinel */ }
+};
+
+static struct clk_regmap sc2_sys_pll_dco = {
+	.data = &(struct meson_clk_pll_data){
+		.en = {
+			.reg_off = ANACTRL_SYSPLL_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.m = {
+			.reg_off = ANACTRL_SYSPLL_CTRL0,
+			.shift   = 0,
+			.width   = 8,
+		},
+		.n = {
+			.reg_off = ANACTRL_SYSPLL_CTRL0,
+			.shift   = 10,
+			.width   = 5,
+		},
+		.table = sc2_sys_pll_params_table,
+		.l = {
+			.reg_off = ANACTRL_SYSPLL_CTRL0,
+			.shift   = 31,
+			.width   = 1,
+		},
+		.rst = {
+			.reg_off = ANACTRL_SYSPLL_CTRL0,
+			.shift   = 29,
+			.width   = 1,
+		},
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sys_pll_dco",
+		.ops = &meson_secure_clk_pll_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+		/* This clock feeds the CPU, avoid disabling it */
+		.flags = CLK_IS_CRITICAL,
+	},
+};
+
+static struct clk_regmap sc2_sys_pll = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = ANACTRL_SYSPLL_CTRL0,
+		.shift = 16,
+		.width = 3,
+		.flags = CLK_DIVIDER_POWER_OF_TWO,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sys_pll",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_sys_pll_dco.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_fixed_factor sc2_fclk_div2_div = {
+	.mult = 1,
+	.div = 2,
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div2_div",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_fixed_pll.hw },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_fclk_div2 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_FIXPLL_CTRL1,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div2",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fclk_div2_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_IS_CRITICAL,
+	},
+};
+
+static struct clk_fixed_factor sc2_fclk_div3_div = {
+	.mult = 1,
+	.div = 3,
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div3_div",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_fixed_pll.hw },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_fclk_div3 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_FIXPLL_CTRL1,
+		.bit_idx = 20,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div3",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fclk_div3_div.hw
+		},
+		.num_parents = 1,
+		/*
+		 * This clock is used by the resident firmware and is required
+		 * by the platform to operate correctly.
+		 * Until the following condition are met, we need this clock to
+		 * be marked as critical:
+		 * a) Mark the clock used by a firmware resource, if possible
+		 * b) CCF has a clock hand-off mechanism to make the sure the
+		 *    clock stays on until the proper driver comes along
+		 */
+		.flags = CLK_IS_CRITICAL,
+	},
+};
+
+static struct clk_fixed_factor sc2_fclk_div4_div = {
+	.mult = 1,
+	.div = 4,
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div4_div",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_fixed_pll.hw },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_fclk_div4 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_FIXPLL_CTRL1,
+		.bit_idx = 21,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div4",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fclk_div4_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_IS_CRITICAL,
+	},
+};
+
+static struct clk_fixed_factor sc2_fclk_div5_div = {
+	.mult = 1,
+	.div = 5,
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div5_div",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_fixed_pll.hw },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_fclk_div5 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_FIXPLL_CTRL1,
+		.bit_idx = 22,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div5",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fclk_div5_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_IS_CRITICAL,
+	},
+};
+
+static struct clk_fixed_factor sc2_fclk_div7_div = {
+	.mult = 1,
+	.div = 7,
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div7_div",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_fixed_pll.hw },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_fclk_div7 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_FIXPLL_CTRL1,
+		.bit_idx = 23,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div7",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fclk_div7_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_IS_CRITICAL,
+	},
+};
+
+static struct clk_fixed_factor sc2_fclk_div2p5_div = {
+	.mult = 2,
+	.div = 5,
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div2p5_div",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fixed_pll.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_fclk_div2p5 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_FIXPLL_CTRL1,
+		.bit_idx = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "fclk_div2p5",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fclk_div2p5_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_IS_CRITICAL,
+	},
+};
+
+static const struct pll_params_table sc2_gp0_pll_table[] = {
+	PLL_PARAMS(141, 1), /* DCO = 3384M OD = 2 PLL = 846M */
+	PLL_PARAMS(132, 1), /* DCO = 3168M OD = 2 PLL = 792M */
+	PLL_PARAMS(248, 1), /* DCO = 5952M OD = 3 PLL = 744M */
+	{ /* sentinel */  }
+};
+
+/*
+ * Internal gp0 pll emulation configuration parameters
+ */
+static const struct reg_sequence sc2_gp0_init_regs[] = {
+	{ .reg = ANACTRL_GP0PLL_CTRL1,	.def = 0x00000000 },
+	{ .reg = ANACTRL_GP0PLL_CTRL2,	.def = 0x00000000 },
+	{ .reg = ANACTRL_GP0PLL_CTRL3,	.def = 0x48681c00 },
+	{ .reg = ANACTRL_GP0PLL_CTRL4,	.def = 0x88770290 },
+	{ .reg = ANACTRL_GP0PLL_CTRL5,	.def = 0x39272000 },
+	{ .reg = ANACTRL_GP0PLL_CTRL6,	.def = 0x56540000 }
+};
+
+static struct clk_regmap sc2_gp0_pll_dco = {
+	.data = &(struct meson_clk_pll_data){
+		.en = {
+			.reg_off = ANACTRL_GP0PLL_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.m = {
+			.reg_off = ANACTRL_GP0PLL_CTRL0,
+			.shift   = 0,
+			.width   = 8,
+		},
+		.n = {
+			.reg_off = ANACTRL_GP0PLL_CTRL0,
+			.shift   = 10,
+			.width   = 5,
+		},
+		.frac = {
+			.reg_off = ANACTRL_GP0PLL_CTRL1,
+			.shift   = 0,
+			.width   = 19,
+		},
+		.l = {
+			.reg_off = ANACTRL_GP0PLL_CTRL0,
+			.shift   = 31,
+			.width   = 1,
+		},
+		.rst = {
+			.reg_off = ANACTRL_GP0PLL_CTRL0,
+			.shift   = 29,
+			.width   = 1,
+		},
+		.table = sc2_gp0_pll_table,
+		.init_regs = sc2_gp0_init_regs,
+		.init_count = ARRAY_SIZE(sc2_gp0_init_regs),
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "gp0_pll_dco",
+		.ops = &meson_clk_pll_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_gp0_pll = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = ANACTRL_GP0PLL_CTRL0,
+		.shift = 16,
+		.width = 3,
+		.flags = (CLK_DIVIDER_POWER_OF_TWO |
+			  CLK_DIVIDER_ROUND_CLOSEST),
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "gp0_pll",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_gp0_pll_dco.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static const struct pll_params_table sc2_gp1_pll_table[] = {
+	PLL_PARAMS(200, 1), /*DCO=4800M OD=1200M*/
+	PLL_PARAMS(125, 1), /*DCO=3000M OD=1500M*/
+	{ /* sentinel */  }
+};
+
+static struct clk_regmap sc2_gp1_pll_dco = {
+	.data = &(struct meson_clk_pll_data){
+		.en = {
+			.reg_off = ANACTRL_GP1PLL_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.m = {
+			.reg_off = ANACTRL_GP1PLL_CTRL0,
+			.shift   = 0,
+			.width   = 8,
+		},
+		.n = {
+			.reg_off = ANACTRL_GP1PLL_CTRL0,
+			.shift   = 10,
+			.width   = 5,
+		},
+		.frac = {
+			.reg_off = ANACTRL_GP1PLL_CTRL1,
+			.shift   = 0,
+			.width   = 19,
+		},
+		.l = {
+			.reg_off = ANACTRL_GP1PLL_CTRL0,
+			.shift   = 31,
+			.width   = 1,
+		},
+		.rst = {
+			.reg_off = ANACTRL_GP1PLL_CTRL0,
+			.shift   = 29,
+			.width   = 1,
+		},
+		.table = sc2_gp1_pll_table,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "gp1_pll_dco",
+		.ops = &meson_secure_clk_pll_ops,
+		.parent_data = &(const struct clk_parent_data) {
+			.fw_name = "xtal",
+		},
+		.num_parents = 1,
+		/* This clock feeds the DSU, avoid disabling it */
+		.flags = CLK_GET_RATE_NOCACHE | CLK_IS_CRITICAL,
+	},
+};
+
+static struct clk_regmap sc2_gp1_pll = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = ANACTRL_GP1PLL_CTRL0,
+		.shift = 16,
+		.width = 3,
+		.flags = (CLK_DIVIDER_POWER_OF_TWO |
+			  CLK_DIVIDER_ROUND_CLOSEST),
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "gp1_pll",
+		.ops = &clk_regmap_divider_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_gp1_pll_dco.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cpu_clk*/
+/* Datasheet names this field as "premux0" */
+static struct clk_regmap sc2_cpu_clk_premux0 = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL,
+		.mask = 0x3,
+		.shift = 0,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu_clk_dyn0_sel",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_data = (const struct clk_parent_data []) {
+			{ .fw_name = "xtal", },
+			{ .hw = &sc2_fclk_div2.hw },
+			{ .hw = &sc2_fclk_div3.hw },
+		},
+		.num_parents = 3,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* Datasheet names this field as "premux1" */
+static struct clk_regmap sc2_cpu_clk_premux1 = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL,
+		.mask = 0x3,
+		.shift = 16,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu_clk_dyn1_sel",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_data = (const struct clk_parent_data []) {
+			{ .fw_name = "xtal", },
+			{ .hw = &sc2_fclk_div2.hw },
+			{ .hw = &sc2_fclk_div3.hw },
+		},
+		.num_parents = 3,
+		/* This sub-tree is used a parking clock */
+		.flags = CLK_SET_RATE_NO_REPARENT
+	},
+};
+
+/* Datasheet names this field as "mux0_divn_tcnt" */
+static struct clk_regmap sc2_cpu_clk_mux0_div = {
+	.data = &(struct meson_clk_cpu_dyndiv_data){
+		.div = {
+			.reg_off = CPUCTRL_SYS_CPU_CLK_CTRL,
+			.shift = 4,
+			.width = 6,
+		},
+		.dyn = {
+			.reg_off = CPUCTRL_SYS_CPU_CLK_CTRL,
+			.shift = 26,
+			.width = 1,
+		},
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu_clk_dyn0_div",
+		.ops = &meson_secure_clk_cpu_dyndiv_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk_premux0.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* Datasheet names this field as "postmux0" */
+static struct clk_regmap sc2_cpu_clk_postmux0 = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL,
+		.mask = 0x1,
+		.shift = 2,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu_clk_dyn0",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk_premux0.hw,
+			&sc2_cpu_clk_mux0_div.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* Datasheet names this field as "Mux1_divn_tcnt" */
+static struct clk_regmap sc2_cpu_clk_mux1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL,
+		.shift = 20,
+		.width = 6,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu_clk_dyn1_div",
+		.ops = &meson_clk_regmap_secure_divider_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk_premux1.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+/* Datasheet names this field as "postmux1" */
+static struct clk_regmap sc2_cpu_clk_postmux1 = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL,
+		.mask = 0x1,
+		.shift = 18,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu_clk_dyn1",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk_premux1.hw,
+			&sc2_cpu_clk_mux1_div.hw,
+		},
+		.num_parents = 2,
+		/* This sub-tree is used a parking clock */
+		.flags = CLK_SET_RATE_NO_REPARENT,
+	},
+};
+
+/* Datasheet names this field as "Final_dyn_mux_sel" */
+static struct clk_regmap sc2_cpu_clk_dyn = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL,
+		.mask = 0x1,
+		.shift = 10,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu_clk_dyn",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk_postmux0.hw,
+			&sc2_cpu_clk_postmux1.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* Datasheet names this field as "Final_mux_sel" */
+static struct clk_regmap sc2_cpu_clk = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL,
+		.mask = 0x1,
+		.shift = 11,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu_clk",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk_dyn.hw,
+			&sc2_sys_pll.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/*dsu_clk*/
+/* Datasheet names this field as "Final_mux_sel" */
+/* Datasheet names this field as "premux0" */
+static struct clk_regmap sc2_dsu_clk_premux0 = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL5,
+		.mask = 0x3,
+		.shift = 0,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dsu_clk_dyn0_sel",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_data = (const struct clk_parent_data []) {
+			{ .fw_name = "xtal", },
+			{ .hw = &sc2_fclk_div2.hw },
+			{ .hw = &sc2_fclk_div3.hw },
+			{ .hw = &sc2_gp1_pll.hw },
+		},
+		.num_parents = 4,
+		.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
+	},
+};
+
+/* Datasheet names this field as "premux1" */
+static struct clk_regmap sc2_dsu_clk_premux1 = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL5,
+		.mask = 0x3,
+		.shift = 16,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dsu_clk_dyn1_sel",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_data = (const struct clk_parent_data []) {
+			{ .fw_name = "xtal", },
+			{ .hw = &sc2_fclk_div2.hw },
+			{ .hw = &sc2_fclk_div3.hw },
+			{ .hw = &sc2_gp1_pll.hw },
+		},
+		.num_parents = 4,
+		.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
+	},
+};
+
+/* Datasheet names this field as "Mux0_divn_tcnt" */
+static struct clk_regmap sc2_dsu_clk_mux0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL5,
+		.shift = 4,
+		.width = 6,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dsu_clk_dyn0_div",
+		.ops = &meson_clk_regmap_secure_divider_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dsu_clk_premux0.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* Datasheet names this field as "postmux0" */
+static struct clk_regmap sc2_dsu_clk_postmux0 = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL5,
+		.mask = 0x1,
+		.shift = 2,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dsu_clk_dyn0",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dsu_clk_premux0.hw,
+			&sc2_dsu_clk_mux0_div.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* Datasheet names this field as "Mux1_divn_tcnt" */
+static struct clk_regmap sc2_dsu_clk_mux1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL5,
+		.shift = 20,
+		.width = 6,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dsu_clk_dyn1_div",
+		.ops = &meson_clk_regmap_secure_divider_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dsu_clk_premux1.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* Datasheet names this field as "postmux1" */
+static struct clk_regmap sc2_dsu_clk_postmux1 = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL5,
+		.mask = 0x1,
+		.shift = 18,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dsu_clk_dyn1",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dsu_clk_premux1.hw,
+			&sc2_dsu_clk_mux1_div.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* Datasheet names this field as "Final_dyn_mux_sel" */
+static struct clk_regmap sc2_dsu_clk_dyn = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL5,
+		.mask = 0x1,
+		.shift = 10,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dsu_clk_dyn",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dsu_clk_postmux0.hw,
+			&sc2_dsu_clk_postmux1.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
+	},
+};
+
+/* Datasheet names this field as "Final_mux_sel" */
+static struct clk_regmap sc2_dsu_final_clk = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL5,
+		.mask = 0x1,
+		.shift = 11,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dsu_clk_final",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dsu_clk_dyn.hw,
+			&sc2_sys_pll.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
+	},
+};
+
+/* Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 0 */
+static struct clk_regmap sc2_cpu1_clk = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL6,
+		.mask = 0x1,
+		.shift = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu1_clk",
+		.ops = &meson_clk_regmap_secure_mux_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk.hw,
+			/* This CPU also have a dedicated clock tree */
+		},
+		.num_parents = 1,
+	},
+};
+
+/* Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 1 */
+static struct clk_regmap sc2_cpu2_clk = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL6,
+		.mask = 0x1,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu2_clk",
+		.ops = &meson_clk_regmap_secure_mux_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk.hw,
+			/* This CPU also have a dedicated clock tree */
+		},
+		.num_parents = 1,
+	},
+};
+
+/* Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 2 */
+static struct clk_regmap sc2_cpu3_clk = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL6,
+		.mask = 0x1,
+		.shift = 26,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cpu3_clk",
+		.ops = &meson_clk_regmap_secure_mux_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk.hw,
+			/* This CPU also have a dedicated clock tree */
+		},
+		.num_parents = 1,
+	},
+};
+
+/* Datasheet names this field as "Cpu_clk_sync_mux_sel" bit 4 */
+static struct clk_regmap sc2_dsu_clk = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CPUCTRL_SYS_CPU_CLK_CTRL6,
+		.mask = 0x1,
+		.shift = 27,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dsu_clk",
+		.ops = &meson_clk_regmap_secure_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cpu_clk.hw,
+			&sc2_dsu_final_clk.hw,
+		},
+		.num_parents = 2,
+	},
+};
+
+struct sc2_cpu_clk_postmux_nb_data {
+	struct notifier_block nb;
+	struct clk_hw *fclk_div2;
+	struct clk_hw *cpu_clk_dyn;
+	struct clk_hw *cpu_clk_postmux0;
+	struct clk_hw *cpu_clk_postmux1;
+	struct clk_hw *cpu_clk_premux1;
+};
+
+static int sc2_cpu_clk_postmux_notifier_cb(struct notifier_block *nb,
+					   unsigned long event, void *data)
+{
+	struct sc2_cpu_clk_postmux_nb_data *nb_data =
+		container_of(nb, struct sc2_cpu_clk_postmux_nb_data, nb);
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		/*
+		 * This notifier means cpu_clk_postmux0 clock will be changed
+		 * to feed cpu_clk, this is the current path :
+		 * cpu_clk
+		 *    \- cpu_clk_dyn
+		 *          \- cpu_clk_postmux0
+		 *                \- cpu_clk_muxX_div
+		 *                      \- cpu_clk_premux0
+		 *				\- fclk_div3 or fclk_div2
+		 *		OR
+		 *                \- cpu_clk_premux0
+		 *			\- fclk_div3 or fclk_div2
+		 */
+
+		/* Setup cpu_clk_premux1 to fclk_div2 */
+		clk_hw_set_parent(nb_data->cpu_clk_premux1,
+				  nb_data->fclk_div2);
+
+		/* Setup cpu_clk_postmux1 to bypass divider */
+		clk_hw_set_parent(nb_data->cpu_clk_postmux1,
+				  nb_data->cpu_clk_premux1);
+
+		/* Switch to parking clk on cpu_clk_postmux1 */
+		clk_hw_set_parent(nb_data->cpu_clk_dyn,
+				  nb_data->cpu_clk_postmux1);
+
+		/*
+		 * Now, cpu_clk is fclk_div2 in the current path :
+		 * cpu_clk
+		 *    \- cpu_clk_dyn
+		 *          \- cpu_clk_postmux1
+		 *                \- cpu_clk_premux1
+		 *                      \- fclk_div2
+		 */
+
+		return NOTIFY_OK;
+
+	case POST_RATE_CHANGE:
+		/*
+		 * The cpu_clk_postmux0 has ben updated, now switch back
+		 * cpu_clk_dyn to cpu_clk_postmux0 and take the changes
+		 * in account.
+		 */
+
+		/* Configure cpu_clk_dyn back to cpu_clk_postmux0 */
+		clk_hw_set_parent(nb_data->cpu_clk_dyn,
+				  nb_data->cpu_clk_postmux0);
+
+		/*
+		 * new path :
+		 * cpu_clk
+		 *    \- cpu_clk_dyn
+		 *          \- cpu_clk_postmux0
+		 *                \- cpu_clk_muxX_div
+		 *                      \- cpu_clk_premux0
+		 *				\- fclk_div3 or fclk_div2
+		 *		OR
+		 *                \- cpu_clk_premux0
+		 *			\- fclk_div3 or fclk_div2
+		 */
+
+		return NOTIFY_OK;
+
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static struct sc2_cpu_clk_postmux_nb_data sc2_cpu_clk_postmux0_nb_data = {
+	.cpu_clk_dyn = &sc2_cpu_clk_dyn.hw,
+	.cpu_clk_postmux0 = &sc2_cpu_clk_postmux0.hw,
+	.cpu_clk_postmux1 = &sc2_cpu_clk_postmux1.hw,
+	.cpu_clk_premux1 = &sc2_cpu_clk_premux1.hw,
+	.nb.notifier_call = sc2_cpu_clk_postmux_notifier_cb,
+};
+
+struct sc2_sys_pll_nb_data {
+	struct notifier_block nb;
+	struct clk_hw *sys_pll;
+	struct clk_hw *cpu_clk;
+	struct clk_hw *cpu_clk_dyn;
+};
+
+static int sc2_sys_pll_notifier_cb(struct notifier_block *nb,
+				   unsigned long event, void *data)
+{
+	struct sc2_sys_pll_nb_data *nb_data =
+		container_of(nb, struct sc2_sys_pll_nb_data, nb);
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		/*
+		 * This notifier means sys_pll clock will be changed
+		 * to feed cpu_clk, this the current path :
+		 * cpu_clk
+		 *    \- sys_pll
+		 *          \- sys_pll_dco
+		 */
+
+		/* Configure cpu_clk to use cpu_clk_dyn */
+		clk_hw_set_parent(nb_data->cpu_clk,
+				  nb_data->cpu_clk_dyn);
+
+		/*
+		 * Now, cpu_clk uses the dyn path
+		 * cpu_clk
+		 *    \- cpu_clk_dyn
+		 *          \- cpu_clk_dynX
+		 *                \- cpu_clk_dynX_sel
+		 *		     \- cpu_clk_dynX_div
+		 *                      \- xtal/fclk_div2/fclk_div3
+		 *                   \- xtal/fclk_div2/fclk_div3
+		 */
+
+		return NOTIFY_OK;
+
+	case POST_RATE_CHANGE:
+		/*
+		 * The sys_pll has ben updated, now switch back cpu_clk to
+		 * sys_pll
+		 */
+
+		/* Configure cpu_clk to use sys_pll */
+		clk_hw_set_parent(nb_data->cpu_clk,
+				  nb_data->sys_pll);
+
+		/* new path :
+		 * cpu_clk
+		 *    \- sys_pll
+		 *          \- sys_pll_dco
+		 */
+
+		return NOTIFY_OK;
+
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static struct sc2_sys_pll_nb_data sc2_sys_pll_nb_data = {
+	.sys_pll = &sc2_sys_pll.hw,
+	.cpu_clk = &sc2_cpu_clk.hw,
+	.cpu_clk_dyn = &sc2_cpu_clk_dyn.hw,
+	.nb.notifier_call = sc2_sys_pll_notifier_cb,
+};
+
+/* sc2 dsu notify */
+struct sc2_dsu_clk_postmux_nb_data {
+	struct notifier_block nb;
+	struct clk_hw *dsu_clk_dyn;
+	struct clk_hw *dsu_clk_postmux0;
+	struct clk_hw *dsu_clk_postmux1;
+};
+
+static int sc2_dsu_clk_postmux_notifier_cb(struct notifier_block *nb,
+					   unsigned long event, void *data)
+{
+	struct sc2_dsu_clk_postmux_nb_data *nb_data =
+		container_of(nb, struct sc2_dsu_clk_postmux_nb_data, nb);
+	int ret = 0;
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		ret = clk_hw_set_parent(nb_data->dsu_clk_dyn,
+					nb_data->dsu_clk_postmux1);
+		if (ret)
+			return notifier_from_errno(ret);
+		return NOTIFY_OK;
+	case POST_RATE_CHANGE:
+		ret = clk_hw_set_parent(nb_data->dsu_clk_dyn,
+					nb_data->dsu_clk_postmux0);
+		if (ret)
+			return notifier_from_errno(ret);
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static struct sc2_dsu_clk_postmux_nb_data sc2_dsu_clk_postmux0_nb_data = {
+	.dsu_clk_dyn = &sc2_dsu_clk_dyn.hw,
+	.dsu_clk_postmux0 = &sc2_dsu_clk_postmux0.hw,
+	.dsu_clk_postmux1 = &sc2_dsu_clk_postmux1.hw,
+	.nb.notifier_call = sc2_dsu_clk_postmux_notifier_cb,
+};
+
+static const struct pll_params_table sc2_hifi_pll_table[] = {
+	PLL_PARAMS(150, 1), /* DCO = 1806.336M */
+	{ /* sentinel */  }
+};
+
+/*
+ * Internal hifi pll emulation configuration parameters
+ */
+static const struct reg_sequence sc2_hifi_init_regs[] = {
+	{ .reg = ANACTRL_HIFIPLL_CTRL1,	.def = 0x00010e56 },
+	{ .reg = ANACTRL_HIFIPLL_CTRL2,	.def = 0x00000000 },
+	{ .reg = ANACTRL_HIFIPLL_CTRL3,	.def = 0x6a285c00 },
+	{ .reg = ANACTRL_HIFIPLL_CTRL4,	.def = 0x65771290 },
+	{ .reg = ANACTRL_HIFIPLL_CTRL5,	.def = 0x39272000 },
+	{ .reg = ANACTRL_HIFIPLL_CTRL6,	.def = 0x56540000 }
+};
+
+static struct clk_regmap sc2_hifi_pll_dco = {
+	.data = &(struct meson_clk_pll_data){
+		.en = {
+			.reg_off = ANACTRL_HIFIPLL_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.m = {
+			.reg_off = ANACTRL_HIFIPLL_CTRL0,
+			.shift   = 0,
+			.width   = 8,
+		},
+		.n = {
+			.reg_off = ANACTRL_HIFIPLL_CTRL0,
+			.shift   = 10,
+			.width   = 5,
+		},
+		.frac = {
+			.reg_off = ANACTRL_HIFIPLL_CTRL1,
+			.shift   = 0,
+			.width   = 19,
+		},
+		.l = {
+			.reg_off = ANACTRL_HIFIPLL_CTRL0,
+			.shift   = 31,
+			.width   = 1,
+		},
+		.rst = {
+			.reg_off = ANACTRL_HIFIPLL_CTRL0,
+			.shift   = 29,
+			.width   = 1,
+		},
+		.table = sc2_hifi_pll_table,
+		.init_regs = sc2_hifi_init_regs,
+		.init_count = ARRAY_SIZE(sc2_hifi_init_regs),
+		.flags = CLK_MESON_PLL_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hifi_pll_dco",
+		.ops = &meson_clk_pll_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_hifi_pll = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = ANACTRL_HIFIPLL_CTRL0,
+		.shift = 16,
+		.width = 2,
+		.flags = (CLK_DIVIDER_POWER_OF_TWO |
+			  CLK_DIVIDER_ROUND_CLOSEST),
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hifi_pll",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hifi_pll_dco.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+/*
+ * The Meson sc2 PCIE PLL is fined tuned to deliver a very precise
+ * 100MHz reference clock for the PCIe Analog PHY, and thus requires
+ * a strict register sequence to enable the PLL.
+ */
+static const struct reg_sequence sc2_pcie_pll_init_regs[] = {
+	{ .reg = ANACTRL_PCIEPLL_CTRL0,	.def = 0x200c04c8 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL0,	.def = 0x300c04c8 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL1,	.def = 0x30000000 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL2,	.def = 0x00001100 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL3,	.def = 0x10058e00 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL4,	.def = 0x000100c0 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL5,	.def = 0x68000040 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL5,	.def = 0x68000060, .delay_us = 20 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL4,	.def = 0x008100c0, .delay_us = 10 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL0,	.def = 0x340c04c8 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL0,	.def = 0x140c04c8, .delay_us = 10 },
+	{ .reg = ANACTRL_PCIEPLL_CTRL2,	.def = 0x00001000 }
+};
+
+/* Keep a single entry table for recalc/round_rate() ops */
+static const struct pll_params_table sc2_pcie_pll_table[] = {
+	PLL_PARAMS(200, 1),
+	{0, 0}
+};
+
+static struct clk_regmap sc2_pcie_pll_dco = {
+	.data = &(struct meson_clk_pll_data){
+		.en = {
+			.reg_off = ANACTRL_PCIEPLL_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.m = {
+			.reg_off = ANACTRL_PCIEPLL_CTRL0,
+			.shift   = 0,
+			.width   = 8,
+		},
+		.n = {
+			.reg_off = ANACTRL_PCIEPLL_CTRL0,
+			.shift   = 10,
+			.width   = 5,
+		},
+		.frac = {
+			.reg_off = ANACTRL_PCIEPLL_CTRL1,
+			.shift   = 0,
+			.width   = 12,
+		},
+		.l = {
+			.reg_off = ANACTRL_PCIEPLL_CTRL0,
+			.shift   = 31,
+			.width   = 1,
+		},
+		.rst = {
+			.reg_off = ANACTRL_PCIEPLL_CTRL0,
+			.shift   = 29,
+			.width   = 1,
+		},
+		.table = sc2_pcie_pll_table,
+		.init_regs = sc2_pcie_pll_init_regs,
+		.init_count = ARRAY_SIZE(sc2_pcie_pll_init_regs),
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pcie_pll_dco",
+		.ops = &meson_clk_pcie_pll_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_fixed_factor sc2_pcie_pll_dco_div2 = {
+	.mult = 1,
+	.div = 2,
+	.hw.init = &(struct clk_init_data){
+		.name = "pcie_pll_dco_div2",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pcie_pll_dco.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_pcie_pll_od = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = ANACTRL_PCIEPLL_CTRL0,
+		.shift = 16,
+		.width = 5,
+		.flags = CLK_DIVIDER_ROUND_CLOSEST |
+			 CLK_DIVIDER_ONE_BASED |
+			 CLK_DIVIDER_ALLOW_ZERO,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pcie_pll_od",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pcie_pll_dco_div2.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_fixed_factor sc2_pcie_pll = {
+	.mult = 1,
+	.div = 2,
+	.hw.init = &(struct clk_init_data){
+		.name = "pcie_pll",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pcie_pll_od.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_pcie_bgp = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_PCIEPLL_CTRL5,
+		.bit_idx = 27,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pcie_bgp",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_pcie_pll.hw },
+		.num_parents = 1,
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pcie_hcsl = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_PCIEPLL_CTRL5,
+		.bit_idx = 3,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pcie_hcsl",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_pcie_bgp.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_hdmi_pll_dco = {
+	.data = &(struct meson_clk_pll_data){
+		.en = {
+			.reg_off = ANACTRL_HDMIPLL_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.m = {
+			.reg_off = ANACTRL_HDMIPLL_CTRL0,
+			.shift   = 0,
+			.width   = 8,
+		},
+		.n = {
+			.reg_off = ANACTRL_HDMIPLL_CTRL0,
+			.shift   = 10,
+			.width   = 5,
+		},
+		.frac = {
+			.reg_off = ANACTRL_HDMIPLL_CTRL1,
+			.shift   = 0,
+			.width   = 19,
+		},
+		.l = {
+			.reg_off = ANACTRL_HDMIPLL_CTRL0,
+			.shift   = 31,
+			.width   = 1,
+		},
+		.rst = {
+			.reg_off = ANACTRL_HDMIPLL_CTRL0,
+			.shift   = 29,
+			.width   = 1,
+		},
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hdmi_pll_dco",
+		.ops = &meson_clk_pll_ro_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+		/*
+		 * Display directly handle hdmi pll registers ATM, we need
+		 * NOCACHE to keep our view of the clock as accurate as
+		 * possible
+		 */
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_hdmi_pll_od = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = ANACTRL_HDMIPLL_CTRL0,
+		.shift = 16,
+		.width = 4,
+		.flags = CLK_DIVIDER_POWER_OF_TWO,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hdmi_pll_od",
+		.ops = &clk_regmap_divider_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hdmi_pll_dco.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hdmi_pll = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = ANACTRL_HDMIPLL_CTRL0,
+		.shift = 20,
+		.width = 2,
+		.flags = CLK_DIVIDER_POWER_OF_TWO,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hdmi_pll",
+		.ops = &clk_regmap_divider_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hdmi_pll_od.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_fixed_factor sc2_mpll_50m_div = {
+	.mult = 1,
+	.div = 80,
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll_50m_div",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fixed_pll_dco.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_mpll_50m = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = ANACTRL_FIXPLL_CTRL3,
+		.mask = 0x1,
+		.shift = 5,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll_50m",
+		.ops = &clk_regmap_mux_ro_ops,
+		.parent_data = (const struct clk_parent_data []) {
+			{ .fw_name = "xtal", },
+			{ .hw = &sc2_mpll_50m_div.hw },
+		},
+		.num_parents = 2,
+	},
+};
+
+static struct clk_fixed_factor sc2_mpll_prediv = {
+	.mult = 1,
+	.div = 2,
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll_prediv",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_fixed_pll_dco.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static const struct reg_sequence sc2_mpll0_init_regs[] = {
+	{ .reg = ANACTRL_MPLL_CTRL2, .def = 0x40000033 }
+};
+
+static struct clk_regmap sc2_mpll0_div = {
+	.data = &(struct meson_clk_mpll_data){
+		.sdm = {
+			.reg_off = ANACTRL_MPLL_CTRL1,
+			.shift   = 0,
+			.width   = 14,
+		},
+		.sdm_en = {
+			.reg_off = ANACTRL_MPLL_CTRL1,
+			.shift   = 30,
+			.width	 = 1,
+		},
+		.n2 = {
+			.reg_off = ANACTRL_MPLL_CTRL1,
+			.shift   = 20,
+			.width   = 9,
+		},
+		.ssen = {
+			.reg_off = ANACTRL_MPLL_CTRL1,
+			.shift   = 29,
+			.width	 = 1,
+		},
+		.lock = &meson_clk_lock,
+		.init_regs = sc2_mpll0_init_regs,
+		.init_count = ARRAY_SIZE(sc2_mpll0_init_regs),
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll0_div",
+		.ops = &meson_clk_mpll_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_mpll_prediv.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_mpll0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_MPLL_CTRL1,
+		.bit_idx = 31,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_mpll0_div.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static const struct reg_sequence sc2_mpll1_init_regs[] = {
+	{ .reg = ANACTRL_MPLL_CTRL4,	.def = 0x40000033 }
+};
+
+static struct clk_regmap sc2_mpll1_div = {
+	.data = &(struct meson_clk_mpll_data){
+		.sdm = {
+			.reg_off = ANACTRL_MPLL_CTRL3,
+			.shift   = 0,
+			.width   = 14,
+		},
+		.sdm_en = {
+			.reg_off = ANACTRL_MPLL_CTRL3,
+			.shift   = 30,
+			.width	 = 1,
+		},
+		.n2 = {
+			.reg_off = ANACTRL_MPLL_CTRL3,
+			.shift   = 20,
+			.width   = 9,
+		},
+		.ssen = {
+			.reg_off = ANACTRL_MPLL_CTRL3,
+			.shift   = 29,
+			.width	 = 1,
+		},
+		.lock = &meson_clk_lock,
+		.init_regs = sc2_mpll1_init_regs,
+		.init_count = ARRAY_SIZE(sc2_mpll1_init_regs),
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll1_div",
+		.ops = &meson_clk_mpll_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_mpll_prediv.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_mpll1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_MPLL_CTRL3,
+		.bit_idx = 31,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_mpll1_div.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static const struct reg_sequence sc2_mpll2_init_regs[] = {
+	{ .reg = ANACTRL_MPLL_CTRL6, .def = 0x40000033 }
+};
+
+static struct clk_regmap sc2_mpll2_div = {
+	.data = &(struct meson_clk_mpll_data){
+		.sdm = {
+			.reg_off = ANACTRL_MPLL_CTRL5,
+			.shift   = 0,
+			.width   = 14,
+		},
+		.sdm_en = {
+			.reg_off = ANACTRL_MPLL_CTRL5,
+			.shift   = 30,
+			.width	 = 1,
+		},
+		.n2 = {
+			.reg_off = ANACTRL_MPLL_CTRL5,
+			.shift   = 20,
+			.width   = 9,
+		},
+		.ssen = {
+			.reg_off = ANACTRL_MPLL_CTRL5,
+			.shift   = 29,
+			.width	 = 1,
+		},
+		.lock = &meson_clk_lock,
+		.init_regs = sc2_mpll2_init_regs,
+		.init_count = ARRAY_SIZE(sc2_mpll2_init_regs),
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll2_div",
+		.ops = &meson_clk_mpll_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_mpll_prediv.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_mpll2 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_MPLL_CTRL5,
+		.bit_idx = 31,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll2",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_mpll2_div.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static const struct reg_sequence sc2_mpll3_init_regs[] = {
+	{ .reg = ANACTRL_MPLL_CTRL8, .def = 0x40000033 }
+};
+
+static struct clk_regmap sc2_mpll3_div = {
+	.data = &(struct meson_clk_mpll_data){
+		.sdm = {
+			.reg_off = ANACTRL_MPLL_CTRL7,
+			.shift   = 0,
+			.width   = 14,
+		},
+		.sdm_en = {
+			.reg_off = ANACTRL_MPLL_CTRL7,
+			.shift   = 30,
+			.width	 = 1,
+		},
+		.n2 = {
+			.reg_off = ANACTRL_MPLL_CTRL7,
+			.shift   = 20,
+			.width   = 9,
+		},
+		.ssen = {
+			.reg_off = ANACTRL_MPLL_CTRL7,
+			.shift   = 29,
+			.width	 = 1,
+		},
+		.lock = &meson_clk_lock,
+		.init_regs = sc2_mpll3_init_regs,
+		.init_count = ARRAY_SIZE(sc2_mpll3_init_regs),
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll3_div",
+		.ops = &meson_clk_mpll_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_mpll_prediv.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_mpll3 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = ANACTRL_MPLL_CTRL7,
+		.bit_idx = 31,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mpll3",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_mpll3_div.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/*
+ *rtc 32k clock
+ *
+ *xtal--GATE------------------GATE---------------------|\
+ *	              |  --------                      | \
+ *	              |  |      |                      |  \
+ *	              ---| DUAL |----------------------|   |
+ *	                 |      |                      |   |____GATE__
+ *	                 --------                      |   |     rtc_32k_out
+ *	   PAD-----------------------------------------|  /
+ *	                                               | /
+ *	   DUAL function:                              |/
+ *	   bit 28 in RTC_BY_OSCIN_CTRL0 control the dual function.
+ *	   when bit 28 = 0
+ *	         f = 24M/N0
+ *	   when bit 28 = 1
+ *	         output N1 and N2 in rurn.
+ *	   T = (x*T1 + y*T2)/x+y
+ *	   f = (24M/(N0*M0 + N1*M1)) * (M0 + M1)
+ *	   f: the frequecy value (HZ)
+ *	       |      | |      |
+ *	       | Div1 |-| Cnt1 |
+ *	      /|______| |______|\
+ *	    -|  ______   ______  ---> Out
+ *	      \|      | |      |/
+ *	       | Div2 |-| Cnt2 |
+ *	       |______| |______|
+ **/
+
+/*
+ * rtc 32k clock in gate
+ */
+static struct clk_regmap sc2_rtc_32k_clkin = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_RTC_BY_OSCIN_CTRL0,
+		.bit_idx = 31,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "rtc_32k_clkin",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+	},
+};
+
+static const struct meson_clk_dualdiv_param sc2_32k_div_table[] = {
+	{
+		.dual	= 1,
+		.n1	= 733,
+		.m1	= 8,
+		.n2	= 732,
+		.m2	= 11,
+	},
+	{}
+};
+
+static struct clk_regmap sc2_rtc_32k_div = {
+	.data = &(struct meson_clk_dualdiv_data){
+		.n1 = {
+			.reg_off = CLKCTRL_RTC_BY_OSCIN_CTRL0,
+			.shift   = 0,
+			.width   = 12,
+		},
+		.n2 = {
+			.reg_off = CLKCTRL_RTC_BY_OSCIN_CTRL0,
+			.shift   = 12,
+			.width   = 12,
+		},
+		.m1 = {
+			.reg_off = CLKCTRL_RTC_BY_OSCIN_CTRL1,
+			.shift   = 0,
+			.width   = 12,
+		},
+		.m2 = {
+			.reg_off = CLKCTRL_RTC_BY_OSCIN_CTRL1,
+			.shift   = 12,
+			.width   = 12,
+		},
+		.dual = {
+			.reg_off = CLKCTRL_RTC_BY_OSCIN_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.table = sc2_32k_div_table,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "rtc_32k_div",
+		.ops = &meson_clk_dualdiv_ops,
+		.parent_names = (const char *[]){ "rtc_32k_clkin" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_rtc_32k_xtal = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_RTC_BY_OSCIN_CTRL1,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "rtc_32k_xtal",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "rtc_32k_clkin" },
+		.num_parents = 1,
+	},
+};
+
+/*
+ * three parent for rtc clock out
+ * pad is from where?
+ */
+static u32 rtc_32k_sel[] = {0, 1};
+static const char * const rtc_32k_sel_parent_names[] = {
+	"rtc_32k_xtal", "rtc_32k_div", "pad"
+};
+
+static struct clk_regmap sc2_rtc_32k_sel = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_RTC_CTRL,
+		.mask = 0x3,
+		.shift = 0,
+		.table = rtc_32k_sel,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "rtc_32k_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_names = rtc_32k_sel_parent_names,
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_rtc_clk = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_RTC_BY_OSCIN_CTRL0,
+		.bit_idx = 30,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "rtc_clk",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "rtc_32k_sel" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* sys clk */
+static u32 mux_table_sys_ab_clk_sel[] = { 0, 1, 2, 3, 4, 6, 7 };
+static const char * const sys_ab_clk_parent_names[] = {
+	"xtal", "fclk_div2", "fclk_div3", "fclk_div4",
+	"fclk_div5", "axi_clk_frcpu", "fclk_div7", "rtc_clk"
+};
+
+static struct clk_regmap sc2_sysclk_b_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_SYS_CLK_CTRL0,
+		.mask = 0x7,
+		.shift = 26,
+		.table = mux_table_sys_ab_clk_sel,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sysclk_b_sel",
+		.ops = &clk_regmap_mux_ro_ops,
+		.parent_names = sys_ab_clk_parent_names,
+		.num_parents = ARRAY_SIZE(sys_ab_clk_parent_names),
+	},
+};
+
+static struct clk_regmap sc2_sysclk_b_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_SYS_CLK_CTRL0,
+		.shift = 16,
+		.width = 10,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sysclk_b_div",
+		.ops = &clk_regmap_divider_ro_ops,
+		.parent_names = (const char *[]){ "sysclk_b_sel" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_sysclk_b = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_SYS_CLK_CTRL0,
+		.bit_idx = 29,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sysclk_b",
+		.ops = &clk_regmap_gate_ro_ops,
+		.parent_names = (const char *[]){ "sysclk_b_div" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED
+			 | CLK_IS_CRITICAL,
+	},
+};
+
+static struct clk_regmap sc2_sysclk_a_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_SYS_CLK_CTRL0,
+		.mask = 0x7,
+		.shift = 10,
+		.table = mux_table_sys_ab_clk_sel,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sysclk_a_sel",
+		.ops = &clk_regmap_mux_ro_ops,
+		.parent_names = sys_ab_clk_parent_names,
+		.num_parents = ARRAY_SIZE(sys_ab_clk_parent_names),
+	},
+};
+
+static struct clk_regmap sc2_sysclk_a_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_SYS_CLK_CTRL0,
+		.shift = 0,
+		.width = 10,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sysclk_a_div",
+		.ops = &clk_regmap_divider_ro_ops,
+		.parent_names = (const char *[]){ "sysclk_a_sel" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_sysclk_a = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_SYS_CLK_CTRL0,
+		.bit_idx = 13,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sysclk_a",
+		.ops = &clk_regmap_gate_ro_ops,
+		.parent_names = (const char *[]){ "sysclk_a_div" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED
+			 | CLK_IS_CRITICAL,
+	},
+};
+
+static const char * const sys_clk_parent_names[] = {
+	"sysclk_a", "sysclk_b"};
+
+static struct clk_regmap sc2_sys_clk = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_SYS_CLK_CTRL0,
+		.mask = 0x1,
+		.shift = 31,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sys_clk",
+		.ops = &clk_regmap_mux_ro_ops,
+		.parent_names = sys_clk_parent_names,
+		.num_parents = ARRAY_SIZE(sys_clk_parent_names),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+/*axi clk*/
+
+/*ceca_clk*/
+static struct clk_regmap sc2_ceca_32k_clkin = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_CECA_CTRL0,
+		.bit_idx = 31,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "ceca_32k_clkin",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_ceca_32k_div = {
+	.data = &(struct meson_clk_dualdiv_data){
+		.n1 = {
+			.reg_off = CLKCTRL_CECA_CTRL0,
+			.shift   = 0,
+			.width   = 12,
+		},
+		.n2 = {
+			.reg_off = CLKCTRL_CECA_CTRL0,
+			.shift   = 12,
+			.width   = 12,
+		},
+		.m1 = {
+			.reg_off = CLKCTRL_CECA_CTRL1,
+			.shift   = 0,
+			.width   = 12,
+		},
+		.m2 = {
+			.reg_off = CLKCTRL_CECA_CTRL1,
+			.shift   = 12,
+			.width   = 12,
+		},
+		.dual = {
+			.reg_off = CLKCTRL_CECA_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.table = sc2_32k_div_table,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "ceca_32k_div",
+		.ops = &meson_clk_dualdiv_ops,
+		.parent_names = (const char *[]){ "ceca_32k_clkin" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_ceca_32k_sel_pre = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_CECA_CTRL1,
+		.mask = 0x1,
+		.shift = 24,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "ceca_32k_sel_pre",
+		.ops = &clk_regmap_mux_ops,
+		.parent_names = (const char *[]){ "ceca_32k_div",
+						"ceca_32k_clkin" },
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_ceca_32k_sel = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_CECA_CTRL1,
+		.mask = 0x1,
+		.shift = 31,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "ceca_32k_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_names = (const char *[]){ "ceca_32k_sel_pre",
+						"rtc_clk" },
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_ceca_32k_clkout = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_CECA_CTRL0,
+		.bit_idx = 30,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "ceca_32k_clkout",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "ceca_32k_sel" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cecb_clk*/
+static struct clk_regmap sc2_cecb_32k_clkin = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_CECB_CTRL0,
+		.bit_idx = 31,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "cecb_32k_clkin",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_cecb_32k_div = {
+	.data = &(struct meson_clk_dualdiv_data){
+		.n1 = {
+			.reg_off = CLKCTRL_CECB_CTRL0,
+			.shift   = 0,
+			.width   = 12,
+		},
+		.n2 = {
+			.reg_off = CLKCTRL_CECB_CTRL0,
+			.shift   = 12,
+			.width   = 12,
+		},
+		.m1 = {
+			.reg_off = CLKCTRL_CECB_CTRL1,
+			.shift   = 0,
+			.width   = 12,
+		},
+		.m2 = {
+			.reg_off = CLKCTRL_CECB_CTRL1,
+			.shift   = 12,
+			.width   = 12,
+		},
+		.dual = {
+			.reg_off = CLKCTRL_CECB_CTRL0,
+			.shift   = 28,
+			.width   = 1,
+		},
+		.table = sc2_32k_div_table,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cecb_32k_div",
+		.ops = &meson_clk_dualdiv_ops,
+		.parent_names = (const char *[]){ "cecb_32k_clkin" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_cecb_32k_sel_pre = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_CECB_CTRL1,
+		.mask = 0x1,
+		.shift = 24,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cecb_32k_sel_pre",
+		.ops = &clk_regmap_mux_ops,
+		.parent_names = (const char *[]){ "cecb_32k_div",
+						"cecb_32k_clkin" },
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_cecb_32k_sel = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_CECB_CTRL1,
+		.mask = 0x1,
+		.shift = 31,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cecb_32k_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_names = (const char *[]){ "cecb_32k_sel_pre",
+						"rtc_clk" },
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_cecb_32k_clkout = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_CECB_CTRL0,
+		.bit_idx = 30,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cecb_32k_clkout",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "cecb_32k_sel" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cts_sc_clk*/
+static const struct clk_parent_data sc2_sc_parent_data[] = {
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div3.hw },
+	{ .hw = &sc2_fclk_div5.hw },
+	{ .fw_name = "xtal", }
+};
+
+static struct clk_regmap sc2_sc_clk_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_SC_CLK_CTRL,
+		.mask = 0x3,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sc_clk_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_sc_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_sc_parent_data),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_sc_clk_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_SC_CLK_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sc_clk_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_sc_clk_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_sc_clk_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_SC_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sc_clk_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_sc_clk_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/*rama_clk*/
+
+/*dspa_clk*/
+static const struct clk_parent_data sc2_dsp_parent_hws[] = {
+	{ .fw_name = "xtal", },
+	{ .hw = &sc2_fclk_div2p5.hw },
+	{ .hw = &sc2_fclk_div3.hw },
+	{ .hw = &sc2_fclk_div5.hw },
+	{ .hw = &sc2_hifi_pll.hw },
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div7.hw },
+	{ .hw = &sc2_rtc_clk.hw }
+};
+
+static struct clk_regmap sc2_dspa_a_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_DSPA_CLK_CTRL0,
+		.mask = 0x7,
+		.shift = 10,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "dspa_a_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_dsp_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_dsp_parent_hws),
+	},
+};
+
+static struct clk_regmap sc2_dspa_a_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_DSPA_CLK_CTRL0,
+		.shift = 0,
+		.width = 10,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "dspa_a_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dspa_a_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_dspa_a_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_DSPA_CLK_CTRL0,
+		.bit_idx = 13,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dspa_a_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dspa_a_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_dspa_b_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_DSPA_CLK_CTRL0,
+		.mask = 0x7,
+		.shift = 26,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "dspa_b_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_dsp_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_dsp_parent_hws),
+	},
+};
+
+static struct clk_regmap sc2_dspa_b_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_DSPA_CLK_CTRL0,
+		.shift = 16,
+		.width = 10,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "dspa_b_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dspa_b_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_dspa_b_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_DSPA_CLK_CTRL0,
+		.bit_idx = 29,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "dspa_b_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dspa_b_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_dspa_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_DSPA_CLK_CTRL0,
+		.mask = 0x1,
+		.shift = 15,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "dspa_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_dspa_a_gate.hw,
+			&sc2_dspa_b_gate.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/*12_24M clk*/
+static struct clk_regmap sc2_24M_clk_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_CLK12_24_CTRL,
+		.bit_idx = 11,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "24m",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_fixed_factor sc2_12M_clk_div = {
+	.mult = 1,
+	.div = 2,
+	.hw.init = &(struct clk_init_data){
+		.name = "24m_div2",
+		.ops = &clk_fixed_factor_ops,
+		.parent_names = (const char *[]){ "24m" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_12M_clk_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_CLK12_24_CTRL,
+		.bit_idx = 10,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "12m",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "24m_div2" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_25M_clk_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_CLK12_24_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "25M_clk_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_names = (const char *[]){ "fclk_div2" },
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_25M_clk_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_CLK12_24_CTRL,
+		.bit_idx = 12,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "25m",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "25M_clk_div" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* Video Clocks */
+static struct clk_regmap sc2_vid_pll_div = {
+	.data = &(struct meson_vid_pll_div_data){
+		.val = {
+			.reg_off = CLKCTRL_VID_PLL_CLK_DIV,
+			.shift   = 0,
+			.width   = 15,
+		},
+		.sel = {
+			.reg_off = CLKCTRL_VID_PLL_CLK_DIV,
+			.shift   = 16,
+			.width   = 2,
+		},
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vid_pll_div",
+		.ops = &meson_vid_pll_div_ro_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_hdmi_pll.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static const struct clk_hw *sc2_vid_pll_parent_hws[] = {
+	&sc2_vid_pll_div.hw,
+	&sc2_hdmi_pll.hw
+};
+
+static struct clk_regmap sc2_vid_pll_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VID_PLL_CLK_DIV,
+		.mask = 0x1,
+		.shift = 18,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vid_pll_sel",
+		.ops = &clk_regmap_mux_ops,
+		/*
+		 * bit 18 selects from 2 possible parents:
+		 * vid_pll_div or hdmi_pll
+		 */
+		.parent_hws = sc2_vid_pll_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vid_pll_parent_hws),
+		.flags = CLK_SET_RATE_NO_REPARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vid_pll = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_PLL_CLK_DIV,
+		.bit_idx = 19,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vid_pll",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vid_pll_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static const struct clk_hw *sc2_vclk_parent_hws[] = {
+	&sc2_vid_pll.hw,
+	&sc2_gp0_pll.hw,
+	&sc2_hifi_pll.hw,
+	&sc2_mpll1.hw,
+	&sc2_fclk_div3.hw,
+	&sc2_fclk_div4.hw,
+	&sc2_fclk_div5.hw,
+	&sc2_fclk_div7.hw
+};
+
+static struct clk_regmap sc2_vclk_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VID_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 16,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_vclk_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vclk_parent_hws),
+		.flags = CLK_SET_RATE_NO_REPARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vclk2_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VIID_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 16,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk2_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_vclk_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vclk_parent_hws),
+		.flags = CLK_SET_RATE_NO_REPARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vclk_input = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_DIV,
+		.bit_idx = 16,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk_input",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk_sel.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk2_input = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VIID_CLK_DIV,
+		.bit_idx = 16,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk2_input",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk2_sel.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VID_CLK_DIV,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk_input.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vclk2_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VIID_CLK_DIV,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk2_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk2_input.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vclk = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL,
+		.bit_idx = 19,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk_div.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk2 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VIID_CLK_CTRL,
+		.bit_idx = 19,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk2",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk2_div.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk_div1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL,
+		.bit_idx = 0,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk_div1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk_div2_en = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL,
+		.bit_idx = 1,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk_div2_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk_div4_en = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL,
+		.bit_idx = 2,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk_div4_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk_div6_en = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL,
+		.bit_idx = 3,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk_div6_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk_div12_en = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL,
+		.bit_idx = 4,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk_div12_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk2_div1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VIID_CLK_CTRL,
+		.bit_idx = 0,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk2_div1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk2.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk2_div2_en = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VIID_CLK_CTRL,
+		.bit_idx = 1,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk2_div2_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk2.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk2_div4_en = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VIID_CLK_CTRL,
+		.bit_idx = 2,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk2_div4_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk2.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk2_div6_en = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VIID_CLK_CTRL,
+		.bit_idx = 3,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk2_div6_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk2.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vclk2_div12_en = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VIID_CLK_CTRL,
+		.bit_idx = 4,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vclk2_div12_en",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vclk2.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_fixed_factor sc2_vclk_div2 = {
+	.mult = 1,
+	.div = 2,
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk_div2",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk_div2_en.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_fixed_factor sc2_vclk_div4 = {
+	.mult = 1,
+	.div = 4,
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk_div4",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk_div4_en.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_fixed_factor sc2_vclk_div6 = {
+	.mult = 1,
+	.div = 6,
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk_div6",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk_div6_en.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_fixed_factor sc2_vclk_div12 = {
+	.mult = 1,
+	.div = 12,
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk_div12",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk_div12_en.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_fixed_factor sc2_vclk2_div2 = {
+	.mult = 1,
+	.div = 2,
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk2_div2",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk2_div2_en.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_fixed_factor sc2_vclk2_div4 = {
+	.mult = 1,
+	.div = 4,
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk2_div4",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk2_div4_en.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_fixed_factor sc2_vclk2_div6 = {
+	.mult = 1,
+	.div = 6,
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk2_div6",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk2_div6_en.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_fixed_factor sc2_vclk2_div12 = {
+	.mult = 1,
+	.div = 12,
+	.hw.init = &(struct clk_init_data){
+		.name = "vclk2_div12",
+		.ops = &clk_fixed_factor_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vclk2_div12_en.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+static u32 mux_table_cts_sel[] = { 0, 1, 2, 3, 4, 8, 9, 10, 11, 12 };
+static const struct clk_hw *sc2_cts_parent_hws[] = {
+	&sc2_vclk_div1.hw,
+	&sc2_vclk_div2.hw,
+	&sc2_vclk_div4.hw,
+	&sc2_vclk_div6.hw,
+	&sc2_vclk_div12.hw,
+	&sc2_vclk2_div1.hw,
+	&sc2_vclk2_div2.hw,
+	&sc2_vclk2_div4.hw,
+	&sc2_vclk2_div6.hw,
+	&sc2_vclk2_div12.hw
+};
+
+static struct clk_regmap sc2_cts_enci_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VID_CLK_DIV,
+		.mask = 0xf,
+		.shift = 28,
+		.table = mux_table_cts_sel,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cts_enci_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_cts_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_cts_parent_hws),
+		.flags = CLK_SET_RATE_NO_REPARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_cts_encp_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VID_CLK_DIV,
+		.mask = 0xf,
+		.shift = 20,
+		.table = mux_table_cts_sel,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cts_encp_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_cts_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_cts_parent_hws),
+		.flags = CLK_SET_RATE_NO_REPARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_cts_vdac_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VIID_CLK_DIV,
+		.mask = 0xf,
+		.shift = 28,
+		.table = mux_table_cts_sel,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "cts_vdac_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_cts_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_cts_parent_hws),
+		.flags = CLK_SET_RATE_NO_REPARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+/* TOFIX: add support for cts_tcon */
+static u32 mux_table_hdmi_tx_sel[] = { 0, 1, 2, 3, 4, 8, 9, 10, 11, 12 };
+static const struct clk_hw *sc2_cts_hdmi_tx_parent_hws[] = {
+	&sc2_vclk_div1.hw,
+	&sc2_vclk_div2.hw,
+	&sc2_vclk_div4.hw,
+	&sc2_vclk_div6.hw,
+	&sc2_vclk_div12.hw,
+	&sc2_vclk2_div1.hw,
+	&sc2_vclk2_div2.hw,
+	&sc2_vclk2_div4.hw,
+	&sc2_vclk2_div6.hw,
+	&sc2_vclk2_div12.hw
+};
+
+static struct clk_regmap sc2_hdmi_tx_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_HDMI_CLK_CTRL,
+		.mask = 0xf,
+		.shift = 16,
+		.table = mux_table_hdmi_tx_sel,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hdmi_tx_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_cts_hdmi_tx_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_cts_hdmi_tx_parent_hws),
+		.flags = CLK_SET_RATE_NO_REPARENT | CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_cts_enci = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL2,
+		.bit_idx = 0,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "cts_enci",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cts_enci_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_cts_encp = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL2,
+		.bit_idx = 2,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "cts_encp",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cts_encp_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_cts_vdac = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL2,
+		.bit_idx = 4,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "cts_vdac",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_cts_vdac_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_hdmi_tx = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VID_CLK_CTRL2,
+		.bit_idx = 5,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hdmi_tx",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hdmi_tx_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+/*hdmi_clk*/
+static const struct clk_parent_data sc2_hdmi_parent_data[] = {
+	{ .fw_name = "xtal", },
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div3.hw },
+	{ .hw = &sc2_fclk_div5.hw }
+};
+
+static struct clk_regmap sc2_hdmi_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_HDMI_CLK_CTRL,
+		.mask = 0x3,
+		.shift = 9,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hdmi_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_hdmi_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_hdmi_parent_data),
+		.flags = CLK_SET_RATE_NO_REPARENT | CLK_GET_RATE_NOCACHE |
+			 CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_hdmi_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_HDMI_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hdmi_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_hdmi_sel.hw },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT |
+			 CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_hdmi = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_HDMI_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hdmi",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_hdmi_div.hw },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT |
+			 CLK_IGNORE_UNUSED,
+	},
+};
+
+/*vid_lock_clk*/
+
+/*eth_clk :125M*/
+
+/*ts_clk*/
+static struct clk_regmap sc2_ts_clk_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_TS_CLK_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "ts_clk_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_data = &(const struct clk_parent_data) {
+			.fw_name = "xtal",
+		},
+		.num_parents = 1,
+	},
+};
+
+static struct clk_regmap sc2_ts_clk_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_TS_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "ts_clk_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_ts_clk_div.hw
+		},
+		.num_parents = 1,
+	},
+};
+
+/*mali_clk*/
+/*
+ * The MALI IP is clocked by two identical clocks (mali_0 and mali_1)
+ * muxed by a glitch-free switch on Meson8b and Meson8m2 and later.
+ *
+ * CLK_SET_RATE_PARENT is added for mali_0_sel clock
+ * 1.gp0 pll only support the 846M, avoid other rate 500/400M from it
+ * 2.hifi pll is used for other module, skip it, avoid some rate from it
+ */
+static u32 mux_table_mali[] = { 0, 1, 3, 4, 5, 6, 7 };
+
+static const struct clk_parent_data sc2_mali_0_1_parent_data[] = {
+	{ .fw_name = "xtal", },
+	{ .hw = &sc2_gp0_pll.hw },
+	{ .hw = &sc2_fclk_div2p5.hw },
+	{ .hw = &sc2_fclk_div3.hw },
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div5.hw },
+	{ .hw = &sc2_fclk_div7.hw }
+};
+
+static struct clk_regmap sc2_mali_0_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_MALI_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+		.table = mux_table_mali,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mali_0_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_mali_0_1_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_mali_0_1_parent_data),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_mali_0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_MALI_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mali_0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_mali_0_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_mali_0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_MALI_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mali_0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_mali_0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_GATE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_mali_1_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_MALI_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+		.table = mux_table_mali,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mali_1_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_mali_0_1_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_mali_0_1_parent_data),
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_mali_1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_MALI_CLK_CTRL,
+		.shift = 16,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mali_1_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_mali_1_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_mali_1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_MALI_CLK_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mali_1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_mali_1_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_GATE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static const struct clk_hw *sc2_mali_parent_hws[] = {
+	&sc2_mali_0.hw,
+	&sc2_mali_1.hw
+};
+
+static struct clk_regmap sc2_mali_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_MALI_CLK_CTRL,
+		.mask = 1,
+		.shift = 31,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mali",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_mali_parent_hws,
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* cts_vdec_clk */
+static const struct clk_parent_data sc2_dec_parent_hws[] = {
+	{ .hw = &sc2_fclk_div2p5.hw },
+	{ .hw = &sc2_fclk_div3.hw },
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div5.hw },
+	{ .hw = &sc2_fclk_div7.hw },
+	{ .hw = &sc2_hifi_pll.hw },
+	{ .hw = &sc2_gp0_pll.hw },
+	{ .fw_name = "xtal", }
+};
+
+static struct clk_regmap sc2_vdec_p0_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdec_p0_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_dec_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_dec_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vdec_p0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VDEC_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdec_p0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vdec_p0_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vdec_p0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VDEC_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vdec_p0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vdec_p0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vdec_p1_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC3_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdec_p1_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_dec_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_dec_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vdec_p1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VDEC3_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdec_p1_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vdec_p1_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vdec_p1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VDEC3_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vdec_p1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vdec_p1_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static const struct clk_parent_data sc2_vdec_mux_parent_hws[] = {
+	{.hw = &sc2_vdec_p0.hw,},
+	{.hw = &sc2_vdec_p1.hw,}
+};
+
+static struct clk_regmap sc2_vdec_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC3_CLK_CTRL,
+		.mask = 0x1,
+		.shift = 15,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdec_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_vdec_mux_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vdec_mux_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/* cts_hcodec_clk */
+static struct clk_regmap sc2_hcodec_p0_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hcodec_p0_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_dec_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_dec_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_hcodec_p0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VDEC_CLK_CTRL,
+		.shift = 16,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hcodec_p0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hcodec_p0_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hcodec_p0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VDEC_CLK_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hcodec_p0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hcodec_p0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hcodec_p1_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC3_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hcodec_p1_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_dec_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_dec_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_hcodec_p1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VDEC3_CLK_CTRL,
+		.shift = 16,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hcodec_p1_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hcodec_p1_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hcodec_p1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VDEC3_CLK_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hcodec_p1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hcodec_p1_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static const struct clk_parent_data sc2_hcodec_mux_parent_hws[] = {
+	{ .hw = &sc2_hcodec_p0.hw },
+	{ .hw = &sc2_hcodec_p1.hw }
+};
+
+static struct clk_regmap sc2_hcodec_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC3_CLK_CTRL,
+		.mask = 0x1,
+		.shift = 31,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hcodec_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_hcodec_mux_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_hcodec_mux_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/* cts_hevcb_clk */
+static u32 mux_table_vdec[] = { 0, 1, 2, 3, 4};
+
+static const struct clk_hw *sc2_vdec_parent_hws[] = {
+	&sc2_fclk_div2p5.hw,
+	&sc2_fclk_div3.hw,
+	&sc2_fclk_div4.hw,
+	&sc2_fclk_div5.hw,
+	&sc2_fclk_div7.hw
+};
+
+static struct clk_regmap sc2_hevcb_p0_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC2_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+		.table = mux_table_vdec,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcb_p0_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_vdec_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vdec_parent_hws),
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hevcb_p0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VDEC2_CLK_CTRL,
+		.shift = 16,
+		.width = 7,
+		.flags = CLK_DIVIDER_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcb_p0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hevcb_p0_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hevcb_p0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VDEC2_CLK_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcb_p0_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hevcb_p0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hevcb_p1_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC4_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcb_p1_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_dec_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_dec_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_hevcb_p1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VDEC4_CLK_CTRL,
+		.shift = 16,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevc_p1_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hevcb_p1_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hevcb_p1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VDEC4_CLK_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcb_p1_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hevcb_p1_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static const struct clk_parent_data sc2_hevcb_mux_parent_hws[] = {
+	{ .hw = &sc2_hevcb_p0.hw },
+	{ .hw = &sc2_hevcb_p1.hw }
+};
+
+static struct clk_regmap sc2_hevcb_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC4_CLK_CTRL,
+		.mask = 0x1,
+		.shift = 31,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcb_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_hevcb_mux_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_hevcb_mux_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/* cts_hevcf_clk */
+static struct clk_regmap sc2_hevcf_p0_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC2_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcf_p0_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_dec_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_dec_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_hevcf_p0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VDEC2_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcf_p0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hevcf_p0_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hevcf_p0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VDEC2_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcf_p0_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hevcf_p0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hevcf_p1_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC4_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcf_p1_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_dec_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_dec_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_hevcf_p1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VDEC4_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcf_p1_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hevcf_p1_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_hevcf_p1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VDEC4_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcf_p1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_hevcf_p1_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static const struct clk_parent_data sc2_hevcf_mux_parent_hws[] = {
+	{ .hw = &sc2_hevcf_p0.hw },
+	{ .hw = &sc2_hevcf_p1.hw }
+};
+
+static struct clk_regmap sc2_hevcf_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDEC4_CLK_CTRL,
+		.mask = 0x1,
+		.shift = 15,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcf_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_hevcf_mux_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_hevcf_mux_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cts_wave420l_a/b/c_clk*/
+static const struct clk_parent_data sc2_wave_parent_data[] = {
+	{ .fw_name = "xtal", },
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div3.hw },
+	{ .hw = &sc2_fclk_div5.hw },
+	{ .hw = &sc2_fclk_div7.hw },
+	{ .hw = &sc2_mpll2.hw },
+	{ .hw = &sc2_mpll3.hw },
+	{ .hw = &sc2_gp0_pll.hw }
+};
+
+static struct clk_regmap sc2_wave_a_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_WAVE420L_CLK_CTRL2,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "wave_a_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_wave_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_wave_parent_data),
+	},
+};
+
+static struct clk_regmap sc2_wave_a_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_WAVE420L_CLK_CTRL2,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "wave_a_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_wave_a_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_wave_aclk = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_WAVE420L_CLK_CTRL2,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "wave_aclk",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_wave_a_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_wave_b_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_WAVE420L_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "wave_b_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_wave_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_wave_parent_data),
+	},
+};
+
+static struct clk_regmap sc2_wave_b_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_WAVE420L_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "wave_b_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_wave_b_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_wave_bclk = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_WAVE420L_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "wave_bclk",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_wave_b_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_wave_c_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_WAVE420L_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "wave_c_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_wave_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_wave_parent_data),
+	},
+};
+
+static struct clk_regmap sc2_wave_c_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_WAVE420L_CLK_CTRL,
+		.shift = 16,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "wave_c_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_wave_c_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_wave_cclk = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_WAVE420L_CLK_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "wave_cclk",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_wave_c_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* cts_vpu_clk */
+static const struct clk_hw *sc2_vpu_parent_hws[] = {
+	&sc2_fclk_div3.hw,
+	&sc2_fclk_div4.hw,
+	&sc2_fclk_div5.hw,
+	&sc2_fclk_div7.hw,
+	&sc2_mpll1.hw,
+	&sc2_vid_pll.hw,
+	&sc2_hifi_pll.hw,
+	&sc2_gp0_pll.hw
+};
+
+static struct clk_regmap sc2_vpu_0_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VPU_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vpu_0_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_vpu_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vpu_parent_hws),
+	},
+};
+
+static struct clk_regmap sc2_vpu_0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VPU_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vpu_0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vpu_0_sel.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vpu_0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VPU_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vpu_0_div.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vpu_1_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VPU_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vpu_1_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_vpu_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vpu_parent_hws),
+	},
+};
+
+static struct clk_regmap sc2_vpu_1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VPU_CLK_CTRL,
+		.shift = 16,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vpu_1_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vpu_1_sel.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vpu_1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VPU_CLK_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vpu_1_div.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vpu = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VPU_CLK_CTRL,
+		.mask = 1,
+		.shift = 31,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vpu",
+		.ops = &clk_regmap_mux_ops,
+		/*
+		 * bit 31 selects from 2 possible parents:
+		 * vpu_0 or vpu_1
+		 */
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vpu_0.hw,
+			&sc2_vpu_1.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_NO_REPARENT,
+	},
+};
+
+/*cts_vpu_clkb*/
+static const struct clk_parent_data vpu_clkb_tmp_parent_hws[] = {
+	{ .hw = &sc2_vpu.hw },
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div5.hw },
+	{ .hw = &sc2_fclk_div7.hw }
+};
+
+static struct clk_regmap sc2_vpu_clkb_tmp_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VPU_CLKB_CTRL,
+		.mask = 0x3,
+		.shift = 20,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_clkb_tmp_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = vpu_clkb_tmp_parent_hws,
+		.num_parents = ARRAY_SIZE(vpu_clkb_tmp_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vpu_clkb_tmp_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VPU_CLKB_CTRL,
+		.shift = 16,
+		.width = 4,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_clkb_tmp_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vpu_clkb_tmp_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vpu_clkb_tmp = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VPU_CLKB_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vpu_clkb_tmp",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vpu_clkb_tmp_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vpu_clkb_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VPU_CLKB_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_clkb_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vpu_clkb_tmp.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vpu_clkb = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VPU_CLKB_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vpu_clkb",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vpu_clkb_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/* cts_vpu_clkc */
+static const char * const vpu_clkc_parent_names[] = { "fclk_div4",
+	"fclk_div3", "fclk_div5", "fclk_div7", "mpll1", "vid_pll",
+	"mpll2",  "gp0_pll"};
+
+static struct clk_regmap sc2_vpu_clkc_p0_mux  = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VPU_CLKC_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_clkc_p0_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_names = vpu_clkc_parent_names,
+		.num_parents = ARRAY_SIZE(vpu_clkc_parent_names),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vpu_clkc_p0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VPU_CLKC_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_clkc_p0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vpu_clkc_p0_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vpu_clkc_p0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VPU_CLKC_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vpu_clkc_p0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vpu_clkc_p0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vpu_clkc_p1_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VPU_CLKC_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_clkc_p1_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_names = vpu_clkc_parent_names,
+		.num_parents = ARRAY_SIZE(vpu_clkc_parent_names),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vpu_clkc_p1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VPU_CLKC_CTRL,
+		.shift = 16,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_clkc_p1_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vpu_clkc_p1_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vpu_clkc_p1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VPU_CLKC_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vpu_clkc_p1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vpu_clkc_p1_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static const struct clk_parent_data sc2_vpu_mux_parent_hws[] = {
+	{ .hw = &sc2_vpu_clkc_p0.hw },
+	{ .hw = &sc2_vpu_clkc_p1.hw }
+};
+
+static struct clk_regmap sc2_vpu_clkc_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VPU_CLKC_CTRL,
+		.mask = 0x1,
+		.shift = 31,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vpu_clkc_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_vpu_mux_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vpu_mux_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cts_vapb_clk*/
+static const struct clk_hw *sc2_vapb_parent_hws[] = {
+	&sc2_fclk_div4.hw,
+	&sc2_fclk_div3.hw,
+	&sc2_fclk_div5.hw,
+	&sc2_fclk_div7.hw,
+	&sc2_mpll1.hw,
+	&sc2_vid_pll.hw,
+	&sc2_mpll2.hw,
+	&sc2_fclk_div2p5.hw
+};
+
+static struct clk_regmap sc2_vapb_0_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VAPBCLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vapb_0_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_vapb_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vapb_parent_hws),
+	},
+};
+
+static struct clk_regmap sc2_vapb_0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VAPBCLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vapb_0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vapb_0_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vapb_0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VAPBCLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vapb_0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vapb_0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vapb_1_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VAPBCLK_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vapb_1_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = sc2_vapb_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vapb_parent_hws),
+		.flags = CLK_SET_RATE_NO_REPARENT,
+	},
+};
+
+static struct clk_regmap sc2_vapb_1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VAPBCLK_CTRL,
+		.shift = 16,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vapb_1_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vapb_1_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vapb_1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VAPBCLK_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vapb_1",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vapb_1_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_vapb = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VAPBCLK_CTRL,
+		.mask = 1,
+		.shift = 31,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vapb_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vapb_0.hw,
+			&sc2_vapb_1.hw,
+		},
+		.num_parents = 2,
+		.flags = CLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cts_ge2d_clk*/
+static struct clk_regmap sc2_ge2d_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VAPBCLK_CTRL,
+		.bit_idx = 30,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "ge2d_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) { &sc2_vapb.hw },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cts_hdcp22_esmclk*/
+
+/*cts_hdcp22_skpclk*/
+
+/* cts_vdin_meas_clk */
+static const struct clk_parent_data sc2_vdin_parent_hws[] = {
+	{ .fw_name = "xtal", },
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div3.hw },
+	{ .hw = &sc2_fclk_div5.hw },
+	{ .hw = &sc2_vid_pll.hw }
+};
+
+static struct clk_regmap sc2_vdin_meas_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_VDIN_MEAS_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdin_meas_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_vdin_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_vdin_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_vdin_meas_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_VDIN_MEAS_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdin_meas_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vdin_meas_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_vdin_meas_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_VDIN_MEAS_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "vdin_meas_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_vdin_meas_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cts_nand_clk*/
+static const struct clk_parent_data sc2_sd_emmc_clk0_parent_data[] = {
+	{ .fw_name = "xtal", },
+	{ .hw = &sc2_fclk_div2.hw },
+	{ .hw = &sc2_fclk_div3.hw },
+	{ .hw = &sc2_hifi_pll.hw },
+	{ .hw = &sc2_fclk_div2p5.hw },
+	{ .hw = &sc2_mpll2.hw },
+	{ .hw = &sc2_mpll3.hw },
+	{ .hw = &sc2_gp0_pll.hw }
+};
+
+static struct clk_regmap sc2_sd_emmc_c_clk0_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_NAND_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sd_emmc_c_clk0_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_sd_emmc_clk0_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_sd_emmc_clk0_parent_data),
+		.flags = CLK_SET_RATE_PARENT
+	},
+};
+
+static struct clk_regmap sc2_sd_emmc_c_clk0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_NAND_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sd_emmc_c_clk0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_sd_emmc_c_clk0_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT
+	},
+};
+
+static struct clk_regmap sc2_sd_emmc_c_clk0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_NAND_CLK_CTRL,
+		.bit_idx = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sd_emmc_c_clk0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_sd_emmc_c_clk0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT
+	},
+};
+
+/*cts_sd_emmc_a/b_clk*/
+static struct clk_regmap sc2_sd_emmc_a_clk0_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_SD_EMMC_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sd_emmc_a_clk0_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_sd_emmc_clk0_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_sd_emmc_clk0_parent_data),
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_sd_emmc_a_clk0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_SD_EMMC_CLK_CTRL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sd_emmc_a_clk0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_sd_emmc_a_clk0_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_sd_emmc_a_clk0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_SD_EMMC_CLK_CTRL,
+		.bit_idx = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sd_emmc_a_clk0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_sd_emmc_a_clk0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_sd_emmc_b_clk0_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_SD_EMMC_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sd_emmc_b_clk0_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_sd_emmc_clk0_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_sd_emmc_clk0_parent_data),
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_sd_emmc_b_clk0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_SD_EMMC_CLK_CTRL,
+		.shift = 16,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "sd_emmc_b_clk0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_sd_emmc_b_clk0_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_sd_emmc_b_clk0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_SD_EMMC_CLK_CTRL,
+		.bit_idx = 23,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "sd_emmc_b_clk0",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_sd_emmc_b_clk0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cts_cdac_clk*/
+
+/*cts_spicc_0/1_clk*/
+static const struct clk_parent_data sc2_spicc_parent_hws[] = {
+	{ .fw_name = "xtal", },
+	{ .hw = &sc2_sys_clk.hw },
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div3.hw },
+	{ .hw = &sc2_fclk_div2.hw },
+	{ .hw = &sc2_fclk_div5.hw },
+	{ .hw = &sc2_fclk_div7.hw },
+	{ .hw = &sc2_gp0_pll.hw }
+};
+
+static struct clk_regmap sc2_spicc0_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_SPICC_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 7,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "spicc0_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_spicc_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_spicc_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_spicc0_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_SPICC_CLK_CTRL,
+		.shift = 0,
+		.width = 6,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "spicc0_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_spicc0_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_spicc0_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_SPICC_CLK_CTRL,
+		.bit_idx = 6,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "spicc0_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_spicc0_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_spicc1_mux = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_SPICC_CLK_CTRL,
+		.mask = 0x7,
+		.shift = 23,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "spicc1_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_spicc_parent_hws,
+		.num_parents = ARRAY_SIZE(sc2_spicc_parent_hws),
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_regmap sc2_spicc1_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_SPICC_CLK_CTRL,
+		.shift = 16,
+		.width = 6,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "spicc1_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_spicc1_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_spicc1_gate = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_SPICC_CLK_CTRL,
+		.bit_idx = 22,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "spicc1_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_spicc1_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_PARENT,
+	},
+};
+
+/*cts_bt656*/
+
+/*cts_pwm_*_clk*/
+static const struct clk_parent_data sc2_pwm_parent_data[] = {
+	{ .fw_name = "xtal", },
+	{ .hw = &sc2_vid_pll.hw },
+	{ .hw = &sc2_fclk_div4.hw },
+	{ .hw = &sc2_fclk_div3.hw }
+};
+
+static struct clk_regmap sc2_pwm_a_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_AB_CTRL,
+		.mask = 0x3,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_a_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_a_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_AB_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_a_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_a_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_a_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_AB_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_a_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_a_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_b_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_AB_CTRL,
+		.mask = 0x3,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_b_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_b_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_AB_CTRL,
+		.shift = 16,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_b_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_b_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_b_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_AB_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_b_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_b_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_c_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_CD_CTRL,
+		.mask = 0x3,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_c_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_c_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_CD_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_c_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_c_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_c_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_CD_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_c_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_c_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_d_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_CD_CTRL,
+		.mask = 0x3,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_d_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_d_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_CD_CTRL,
+		.shift = 16,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_d_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_d_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_d_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_CD_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_d_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_d_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_e_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_EF_CTRL,
+		.mask = 0x3,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_e_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_e_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_EF_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_e_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_e_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_e_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_EF_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_e_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_e_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_f_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_EF_CTRL,
+		.mask = 0x3,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_f_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_f_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_EF_CTRL,
+		.shift = 16,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_f_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_f_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_f_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_EF_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_f_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_f_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_g_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_GH_CTRL,
+		.mask = 0x3,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_g_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_g_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_GH_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_g_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_g_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_g_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_GH_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_g_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_g_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_h_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_GH_CTRL,
+		.mask = 0x3,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_h_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_h_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_GH_CTRL,
+		.shift = 16,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_h_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_h_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_h_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_GH_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_h_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_h_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_i_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_IJ_CTRL,
+		.mask = 0x3,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_i_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_i_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_IJ_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_i_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_i_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_i_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_IJ_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_i_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_i_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_j_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_PWM_CLK_IJ_CTRL,
+		.mask = 0x3,
+		.shift = 25,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_j_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = sc2_pwm_parent_data,
+		.num_parents = ARRAY_SIZE(sc2_pwm_parent_data),
+		.flags = CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_j_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_PWM_CLK_IJ_CTRL,
+		.shift = 16,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_j_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_h_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+static struct clk_regmap sc2_pwm_j_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_PWM_CLK_IJ_CTRL,
+		.bit_idx = 24,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "pwm_j_gate",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_pwm_j_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+/*cts_sar_adc_clk*/
+static struct clk_regmap sc2_saradc_mux = {
+	.data = &(struct clk_regmap_mux_data) {
+		.offset = CLKCTRL_SAR_CLK_CTRL,
+		.mask = 0x3,
+		.shift = 9,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "saradc_mux",
+		.ops = &clk_regmap_mux_ops,
+		.parent_data = (const struct clk_parent_data []) {
+			{ .fw_name = "xtal", },
+			{ .hw = &sc2_sys_clk.hw },
+		},
+		.num_parents = 2,
+	},
+};
+
+static struct clk_regmap sc2_saradc_div = {
+	.data = &(struct clk_regmap_div_data) {
+		.offset = CLKCTRL_SAR_CLK_CTRL,
+		.shift = 0,
+		.width = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "saradc_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_saradc_mux.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_saradc_gate = {
+	.data = &(struct clk_regmap_gate_data) {
+		.offset = CLKCTRL_SAR_CLK_CTRL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "saradc_clk",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&sc2_saradc_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+	},
+};
+
+/* gen clk */
+static u32 sc2_gen_clk_mux_table[] = { 0, 5, 6, 7, 19, 21, 22,
+				23, 24, 25, 26, 27, 28 };
+
+static const char * const sc2_gen_clk_parent_names[] = {
+	"xtal", "gp0_pll", "gp1_pll", "hifi_pll", "fclk_div2", "fclk_div3",
+	"fclk_div4", "fclk_div5", "fclk_div7", "mpll0", "mpll1",
+	"mpll2", "mpll3"
+};
+
+static struct clk_regmap sc2_gen_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = CLKCTRL_GEN_CLK_CTRL,
+		.mask = 0x1f,
+		.shift = 12,
+		.table = sc2_gen_clk_mux_table,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "gen_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_names = sc2_gen_clk_parent_names,
+		.num_parents = ARRAY_SIZE(sc2_gen_clk_parent_names),
+	},
+};
+
+static struct clk_regmap sc2_gen_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = CLKCTRL_GEN_CLK_CTRL,
+		.shift = 0,
+		.width = 11,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "gen_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_names = (const char *[]){ "gen_sel" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap sc2_gen = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = CLKCTRL_GEN_CLK_CTRL,
+		.bit_idx = 11,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "gen",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "gen_div" },
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+#define MESON_SC2_SYS_GATE(_name, _reg, _bit)				\
+struct clk_regmap _name = {						\
+	.data = &(struct clk_regmap_gate_data) {			\
+		.offset = (_reg),					\
+		.bit_idx = (_bit),					\
+	},								\
+	.hw.init = &(struct clk_init_data) {				\
+		.name = #_name,						\
+		.ops = &clk_regmap_gate_ops,				\
+		.parent_hws = (const struct clk_hw *[]) {		\
+			&sc2_sys_clk.hw					\
+		},							\
+		.num_parents = 1,					\
+		.flags = CLK_IGNORE_UNUSED,				\
+	},								\
+}
+
+/*CLKCTRL_SYS_CLK_EN0_REG0*/
+static MESON_SC2_SYS_GATE(sc2_ddr, CLKCTRL_SYS_CLK_EN0_REG0, 0);
+static MESON_SC2_SYS_GATE(sc2_dos, CLKCTRL_SYS_CLK_EN0_REG0, 1);
+static MESON_SC2_SYS_GATE(sc2_ethphy, CLKCTRL_SYS_CLK_EN0_REG0, 4);
+static MESON_SC2_SYS_GATE(sc2_mali, CLKCTRL_SYS_CLK_EN0_REG0, 6);
+static MESON_SC2_SYS_GATE(sc2_aocpu, CLKCTRL_SYS_CLK_EN0_REG0, 13);
+static MESON_SC2_SYS_GATE(sc2_aucpu, CLKCTRL_SYS_CLK_EN0_REG0, 14);
+static MESON_SC2_SYS_GATE(sc2_cec, CLKCTRL_SYS_CLK_EN0_REG0, 16);
+static MESON_SC2_SYS_GATE(sc2_sdemmca, CLKCTRL_SYS_CLK_EN0_REG0, 24);
+static MESON_SC2_SYS_GATE(sc2_sdemmcb, CLKCTRL_SYS_CLK_EN0_REG0, 25);
+static MESON_SC2_SYS_GATE(sc2_nand, CLKCTRL_SYS_CLK_EN0_REG0, 26);
+static MESON_SC2_SYS_GATE(sc2_smartcard, CLKCTRL_SYS_CLK_EN0_REG0, 27);
+static MESON_SC2_SYS_GATE(sc2_acodec, CLKCTRL_SYS_CLK_EN0_REG0, 28);
+static MESON_SC2_SYS_GATE(sc2_spifc, CLKCTRL_SYS_CLK_EN0_REG0, 29);
+static MESON_SC2_SYS_GATE(sc2_msr_clk, CLKCTRL_SYS_CLK_EN0_REG0, 30);
+static MESON_SC2_SYS_GATE(sc2_ir_ctrl, CLKCTRL_SYS_CLK_EN0_REG0, 31);
+
+/*CLKCTRL_SYS_CLK_EN0_REG1*/
+static MESON_SC2_SYS_GATE(sc2_audio, CLKCTRL_SYS_CLK_EN0_REG1, 0);
+static MESON_SC2_SYS_GATE(sc2_eth, CLKCTRL_SYS_CLK_EN0_REG1, 3);
+static MESON_SC2_SYS_GATE(sc2_uart_a, CLKCTRL_SYS_CLK_EN0_REG1, 5);
+static MESON_SC2_SYS_GATE(sc2_uart_b, CLKCTRL_SYS_CLK_EN0_REG1, 6);
+static MESON_SC2_SYS_GATE(sc2_uart_c, CLKCTRL_SYS_CLK_EN0_REG1, 7);
+static MESON_SC2_SYS_GATE(sc2_uart_d, CLKCTRL_SYS_CLK_EN0_REG1, 8);
+static MESON_SC2_SYS_GATE(sc2_uart_e, CLKCTRL_SYS_CLK_EN0_REG1, 9);
+static MESON_SC2_SYS_GATE(sc2_aififo, CLKCTRL_SYS_CLK_EN0_REG1, 11);
+static MESON_SC2_SYS_GATE(sc2_ts_ddr, CLKCTRL_SYS_CLK_EN0_REG1, 15);
+static MESON_SC2_SYS_GATE(sc2_ts_pll, CLKCTRL_SYS_CLK_EN0_REG1, 16);
+static MESON_SC2_SYS_GATE(sc2_g2d, CLKCTRL_SYS_CLK_EN0_REG1, 20);
+static MESON_SC2_SYS_GATE(sc2_spicc0, CLKCTRL_SYS_CLK_EN0_REG1, 21);
+static MESON_SC2_SYS_GATE(sc2_spicc1, CLKCTRL_SYS_CLK_EN0_REG1, 22);
+static MESON_SC2_SYS_GATE(sc2_pcie, CLKCTRL_SYS_CLK_EN0_REG1, 24);
+static MESON_SC2_SYS_GATE(sc2_usb, CLKCTRL_SYS_CLK_EN0_REG1, 26);
+static MESON_SC2_SYS_GATE(sc2_pcie_phy, CLKCTRL_SYS_CLK_EN0_REG1, 27);
+static MESON_SC2_SYS_GATE(sc2_i2c_m_a, CLKCTRL_SYS_CLK_EN0_REG1, 30);
+static MESON_SC2_SYS_GATE(sc2_i2c_m_b, CLKCTRL_SYS_CLK_EN0_REG1, 31);
+
+/*CLKCTRL_SYS_CLK_EN0_REG2*/
+static MESON_SC2_SYS_GATE(sc2_i2c_m_c, CLKCTRL_SYS_CLK_EN0_REG2, 0);
+static MESON_SC2_SYS_GATE(sc2_i2c_m_d, CLKCTRL_SYS_CLK_EN0_REG2, 1);
+static MESON_SC2_SYS_GATE(sc2_i2c_m_e, CLKCTRL_SYS_CLK_EN0_REG2, 2);
+static MESON_SC2_SYS_GATE(sc2_i2c_m_f, CLKCTRL_SYS_CLK_EN0_REG2, 3);
+static MESON_SC2_SYS_GATE(sc2_hdmitx_apb, CLKCTRL_SYS_CLK_EN0_REG2, 4);
+static MESON_SC2_SYS_GATE(sc2_i2c_s_a, CLKCTRL_SYS_CLK_EN0_REG2, 5);
+static MESON_SC2_SYS_GATE(sc2_usb1_to_ddr, CLKCTRL_SYS_CLK_EN0_REG2, 8);
+static MESON_SC2_SYS_GATE(sc2_hdcp22, CLKCTRL_SYS_CLK_EN0_REG2, 10);
+static MESON_SC2_SYS_GATE(sc2_mmc_apb, CLKCTRL_SYS_CLK_EN0_REG2, 11);
+static MESON_SC2_SYS_GATE(sc2_rsa, CLKCTRL_SYS_CLK_EN0_REG2, 18);
+static MESON_SC2_SYS_GATE(sc2_cpu_debug, CLKCTRL_SYS_CLK_EN0_REG2, 19);
+static MESON_SC2_SYS_GATE(sc2_dspa, CLKCTRL_SYS_CLK_EN0_REG2, 21);
+static MESON_SC2_SYS_GATE(sc2_vpu_intr, CLKCTRL_SYS_CLK_EN0_REG2, 25);
+static MESON_SC2_SYS_GATE(sc2_sar_adc, CLKCTRL_SYS_CLK_EN0_REG2, 28);
+static MESON_SC2_SYS_GATE(sc2_gic, CLKCTRL_SYS_CLK_EN0_REG2, 30);
+
+/*CLKCTRL_SYS_CLK_EN0_REG3*/
+static MESON_SC2_SYS_GATE(sc2_pwm_ab, CLKCTRL_SYS_CLK_EN0_REG3, 7);
+static MESON_SC2_SYS_GATE(sc2_pwm_cd, CLKCTRL_SYS_CLK_EN0_REG3, 8);
+static MESON_SC2_SYS_GATE(sc2_pwm_ef, CLKCTRL_SYS_CLK_EN0_REG3, 9);
+static MESON_SC2_SYS_GATE(sc2_pwm_gh, CLKCTRL_SYS_CLK_EN0_REG3, 10);
+static MESON_SC2_SYS_GATE(sc2_pwm_ij, CLKCTRL_SYS_CLK_EN0_REG3, 11);
+
+/* Array of all clocks provided by this provider */
+static struct clk_hw_onecell_data sc2_hw_onecell_data = {
+	.hws = {
+		[CLKID_FIXED_PLL_DCO]		= &sc2_fixed_pll_dco.hw,
+		[CLKID_FIXED_PLL]		= &sc2_fixed_pll.hw,
+		[CLKID_SYS_PLL_DCO]		= &sc2_sys_pll_dco.hw,
+		[CLKID_SYS_PLL]			= &sc2_sys_pll.hw,
+		[CLKID_FCLK_DIV2_DIV]		= &sc2_fclk_div2_div.hw,
+		[CLKID_FCLK_DIV2]		= &sc2_fclk_div2.hw,
+		[CLKID_FCLK_DIV3_DIV]		= &sc2_fclk_div3_div.hw,
+		[CLKID_FCLK_DIV3]		= &sc2_fclk_div3.hw,
+		[CLKID_FCLK_DIV4_DIV]		= &sc2_fclk_div4_div.hw,
+		[CLKID_FCLK_DIV4]		= &sc2_fclk_div4.hw,
+		[CLKID_FCLK_DIV5_DIV]		= &sc2_fclk_div5_div.hw,
+		[CLKID_FCLK_DIV5]		= &sc2_fclk_div5.hw,
+		[CLKID_FCLK_DIV7_DIV]		= &sc2_fclk_div7_div.hw,
+		[CLKID_FCLK_DIV7]		= &sc2_fclk_div7.hw,
+		[CLKID_FCLK_DIV2P5_DIV]		= &sc2_fclk_div2p5_div.hw,
+		[CLKID_FCLK_DIV2P5]		= &sc2_fclk_div2p5.hw,
+
+		[CLKID_GP0_PLL_DCO]		= &sc2_gp0_pll_dco.hw,
+		[CLKID_GP0_PLL]			= &sc2_gp0_pll.hw,
+		[CLKID_GP1_PLL_DCO]		= &sc2_gp1_pll_dco.hw,
+		[CLKID_GP1_PLL]			= &sc2_gp1_pll.hw,
+
+		[CLKID_CPU_CLK_DYN0_SEL]	= &sc2_cpu_clk_premux0.hw,
+		[CLKID_CPU_CLK_DYN0_DIV]	= &sc2_cpu_clk_mux0_div.hw,
+		[CLKID_CPU_CLK_DYN0]		= &sc2_cpu_clk_postmux0.hw,
+		[CLKID_CPU_CLK_DYN1_SEL]	= &sc2_cpu_clk_premux1.hw,
+		[CLKID_CPU_CLK_DYN1_DIV]	= &sc2_cpu_clk_mux1_div.hw,
+		[CLKID_CPU_CLK_DYN1]		= &sc2_cpu_clk_postmux1.hw,
+		[CLKID_CPU_CLK_DYN]		= &sc2_cpu_clk_dyn.hw,
+		[CLKID_CPU_CLK]			= &sc2_cpu_clk.hw,
+		[CLKID_DSU_CLK_DYN0_SEL]	= &sc2_dsu_clk_premux0.hw,
+		[CLKID_DSU_CLK_DYN0_DIV]	= &sc2_dsu_clk_mux0_div.hw,
+		[CLKID_DSU_CLK_DYN0]		= &sc2_dsu_clk_postmux0.hw,
+		[CLKID_DSU_CLK_DYN1_SEL]	= &sc2_dsu_clk_premux1.hw,
+		[CLKID_DSU_CLK_DYN1_DIV]	= &sc2_dsu_clk_mux1_div.hw,
+		[CLKID_DSU_CLK_DYN1]		= &sc2_dsu_clk_postmux1.hw,
+		[CLKID_DSU_CLK_DYN]		= &sc2_dsu_clk_dyn.hw,
+		[CLKID_DSU_CLK_FINAL]		= &sc2_dsu_final_clk.hw,
+		[CLKID_DSU_CLK]			= &sc2_dsu_clk.hw,
+		[CLKID_CPU1_CLK]		= &sc2_cpu1_clk.hw,
+		[CLKID_CPU2_CLK]		= &sc2_cpu2_clk.hw,
+		[CLKID_CPU3_CLK]		= &sc2_cpu3_clk.hw,
+
+		[CLKID_HIFI_PLL_DCO]		= &sc2_hifi_pll_dco.hw,
+		[CLKID_HIFI_PLL]		= &sc2_hifi_pll.hw,
+		[CLKID_PCIE_PLL_DCO]		= &sc2_pcie_pll_dco.hw,
+		[CLKID_PCIE_PLL_DCO_DIV2]	= &sc2_pcie_pll_dco_div2.hw,
+		[CLKID_PCIE_PLL_OD]		= &sc2_pcie_pll_od.hw,
+		[CLKID_PCIE_PLL]		= &sc2_pcie_pll.hw,
+		[CLKID_PCIE_BGP]		= &sc2_pcie_bgp.hw,
+		[CLKID_PCIE_HCSL]		= &sc2_pcie_hcsl.hw,
+		[CLKID_HDMI_PLL_DCO]		= &sc2_hdmi_pll_dco.hw,
+		[CLKID_HDMI_PLL_OD]		= &sc2_hdmi_pll_od.hw,
+		[CLKID_HDMI_PLL]		= &sc2_hdmi_pll.hw,
+		[CLKID_MPLL_50M_DIV]		= &sc2_mpll_50m_div.hw,
+		[CLKID_MPLL_50M]		= &sc2_mpll_50m.hw,
+		[CLKID_MPLL_PREDIV]		= &sc2_mpll_prediv.hw,
+		[CLKID_MPLL0_DIV]		= &sc2_mpll0_div.hw,
+		[CLKID_MPLL0]			= &sc2_mpll0.hw,
+		[CLKID_MPLL1_DIV]		= &sc2_mpll1_div.hw,
+		[CLKID_MPLL1]			= &sc2_mpll1.hw,
+		[CLKID_MPLL2_DIV]		= &sc2_mpll2_div.hw,
+		[CLKID_MPLL2]			= &sc2_mpll2.hw,
+		[CLKID_MPLL3_DIV]		= &sc2_mpll3_div.hw,
+		[CLKID_MPLL3]			= &sc2_mpll3.hw,
+
+		[CLKID_RTC_32K_CLKIN]		= &sc2_rtc_32k_clkin.hw,
+		[CLKID_RTC_32K_DIV]		= &sc2_rtc_32k_div.hw,
+		[CLKID_RTC_32K_XATL]		= &sc2_rtc_32k_xtal.hw,
+		[CLKID_RTC_32K_MUX]		= &sc2_rtc_32k_sel.hw,
+		[CLKID_RTC_CLK]			= &sc2_rtc_clk.hw,
+
+		[CLKID_SYS_CLK_B_MUX]		= &sc2_sysclk_b_sel.hw,
+		[CLKID_SYS_CLK_B_DIV]		= &sc2_sysclk_b_div.hw,
+		[CLKID_SYS_CLK_B_GATE]		= &sc2_sysclk_b.hw,
+		[CLKID_SYS_CLK_A_MUX]		= &sc2_sysclk_a_sel.hw,
+		[CLKID_SYS_CLK_A_DIV]		= &sc2_sysclk_a_div.hw,
+		[CLKID_SYS_CLK_A_GATE]		= &sc2_sysclk_a.hw,
+		[CLKID_SYS_CLK]			= &sc2_sys_clk.hw,
+
+		[CLKID_CECA_32K_CLKIN]		= &sc2_ceca_32k_clkin.hw,
+		[CLKID_CECA_32K_DIV]		= &sc2_ceca_32k_div.hw,
+		[CLKID_CECA_32K_MUX_PRE]	= &sc2_ceca_32k_sel_pre.hw,
+		[CLKID_CECA_32K_MUX]		= &sc2_ceca_32k_sel.hw,
+		[CLKID_CECA_32K_CLKOUT]		= &sc2_ceca_32k_clkout.hw,
+
+		[CLKID_CECB_32K_CLKIN]		= &sc2_cecb_32k_clkin.hw,
+		[CLKID_CECB_32K_DIV]		= &sc2_cecb_32k_div.hw,
+		[CLKID_CECB_32K_MUX_PRE]	= &sc2_cecb_32k_sel_pre.hw,
+		[CLKID_CECB_32K_MUX]		= &sc2_cecb_32k_sel.hw,
+		[CLKID_CECB_32K_CLKOUT]		= &sc2_cecb_32k_clkout.hw,
+
+		[CLKID_SC_CLK_MUX]		= &sc2_sc_clk_mux.hw,
+		[CLKID_SC_CLK_DIV]		= &sc2_sc_clk_div.hw,
+		[CLKID_SC_CLK_GATE]		= &sc2_sc_clk_gate.hw,
+
+		[CLKID_DSPA_CLK_B_MUX]		= &sc2_dspa_b_mux.hw,
+		[CLKID_DSPA_CLK_B_DIV]		= &sc2_dspa_b_div.hw,
+		[CLKID_DSPA_CLK_B_GATE]		= &sc2_dspa_b_gate.hw,
+		[CLKID_DSPA_CLK_A_MUX]		= &sc2_dspa_a_mux.hw,
+		[CLKID_DSPA_CLK_A_DIV]		= &sc2_dspa_a_div.hw,
+		[CLKID_DSPA_CLK_A_GATE]		= &sc2_dspa_a_gate.hw,
+		[CLKID_DSPA_CLK]		= &sc2_dspa_mux.hw,
+
+		[CLKID_24M_CLK_GATE]		= &sc2_24M_clk_gate.hw,
+		[CLKID_12M_CLK_DIV]		= &sc2_12M_clk_div.hw,
+		[CLKID_12M_CLK_GATE]		= &sc2_12M_clk_gate.hw,
+		[CLKID_25M_CLK_DIV]		= &sc2_25M_clk_div.hw,
+		[CLKID_25M_CLK_GATE]		= &sc2_25M_clk_gate.hw,
+
+		[CLKID_VID_PLL]			= &sc2_vid_pll_div.hw,
+		[CLKID_VID_PLL_MUX]		= &sc2_vid_pll_sel.hw,
+		[CLKID_VID_PLL]			= &sc2_vid_pll.hw,
+		[CLKID_VCLK_MUX]		= &sc2_vclk_sel.hw,
+		[CLKID_VCLK2_MUX]		= &sc2_vclk2_sel.hw,
+		[CLKID_VCLK_INPUT]		= &sc2_vclk_input.hw,
+		[CLKID_VCLK2_INPUT]		= &sc2_vclk2_input.hw,
+		[CLKID_VCLK_DIV]		= &sc2_vclk_div.hw,
+		[CLKID_VCLK2_DIV]		= &sc2_vclk2_div.hw,
+		[CLKID_VCLK]			= &sc2_vclk.hw,
+		[CLKID_VCLK2]			= &sc2_vclk2.hw,
+		[CLKID_VCLK_DIV1]		= &sc2_vclk_div1.hw,
+		[CLKID_VCLK_DIV2_EN]		= &sc2_vclk_div2_en.hw,
+		[CLKID_VCLK_DIV4_EN]		= &sc2_vclk_div4_en.hw,
+		[CLKID_VCLK_DIV6_EN]		= &sc2_vclk_div6_en.hw,
+		[CLKID_VCLK_DIV12_EN]		= &sc2_vclk_div12_en.hw,
+		[CLKID_VCLK2_DIV1]		= &sc2_vclk2_div1.hw,
+		[CLKID_VCLK2_DIV2_EN]		= &sc2_vclk2_div2_en.hw,
+		[CLKID_VCLK2_DIV4_EN]		= &sc2_vclk2_div4_en.hw,
+		[CLKID_VCLK2_DIV6_EN]		= &sc2_vclk2_div6_en.hw,
+		[CLKID_VCLK2_DIV12_EN]		= &sc2_vclk2_div12_en.hw,
+		[CLKID_VCLK_DIV2]		= &sc2_vclk_div2.hw,
+		[CLKID_VCLK_DIV4]		= &sc2_vclk_div4.hw,
+		[CLKID_VCLK_DIV6]		= &sc2_vclk_div6.hw,
+		[CLKID_VCLK_DIV12]		= &sc2_vclk_div12.hw,
+		[CLKID_VCLK2_DIV2]		= &sc2_vclk2_div2.hw,
+		[CLKID_VCLK2_DIV4]		= &sc2_vclk2_div4.hw,
+		[CLKID_VCLK2_DIV6]		= &sc2_vclk2_div6.hw,
+		[CLKID_VCLK2_DIV12]		= &sc2_vclk2_div12.hw,
+		[CLKID_CTS_ENCI_MUX]		= &sc2_cts_enci_sel.hw,
+		[CLKID_CTS_ENCP_MUX]		= &sc2_cts_encp_sel.hw,
+		[CLKID_CTS_VDAC_MUX]		= &sc2_cts_vdac_sel.hw,
+		[CLKID_HDMI_TX_MUX]		= &sc2_hdmi_tx_sel.hw,
+		[CLKID_CTS_ENCI]		= &sc2_cts_enci.hw,
+		[CLKID_CTS_ENCP]		= &sc2_cts_encp.hw,
+		[CLKID_CTS_VDAC]		= &sc2_cts_vdac.hw,
+		[CLKID_HDMI_TX]			= &sc2_hdmi_tx.hw,
+		[CLKID_HDMI_MUX]		= &sc2_hdmi_sel.hw,
+		[CLKID_HDMI_DIV]		= &sc2_hdmi_div.hw,
+		[CLKID_HDMI]			= &sc2_hdmi.hw,
+
+		[CLKID_TS_CLK_DIV]		= &sc2_ts_clk_div.hw,
+		[CLKID_TS_CLK_GATE]		= &sc2_ts_clk_gate.hw,
+
+		[CLKID_MALI_0_SEL]		= &sc2_mali_0_sel.hw,
+		[CLKID_MALI_0_DIV]		= &sc2_mali_0_div.hw,
+		[CLKID_MALI_0]			= &sc2_mali_0.hw,
+		[CLKID_MALI_1_SEL]		= &sc2_mali_1_sel.hw,
+		[CLKID_MALI_1_DIV]		= &sc2_mali_1_div.hw,
+		[CLKID_MALI_1]			= &sc2_mali_1.hw,
+		[CLKID_MALI]			= &sc2_mali_mux.hw,
+
+		[CLKID_VDEC_P0_MUX]		= &sc2_vdec_p0_mux.hw,
+		[CLKID_VDEC_P0_DIV]		= &sc2_vdec_p0_div.hw,
+		[CLKID_VDEC_P0]			= &sc2_vdec_p0.hw,
+		[CLKID_VDEC_P1_MUX]		= &sc2_vdec_p1_mux.hw,
+		[CLKID_VDEC_P1_DIV]		= &sc2_vdec_p1_div.hw,
+		[CLKID_VDEC_P1]			= &sc2_vdec_p1.hw,
+		[CLKID_VDEC_MUX]		= &sc2_vdec_mux.hw,
+
+		[CLKID_HCODEC_P0_MUX]		= &sc2_hcodec_p0_mux.hw,
+		[CLKID_HCODEC_P0_DIV]		= &sc2_hcodec_p0_div.hw,
+		[CLKID_HCODEC_P0]		= &sc2_hcodec_p0.hw,
+		[CLKID_HCODEC_P1_MUX]		= &sc2_hcodec_p1_mux.hw,
+		[CLKID_HCODEC_P1_DIV]		= &sc2_hcodec_p1_div.hw,
+		[CLKID_HCODEC_P1]		= &sc2_hcodec_p1.hw,
+		[CLKID_HCODEC_MUX]		= &sc2_hcodec_mux.hw,
+
+		[CLKID_HEVCB_P0_MUX]		= &sc2_hevcb_p0_mux.hw,
+		[CLKID_HEVCB_P0_DIV]		= &sc2_hevcb_p0_div.hw,
+		[CLKID_HEVCB_P0]		= &sc2_hevcb_p0.hw,
+		[CLKID_HEVCB_P1_MUX]		= &sc2_hevcb_p1_mux.hw,
+		[CLKID_HEVCB_P1_DIV]		= &sc2_hevcb_p1_div.hw,
+		[CLKID_HEVCB_P1]		= &sc2_hevcb_p1.hw,
+		[CLKID_HEVCB_MUX]		= &sc2_hevcb_mux.hw,
+
+		[CLKID_HEVCF_P0_MUX]		= &sc2_hevcf_p0_mux.hw,
+		[CLKID_HEVCF_P0_DIV]		= &sc2_hevcf_p0_div.hw,
+		[CLKID_HEVCF_P0]		= &sc2_hevcf_p0.hw,
+		[CLKID_HEVCF_P1_MUX]		= &sc2_hevcf_p1_mux.hw,
+		[CLKID_HEVCF_P1_DIV]		= &sc2_hevcf_p1_div.hw,
+		[CLKID_HEVCF_P1]		= &sc2_hevcf_p1.hw,
+		[CLKID_HEVCF_MUX]		= &sc2_hevcf_mux.hw,
+
+		[CLKID_WAVE_A_MUX]		= &sc2_wave_a_sel.hw,
+		[CLKID_WAVE_A_DIV]		= &sc2_wave_a_div.hw,
+		[CLKID_WAVE_A_GATE]		= &sc2_wave_aclk.hw,
+		[CLKID_WAVE_B_MUX]		= &sc2_wave_b_sel.hw,
+		[CLKID_WAVE_B_DIV]		= &sc2_wave_b_div.hw,
+		[CLKID_WAVE_B_GATE]		= &sc2_wave_bclk.hw,
+		[CLKID_WAVE_C_MUX]		= &sc2_wave_c_sel.hw,
+		[CLKID_WAVE_C_DIV]		= &sc2_wave_c_div.hw,
+		[CLKID_WAVE_C_GATE]		= &sc2_wave_cclk.hw,
+
+		[CLKID_VPU_0_MUX]		= &sc2_vpu_0_sel.hw,
+		[CLKID_VPU_0_DIV]		= &sc2_vpu_0_div.hw,
+		[CLKID_VPU_0]			= &sc2_vpu_0.hw,
+		[CLKID_VPU_1_MUX]		= &sc2_vpu_1_sel.hw,
+		[CLKID_VPU_1_DIV]		= &sc2_vpu_1_div.hw,
+		[CLKID_VPU_1]			= &sc2_vpu_1.hw,
+		[CLKID_VPU]			= &sc2_vpu.hw,
+
+		[CLKID_VPU_CLKB_TMP_MUX]	= &sc2_vpu_clkb_tmp_mux.hw,
+		[CLKID_VPU_CLKB_TMP_DIV]	= &sc2_vpu_clkb_tmp_div.hw,
+		[CLKID_VPU_CLKB_TMP]		= &sc2_vpu_clkb_tmp.hw,
+		[CLKID_VPU_CLKB_DIV]		= &sc2_vpu_clkb_div.hw,
+		[CLKID_VPU_CLKB]		= &sc2_vpu_clkb.hw,
+		[CLKID_VPU_CLKC_P0_MUX]		= &sc2_vpu_clkc_p0_mux.hw,
+		[CLKID_VPU_CLKC_P0_DIV]		= &sc2_vpu_clkc_p0_div.hw,
+		[CLKID_VPU_CLKC_P0]		= &sc2_vpu_clkc_p0.hw,
+		[CLKID_VPU_CLKC_P1_MUX]		= &sc2_vpu_clkc_p1_mux.hw,
+		[CLKID_VPU_CLKC_P1_DIV]		= &sc2_vpu_clkc_p1_div.hw,
+		[CLKID_VPU_CLKC_P1]		= &sc2_vpu_clkc_p1.hw,
+		[CLKID_VPU_CLKC_MUX]		= &sc2_vpu_clkc_mux.hw,
+
+		[CLKID_VAPB_0_MUX]		= &sc2_vapb_0_sel.hw,
+		[CLKID_VAPB_0_DIV]		= &sc2_vapb_0_div.hw,
+		[CLKID_VAPB_0]			= &sc2_vapb_0.hw,
+		[CLKID_VAPB_1_MUX]		= &sc2_vapb_1_sel.hw,
+		[CLKID_VAPB_1_DIV]		= &sc2_vapb_1_div.hw,
+		[CLKID_VAPB_1]			= &sc2_vapb_1.hw,
+		[CLKID_VAPB]			= &sc2_vapb.hw,
+
+		[CLKID_GE2D]			= &sc2_ge2d_gate.hw,
+
+		[CLKID_VDIN_MEAS_MUX]		= &sc2_vdin_meas_mux.hw,
+		[CLKID_VDIN_MEAS_DIV]		= &sc2_vdin_meas_div.hw,
+		[CLKID_VDIN_MEAS_GATE]		= &sc2_vdin_meas_gate.hw,
+
+		[CLKID_SD_EMMC_C_CLK_MUX]	= &sc2_sd_emmc_c_clk0_sel.hw,
+		[CLKID_SD_EMMC_C_CLK_DIV]	= &sc2_sd_emmc_c_clk0_div.hw,
+		[CLKID_SD_EMMC_C_CLK]		= &sc2_sd_emmc_c_clk0.hw,
+
+		[CLKID_SD_EMMC_A_CLK_MUX]	= &sc2_sd_emmc_a_clk0_sel.hw,
+		[CLKID_SD_EMMC_A_CLK_DIV]	= &sc2_sd_emmc_a_clk0_div.hw,
+		[CLKID_SD_EMMC_A_CLK]		= &sc2_sd_emmc_a_clk0.hw,
+		[CLKID_SD_EMMC_B_CLK_MUX]	= &sc2_sd_emmc_b_clk0_sel.hw,
+		[CLKID_SD_EMMC_B_CLK_DIV]	= &sc2_sd_emmc_b_clk0_div.hw,
+		[CLKID_SD_EMMC_B_CLK]		= &sc2_sd_emmc_b_clk0.hw,
+
+		[CLKID_SPICC0_MUX]		= &sc2_spicc0_mux.hw,
+		[CLKID_SPICC0_DIV]		= &sc2_spicc0_div.hw,
+		[CLKID_SPICC0_GATE]		= &sc2_spicc0_gate.hw,
+		[CLKID_SPICC1_MUX]		= &sc2_spicc1_mux.hw,
+		[CLKID_SPICC1_DIV]		= &sc2_spicc1_div.hw,
+		[CLKID_SPICC1_GATE]		= &sc2_spicc1_gate.hw,
+
+		[CLKID_PWM_A_MUX]		= &sc2_pwm_a_mux.hw,
+		[CLKID_PWM_A_DIV]		= &sc2_pwm_a_div.hw,
+		[CLKID_PWM_A_GATE]		= &sc2_pwm_a_gate.hw,
+		[CLKID_PWM_B_MUX]		= &sc2_pwm_b_mux.hw,
+		[CLKID_PWM_B_DIV]		= &sc2_pwm_b_div.hw,
+		[CLKID_PWM_B_GATE]		= &sc2_pwm_b_gate.hw,
+		[CLKID_PWM_C_MUX]		= &sc2_pwm_c_mux.hw,
+		[CLKID_PWM_C_DIV]		= &sc2_pwm_c_div.hw,
+		[CLKID_PWM_C_GATE]		= &sc2_pwm_c_gate.hw,
+		[CLKID_PWM_D_MUX]		= &sc2_pwm_d_mux.hw,
+		[CLKID_PWM_D_DIV]		= &sc2_pwm_d_div.hw,
+		[CLKID_PWM_D_GATE]		= &sc2_pwm_d_gate.hw,
+		[CLKID_PWM_E_MUX]		= &sc2_pwm_e_mux.hw,
+		[CLKID_PWM_E_DIV]		= &sc2_pwm_e_div.hw,
+		[CLKID_PWM_E_GATE]		= &sc2_pwm_e_gate.hw,
+		[CLKID_PWM_F_MUX]		= &sc2_pwm_f_mux.hw,
+		[CLKID_PWM_F_DIV]		= &sc2_pwm_f_div.hw,
+		[CLKID_PWM_F_GATE]		= &sc2_pwm_f_gate.hw,
+		[CLKID_PWM_G_MUX]		= &sc2_pwm_g_mux.hw,
+		[CLKID_PWM_G_DIV]		= &sc2_pwm_g_div.hw,
+		[CLKID_PWM_G_GATE]		= &sc2_pwm_g_gate.hw,
+		[CLKID_PWM_H_MUX]		= &sc2_pwm_h_mux.hw,
+		[CLKID_PWM_H_DIV]		= &sc2_pwm_h_div.hw,
+		[CLKID_PWM_H_GATE]		= &sc2_pwm_h_gate.hw,
+		[CLKID_PWM_I_MUX]		= &sc2_pwm_i_mux.hw,
+		[CLKID_PWM_I_DIV]		= &sc2_pwm_i_div.hw,
+		[CLKID_PWM_I_GATE]		= &sc2_pwm_i_gate.hw,
+		[CLKID_PWM_J_MUX]		= &sc2_pwm_j_mux.hw,
+		[CLKID_PWM_J_DIV]		= &sc2_pwm_j_div.hw,
+		[CLKID_PWM_J_GATE]		= &sc2_pwm_j_gate.hw,
+
+		[CLKID_SARADC_MUX]		= &sc2_saradc_mux.hw,
+		[CLKID_SARADC_DIV]		= &sc2_saradc_div.hw,
+		[CLKID_SARADC_GATE]		= &sc2_saradc_gate.hw,
+
+		[CLKID_GEN_MUX]			= &sc2_gen_sel.hw,
+		[CLKID_GEN_DIV]			= &sc2_gen_div.hw,
+		[CLKID_GEN_GATE]		= &sc2_gen.hw,
+
+		[CLKID_DDR]			= &sc2_ddr.hw,
+		[CLKID_DOS]			= &sc2_dos.hw,
+		[CLKID_ETHPHY]			= &sc2_ethphy.hw,
+		[CLKID_MALI_GATE]		= &sc2_mali.hw,
+		[CLKID_AOCPU]			= &sc2_aocpu.hw,
+		[CLKID_AUCPU]			= &sc2_aucpu.hw,
+		[CLKID_CEC]			= &sc2_cec.hw,
+		[CLKID_SD_EMMC_A]		= &sc2_sdemmca.hw,
+		[CLKID_SD_EMMC_B]		= &sc2_sdemmcb.hw,
+		[CLKID_NAND]			= &sc2_nand.hw,
+		[CLKID_SMARTCARD]		= &sc2_smartcard.hw,
+		[CLKID_ACODEC]			= &sc2_acodec.hw,
+		[CLKID_SPIFC]			= &sc2_spifc.hw,
+		[CLKID_MSR_CLK]			= &sc2_msr_clk.hw,
+		[CLKID_IR_CTRL]			= &sc2_ir_ctrl.hw,
+
+		[CLKID_AUDIO]			= &sc2_audio.hw,
+		[CLKID_ETH]			= &sc2_eth.hw,
+		[CLKID_UART_A]			= &sc2_uart_a.hw,
+		[CLKID_UART_B]			= &sc2_uart_b.hw,
+		[CLKID_UART_C]			= &sc2_uart_c.hw,
+		[CLKID_UART_D]			= &sc2_uart_d.hw,
+		[CLKID_UART_E]			= &sc2_uart_e.hw,
+		[CLKID_AIFIFO]			= &sc2_aififo.hw,
+		[CLKID_TS_DDR]			= &sc2_ts_ddr.hw,
+		[CLKID_TS_PLL]			= &sc2_ts_pll.hw,
+		[CLKID_G2D]			= &sc2_g2d.hw,
+		[CLKID_SPICC0]			= &sc2_spicc0.hw,
+		[CLKID_SPICC1]			= &sc2_spicc1.hw,
+		[CLKID_PCIE]			= &sc2_pcie.hw,
+		[CLKID_USB]			= &sc2_usb.hw,
+		[CLKID_PCIE_PHY]		= &sc2_pcie_phy.hw,
+		[CLKID_I2C_M_A]			= &sc2_i2c_m_a.hw,
+		[CLKID_I2C_M_B]			= &sc2_i2c_m_b.hw,
+		[CLKID_I2C_M_C]			= &sc2_i2c_m_c.hw,
+		[CLKID_I2C_M_D]			= &sc2_i2c_m_d.hw,
+		[CLKID_I2C_M_E]			= &sc2_i2c_m_e.hw,
+		[CLKID_I2C_M_F]			= &sc2_i2c_m_f.hw,
+		[CLKID_HDMITX_APB]		= &sc2_hdmitx_apb.hw,
+		[CLKID_I2C_S_A]			= &sc2_i2c_s_a.hw,
+		[CLKID_USB1_TO_DDR]		= &sc2_usb1_to_ddr.hw,
+		[CLKID_HDCP22]			= &sc2_hdcp22.hw,
+		[CLKID_MMC_APB]			= &sc2_mmc_apb.hw,
+		[CLKID_RSA]			= &sc2_rsa.hw,
+		[CLKID_CPU_DEBUG]		= &sc2_cpu_debug.hw,
+		[CLKID_DSPA]			= &sc2_dspa.hw,
+		[CLKID_VPU_INTR]		= &sc2_vpu_intr.hw,
+		[CLKID_SAR_ADC]			= &sc2_sar_adc.hw,
+		[CLKID_GIC]			= &sc2_gic.hw,
+		[CLKID_PWM_AB]			= &sc2_pwm_ab.hw,
+		[CLKID_PWM_CD]			= &sc2_pwm_cd.hw,
+		[CLKID_PWM_EF]			= &sc2_pwm_ef.hw,
+		[CLKID_PWM_GH]			= &sc2_pwm_gh.hw,
+		[CLKID_PWM_IJ]			= &sc2_pwm_ij.hw,
+
+		[NR_CLKS]			= NULL
+	},
+	.num = NR_CLKS,
+};
+
+/* Convenience table to populate regmap in .probe */
+static struct clk_regmap *const sc2_clk_regmaps[] __initconst = {
+	&sc2_rtc_32k_clkin,
+	&sc2_rtc_32k_div,
+	&sc2_rtc_32k_xtal,
+	&sc2_rtc_32k_sel,
+	&sc2_rtc_clk,
+
+	&sc2_sysclk_b_sel,
+	&sc2_sysclk_b_div,
+	&sc2_sysclk_b,
+	&sc2_sysclk_a_sel,
+	&sc2_sysclk_a_div,
+	&sc2_sysclk_a,
+	&sc2_sys_clk,
+
+	&sc2_ceca_32k_clkin,
+	&sc2_ceca_32k_div,
+	&sc2_ceca_32k_sel_pre,
+	&sc2_ceca_32k_sel,
+	&sc2_ceca_32k_clkout,
+	&sc2_cecb_32k_clkin,
+	&sc2_cecb_32k_div,
+	&sc2_cecb_32k_sel_pre,
+	&sc2_cecb_32k_sel,
+	&sc2_cecb_32k_clkout,
+
+	&sc2_sc_clk_mux,
+	&sc2_sc_clk_div,
+	&sc2_sc_clk_gate,
+
+	&sc2_dspa_a_mux,
+	&sc2_dspa_a_div,
+	&sc2_dspa_a_gate,
+	&sc2_dspa_b_mux,
+	&sc2_dspa_b_div,
+	&sc2_dspa_b_gate,
+	&sc2_dspa_mux,
+
+	&sc2_24M_clk_gate,
+	&sc2_12M_clk_gate,
+	&sc2_25M_clk_div,
+	&sc2_25M_clk_gate,
+	&sc2_vid_pll_div,
+	&sc2_vid_pll_sel,
+	&sc2_vid_pll,
+	&sc2_vclk_sel,
+	&sc2_vclk2_sel,
+	&sc2_vclk_input,
+	&sc2_vclk2_input,
+	&sc2_vclk_div,
+	&sc2_vclk2_div,
+	&sc2_vclk,
+	&sc2_vclk2,
+	&sc2_vclk_div1,
+	&sc2_vclk_div2_en,
+	&sc2_vclk_div4_en,
+	&sc2_vclk_div6_en,
+	&sc2_vclk_div12_en,
+	&sc2_vclk2_div1,
+	&sc2_vclk2_div2_en,
+	&sc2_vclk2_div4_en,
+	&sc2_vclk2_div6_en,
+	&sc2_vclk2_div12_en,
+	&sc2_cts_enci_sel,
+	&sc2_cts_encp_sel,
+	&sc2_cts_vdac_sel,
+	&sc2_hdmi_tx_sel,
+	&sc2_cts_enci,
+	&sc2_cts_encp,
+	&sc2_cts_vdac,
+	&sc2_hdmi_tx,
+
+	&sc2_hdmi_sel,
+	&sc2_hdmi_div,
+	&sc2_hdmi,
+	&sc2_ts_clk_div,
+	&sc2_ts_clk_gate,
+
+	&sc2_mali_0_sel,
+	&sc2_mali_0_div,
+	&sc2_mali_0,
+	&sc2_mali_1_sel,
+	&sc2_mali_1_div,
+	&sc2_mali_1,
+	&sc2_mali_mux,
+
+	&sc2_vdec_p0_mux,
+	&sc2_vdec_p0_div,
+	&sc2_vdec_p0,
+	&sc2_vdec_p1_mux,
+	&sc2_vdec_p1_div,
+	&sc2_vdec_p1,
+	&sc2_vdec_mux,
+
+	&sc2_hcodec_p0_mux,
+	&sc2_hcodec_p0_div,
+	&sc2_hcodec_p0,
+	&sc2_hcodec_p1_mux,
+	&sc2_hcodec_p1_div,
+	&sc2_hcodec_p1,
+	&sc2_hcodec_mux,
+
+	&sc2_hevcb_p0_mux,
+	&sc2_hevcb_p0_div,
+	&sc2_hevcb_p0,
+	&sc2_hevcb_p1_mux,
+	&sc2_hevcb_p1_div,
+	&sc2_hevcb_p1,
+	&sc2_hevcb_mux,
+
+	&sc2_hevcf_p0_mux,
+	&sc2_hevcf_p0_div,
+	&sc2_hevcf_p0,
+	&sc2_hevcf_p1_mux,
+	&sc2_hevcf_p1_div,
+	&sc2_hevcf_p1,
+	&sc2_hevcf_mux,
+
+	&sc2_wave_a_sel,
+	&sc2_wave_a_div,
+	&sc2_wave_aclk,
+	&sc2_wave_b_sel,
+	&sc2_wave_b_div,
+	&sc2_wave_bclk,
+	&sc2_wave_c_sel,
+	&sc2_wave_c_div,
+	&sc2_wave_cclk,
+
+	&sc2_vpu_0_sel,
+	&sc2_vpu_0_div,
+	&sc2_vpu_0,
+	&sc2_vpu_1_sel,
+	&sc2_vpu_1_div,
+	&sc2_vpu_1,
+	&sc2_vpu,
+	&sc2_vpu_clkb_tmp_mux,
+	&sc2_vpu_clkb_tmp_div,
+	&sc2_vpu_clkb_tmp,
+	&sc2_vpu_clkb_div,
+	&sc2_vpu_clkb,
+	&sc2_vpu_clkc_p0_mux,
+	&sc2_vpu_clkc_p0_div,
+	&sc2_vpu_clkc_p0,
+	&sc2_vpu_clkc_p1_mux,
+	&sc2_vpu_clkc_p1_div,
+	&sc2_vpu_clkc_p1,
+	&sc2_vpu_clkc_mux,
+
+	&sc2_vapb_0_sel,
+	&sc2_vapb_0_div,
+	&sc2_vapb_0,
+	&sc2_vapb_1_sel,
+	&sc2_vapb_1_div,
+	&sc2_vapb_1,
+	&sc2_vapb,
+
+	&sc2_ge2d_gate,
+
+	&sc2_vdin_meas_mux,
+	&sc2_vdin_meas_div,
+	&sc2_vdin_meas_gate,
+
+	&sc2_sd_emmc_c_clk0_sel,
+	&sc2_sd_emmc_c_clk0_div,
+	&sc2_sd_emmc_c_clk0,
+	&sc2_sd_emmc_a_clk0_sel,
+	&sc2_sd_emmc_a_clk0_div,
+	&sc2_sd_emmc_a_clk0,
+	&sc2_sd_emmc_b_clk0_sel,
+	&sc2_sd_emmc_b_clk0_div,
+	&sc2_sd_emmc_b_clk0,
+
+	&sc2_spicc0_mux,
+	&sc2_spicc0_div,
+	&sc2_spicc0_gate,
+	&sc2_spicc1_mux,
+	&sc2_spicc1_div,
+	&sc2_spicc1_gate,
+
+	&sc2_pwm_a_mux,
+	&sc2_pwm_a_div,
+	&sc2_pwm_a_gate,
+	&sc2_pwm_b_mux,
+	&sc2_pwm_b_div,
+	&sc2_pwm_b_gate,
+	&sc2_pwm_c_mux,
+	&sc2_pwm_c_div,
+	&sc2_pwm_c_gate,
+	&sc2_pwm_d_mux,
+	&sc2_pwm_d_div,
+	&sc2_pwm_d_gate,
+	&sc2_pwm_e_mux,
+	&sc2_pwm_e_div,
+	&sc2_pwm_e_gate,
+	&sc2_pwm_f_mux,
+	&sc2_pwm_f_div,
+	&sc2_pwm_f_gate,
+	&sc2_pwm_g_mux,
+	&sc2_pwm_g_div,
+	&sc2_pwm_g_gate,
+	&sc2_pwm_h_mux,
+	&sc2_pwm_h_div,
+	&sc2_pwm_h_gate,
+	&sc2_pwm_i_mux,
+	&sc2_pwm_i_div,
+	&sc2_pwm_i_gate,
+	&sc2_pwm_j_mux,
+	&sc2_pwm_j_div,
+	&sc2_pwm_j_gate,
+
+	&sc2_saradc_mux,
+	&sc2_saradc_div,
+	&sc2_saradc_gate,
+
+	&sc2_gen_sel,
+	&sc2_gen_div,
+	&sc2_gen,
+
+	&sc2_ddr,
+	&sc2_dos,
+	&sc2_ethphy,
+	&sc2_mali,
+	&sc2_aocpu,
+	&sc2_aucpu,
+	&sc2_cec,
+	&sc2_sdemmca,
+	&sc2_sdemmcb,
+	&sc2_nand,
+	&sc2_smartcard,
+	&sc2_acodec,
+	&sc2_spifc,
+	&sc2_msr_clk,
+	&sc2_ir_ctrl,
+	&sc2_audio,
+	&sc2_eth,
+	&sc2_uart_a,
+	&sc2_uart_b,
+	&sc2_uart_c,
+	&sc2_uart_d,
+	&sc2_uart_e,
+	&sc2_aififo,
+	&sc2_ts_ddr,
+	&sc2_ts_pll,
+	&sc2_g2d,
+	&sc2_spicc0,
+	&sc2_spicc1,
+	&sc2_pcie,
+	&sc2_usb,
+	&sc2_pcie_phy,
+	&sc2_i2c_m_a,
+	&sc2_i2c_m_b,
+	&sc2_i2c_m_c,
+	&sc2_i2c_m_d,
+	&sc2_i2c_m_e,
+	&sc2_i2c_m_f,
+	&sc2_hdmitx_apb,
+	&sc2_i2c_s_a,
+	&sc2_usb1_to_ddr,
+	&sc2_hdcp22,
+	&sc2_mmc_apb,
+	&sc2_rsa,
+	&sc2_cpu_debug,
+	&sc2_dspa,
+	&sc2_vpu_intr,
+	&sc2_sar_adc,
+	&sc2_gic,
+	&sc2_pwm_ab,
+	&sc2_pwm_cd,
+	&sc2_pwm_ef,
+	&sc2_pwm_gh,
+	&sc2_pwm_ij
+};
+
+static struct clk_regmap *const sc2_cpu_clk_regmaps[] __initconst = {
+	&sc2_cpu_clk_premux0,
+	&sc2_cpu_clk_mux0_div,
+	&sc2_cpu_clk_postmux0,
+	&sc2_cpu_clk_premux1,
+	&sc2_cpu_clk_mux1_div,
+	&sc2_cpu_clk_postmux1,
+	&sc2_cpu_clk_dyn,
+	&sc2_cpu_clk,
+
+	&sc2_dsu_clk_premux0,
+	&sc2_dsu_clk_premux1,
+	&sc2_dsu_clk_mux0_div,
+	&sc2_dsu_clk_postmux0,
+	&sc2_dsu_clk_mux1_div,
+	&sc2_dsu_clk_postmux1,
+	&sc2_dsu_clk_dyn,
+	&sc2_dsu_final_clk,
+	&sc2_dsu_clk,
+
+	&sc2_cpu1_clk,
+	&sc2_cpu2_clk,
+	&sc2_cpu3_clk
+};
+
+static struct clk_regmap *const sc2_pll_clk_regmaps[] __initconst = {
+	&sc2_fixed_pll_dco,
+	&sc2_fixed_pll,
+	&sc2_sys_pll_dco,
+	&sc2_sys_pll,
+	&sc2_fclk_div2,
+	&sc2_fclk_div3,
+	&sc2_fclk_div4,
+	&sc2_fclk_div5,
+	&sc2_fclk_div7,
+	&sc2_fclk_div2p5,
+	&sc2_gp0_pll_dco,
+	&sc2_gp0_pll,
+	&sc2_gp1_pll_dco,
+	&sc2_gp1_pll,
+
+	&sc2_hifi_pll_dco,
+	&sc2_hifi_pll,
+	&sc2_pcie_pll_dco,
+	&sc2_pcie_pll_od,
+	&sc2_pcie_bgp,
+	&sc2_pcie_hcsl,
+	&sc2_hdmi_pll_dco,
+	&sc2_hdmi_pll_od,
+	&sc2_hdmi_pll,
+	&sc2_mpll_50m,
+	&sc2_mpll0_div,
+	&sc2_mpll0,
+	&sc2_mpll1_div,
+	&sc2_mpll1,
+	&sc2_mpll2_div,
+	&sc2_mpll2,
+	&sc2_mpll3_div,
+	&sc2_mpll3
+};
+
+static int meson_sc2_dvfs_setup_common(struct platform_device *pdev,
+				       struct clk_hw **hws)
+{
+	struct clk *notifier_clk;
+	int ret;
+
+	/* Setup clock notifier for cpu_clk_postmux0 */
+	sc2_cpu_clk_postmux0_nb_data.fclk_div2 = &sc2_fclk_div2.hw;
+	notifier_clk = sc2_cpu_clk_postmux0.hw.clk;
+	ret = clk_notifier_register(notifier_clk,
+				    &sc2_cpu_clk_postmux0_nb_data.nb);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register the cpu_clk_postmux0 notifier\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int meson_sc2_dvfs_setup(struct platform_device *pdev)
+{
+	struct clk_hw **hws = sc2_hw_onecell_data.hws;
+	int ret;
+
+	ret = meson_sc2_dvfs_setup_common(pdev, hws);
+	if (ret)
+		return ret;
+
+	/* Setup clock notifier for sys_pll */
+	ret = clk_notifier_register(sc2_sys_pll.hw.clk,
+				    &sc2_sys_pll_nb_data.nb);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register sys_pll notifier\n");
+		return ret;
+	}
+
+	/* Setup clock notifier for dsu */
+	/* set sc2_dsu_clk_premux1 parent to fclk_div2 1G */
+	ret = clk_set_parent(sc2_dsu_clk_premux1.hw.clk,
+			     sc2_fclk_div2.hw.clk);
+	if (ret < 0) {
+		pr_err("%s: failed to set dsu parent\n", __func__);
+		return ret;
+	}
+
+	ret = clk_notifier_register(sc2_dsu_clk_postmux0.hw.clk,
+				    &sc2_dsu_clk_postmux0_nb_data.nb);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register dsu notifier\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct regmap_config clkc_regmap_config = {
+	.reg_bits       = 32,
+	.val_bits       = 32,
+	.reg_stride     = 4,
+};
+
+static struct regmap *sc2_regmap_resource(struct device *dev, char *name)
+{
+	struct resource res;
+	void __iomem *base;
+	int i;
+	struct device_node *node = dev->of_node;
+
+	i = of_property_match_string(node, "reg-names", name);
+	if (of_address_to_resource(node, i, &res))
+		return ERR_PTR(-ENOENT);
+
+	base = devm_ioremap_resource(dev, &res);
+	if (IS_ERR(base))
+		return ERR_CAST(base);
+
+	clkc_regmap_config.max_register = resource_size(&res) - 4;
+	clkc_regmap_config.name = devm_kasprintf(dev, GFP_KERNEL,
+						 "%s-%s", node->name,
+						 name);
+	if (!clkc_regmap_config.name)
+		return ERR_PTR(-ENOMEM);
+
+	return devm_regmap_init_mmio(dev, base, &clkc_regmap_config);
+}
+
+static int __ref meson_sc2_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct regmap *basic_map;
+	struct regmap *pll_map;
+	struct regmap *cpu_clk_map;
+	int ret, i;
+
+	/* Get regmap for different clock area */
+	basic_map = sc2_regmap_resource(dev, "basic");
+	if (IS_ERR(basic_map)) {
+		dev_err(dev, "basic clk registers not found\n");
+		return PTR_ERR(basic_map);
+	}
+
+	pll_map = sc2_regmap_resource(dev, "pll");
+	if (IS_ERR(pll_map)) {
+		dev_err(dev, "pll clk registers not found\n");
+		return PTR_ERR(pll_map);
+	}
+
+	cpu_clk_map = sc2_regmap_resource(dev, "cpu_clk");
+	if (IS_ERR(cpu_clk_map)) {
+		dev_err(dev, "cpu clk registers not found\n");
+		return PTR_ERR(cpu_clk_map);
+	}
+
+	/* Populate regmap for the regmap backed clocks */
+	for (i = 0; i < ARRAY_SIZE(sc2_clk_regmaps); i++)
+		sc2_clk_regmaps[i]->map = basic_map;
+
+	for (i = 0; i < ARRAY_SIZE(sc2_cpu_clk_regmaps); i++)
+		sc2_cpu_clk_regmaps[i]->map = cpu_clk_map;
+
+	for (i = 0; i < ARRAY_SIZE(sc2_pll_clk_regmaps); i++)
+		sc2_pll_clk_regmaps[i]->map = pll_map;
+	regmap_write(pll_map, ANACTRL_MPLL_CTRL0, 0x00000543);
+
+	for (i = 0; i < sc2_hw_onecell_data.num; i++) {
+		/* array might be sparse */
+		if (!sc2_hw_onecell_data.hws[i])
+			continue;
+		/*
+		 * dev_err(dev, "register %d  %s\n",i,
+		 *	sc2_hw_onecell_data.hws[i]->init->name);
+		 */
+		ret = devm_clk_hw_register(dev, sc2_hw_onecell_data.hws[i]);
+		if (ret) {
+			dev_err(dev, "Clock registration failed\n");
+			return ret;
+		}
+	}
+
+	meson_sc2_dvfs_setup(pdev);
+
+	return devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get,
+					   &sc2_hw_onecell_data);
+}
+
+static const struct of_device_id clkc_match_table[] = {
+	{
+		.compatible = "amlogic,sc2-clkc"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, clkc_match_table);
+
+static struct platform_driver sc2_driver = {
+	.probe		= meson_sc2_probe,
+	.driver		= {
+		.name	= "sc2-clkc",
+		.of_match_table = clkc_match_table,
+	},
+};
+
+module_platform_driver(sc2_driver);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/meson/sc2.h b/drivers/clk/meson/sc2.h
new file mode 100644
index 000000000..bfeec20e9
--- /dev/null
+++ b/drivers/clk/meson/sc2.h
@@ -0,0 +1,320 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ *
+ * Copyright (c) 2018 Amlogic, inc.
+ *
+ */
+
+#ifndef __SC2_H
+#define __SC2_H
+
+/*
+ * Clock controller register offsets
+ * REG_BASE:  REGISTER_BASE_ADDR = 0xfe000000
+ */
+#define CLKCTRL_OSCIN_CTRL                         ((0x0001 << 2))
+#define CLKCTRL_RTC_BY_OSCIN_CTRL0                 ((0x0002 << 2))
+#define CLKCTRL_RTC_BY_OSCIN_CTRL1                 ((0x0003 << 2))
+#define CLKCTRL_RTC_CTRL                           ((0x0004 << 2))
+#define CLKCTRL_CHECK_CLK_RESULT                   ((0x0005 << 2))
+#define CLKCTRL_MBIST_ATSPEED_CTRL                 ((0x0006 << 2))
+#define CLKCTRL_LOCK_BIT_REG0                      ((0x0008 << 2))
+#define CLKCTRL_LOCK_BIT_REG1                      ((0x0009 << 2))
+#define CLKCTRL_LOCK_BIT_REG2                      ((0x000a << 2))
+#define CLKCTRL_LOCK_BIT_REG3                      ((0x000b << 2))
+#define CLKCTRL_PROT_BIT_REG0                      ((0x000c << 2))
+#define CLKCTRL_PROT_BIT_REG1                      ((0x000d << 2))
+#define CLKCTRL_PROT_BIT_REG2                      ((0x000e << 2))
+#define CLKCTRL_PROT_BIT_REG3                      ((0x000f << 2))
+#define CLKCTRL_SYS_CLK_CTRL0                      ((0x0010 << 2))
+#define CLKCTRL_SYS_CLK_EN0_REG0                   ((0x0011 << 2))
+#define CLKCTRL_SYS_CLK_EN0_REG1                   ((0x0012 << 2))
+#define CLKCTRL_SYS_CLK_EN0_REG2                   ((0x0013 << 2))
+#define CLKCTRL_SYS_CLK_EN0_REG3                   ((0x0014 << 2))
+#define CLKCTRL_SYS_CLK_EN1_REG0                   ((0x0015 << 2))
+#define CLKCTRL_SYS_CLK_EN1_REG1                   ((0x0016 << 2))
+#define CLKCTRL_SYS_CLK_EN1_REG2                   ((0x0017 << 2))
+#define CLKCTRL_SYS_CLK_EN1_REG3                   ((0x0018 << 2))
+#define CLKCTRL_SYS_CLK_VPU_EN0                    ((0x0019 << 2))
+#define CLKCTRL_SYS_CLK_VPU_EN1                    ((0x001a << 2))
+#define CLKCTRL_AXI_CLK_CTRL0                      ((0x001b << 2))
+#define CLKCTRL_TST_CTRL0                          ((0x0020 << 2))
+#define CLKCTRL_TST_CTRL1                          ((0x0021 << 2))
+#define CLKCTRL_CECA_CTRL0                         ((0x0022 << 2))
+#define CLKCTRL_CECA_CTRL1                         ((0x0023 << 2))
+#define CLKCTRL_CECB_CTRL0                         ((0x0024 << 2))
+#define CLKCTRL_CECB_CTRL1                         ((0x0025 << 2))
+#define CLKCTRL_SC_CLK_CTRL                        ((0x0026 << 2))
+#define CLKCTRL_DSPA_CLK_CTRL0                     ((0x0027 << 2))
+#define CLKCTRL_DSPB_CLK_CTRL0                     ((0x0028 << 2))
+#define CLKCTRL_RAMA_CLK_CTRL0                     ((0x0029 << 2))
+#define CLKCTRL_CLK12_24_CTRL                      ((0x002a << 2))
+#define CLKCTRL_VID_CLK_CTRL                       ((0x0030 << 2))
+#define CLKCTRL_VID_CLK_CTRL2                      ((0x0031 << 2))
+#define CLKCTRL_VID_CLK_DIV                        ((0x0032 << 2))
+#define CLKCTRL_VIID_CLK_DIV                       ((0x0033 << 2))
+#define CLKCTRL_VIID_CLK_CTRL                      ((0x0034 << 2))
+#define CLKCTRL_HDMI_CLK_CTRL                      ((0x0038 << 2))
+#define CLKCTRL_VID_PLL_CLK_DIV                    ((0x0039 << 2))
+#define CLKCTRL_VPU_CLK_CTRL                       ((0x003a << 2))
+#define CLKCTRL_VPU_CLKB_CTRL                      ((0x003b << 2))
+#define CLKCTRL_VPU_CLKC_CTRL                      ((0x003c << 2))
+#define CLKCTRL_VID_LOCK_CLK_CTRL                  ((0x003d << 2))
+#define CLKCTRL_VDIN_MEAS_CLK_CTRL                 ((0x003e << 2))
+#define CLKCTRL_VAPBCLK_CTRL                       ((0x003f << 2))
+#define CLKCTRL_HDCP22_CTRL                        ((0x0040 << 2))
+#define CLKCTRL_MIPIDSI_PHY_CLK_CTRL               ((0x0041 << 2))
+#define CLKCTRL_CDAC_CLK_CTRL                      ((0x0042 << 2))
+#define CLKCTRL_MIPI_CSI_PHY_CLK_CTRL              ((0x0043 << 2))
+#define CLKCTRL_CSI2_ADAPT_CLK_CTRL                ((0x0044 << 2))
+#define CLKCTRL_VDEC_CLK_CTRL                      ((0x0050 << 2))
+#define CLKCTRL_VDEC2_CLK_CTRL                     ((0x0051 << 2))
+#define CLKCTRL_VDEC3_CLK_CTRL                     ((0x0052 << 2))
+#define CLKCTRL_VDEC4_CLK_CTRL                     ((0x0053 << 2))
+#define CLKCTRL_WAVE420L_CLK_CTRL                  ((0x0054 << 2))
+#define CLKCTRL_WAVE420L_CLK_CTRL2                 ((0x0055 << 2))
+#define CLKCTRL_TS_CLK_CTRL                        ((0x0056 << 2))
+#define CLKCTRL_MALI_CLK_CTRL                      ((0x0057 << 2))
+#define CLKCTRL_VIPNANOQ_CLK_CTRL                  ((0x0058 << 2))
+#define CLKCTRL_ETH_CLK_CTRL                       ((0x0059 << 2))
+#define CLKCTRL_NAND_CLK_CTRL                      ((0x005a << 2))
+#define CLKCTRL_SD_EMMC_CLK_CTRL                   ((0x005b << 2))
+#define CLKCTRL_BT656_CLK_CTRL                     ((0x005c << 2))
+#define CLKCTRL_SPICC_CLK_CTRL                     ((0x005d << 2))
+#define CLKCTRL_GEN_CLK_CTRL                       ((0x005e << 2))
+#define CLKCTRL_SAR_CLK_CTRL                       ((0x005f << 2))
+#define CLKCTRL_PWM_CLK_AB_CTRL                    ((0x0060 << 2))
+#define CLKCTRL_PWM_CLK_CD_CTRL                    ((0x0061 << 2))
+#define CLKCTRL_PWM_CLK_EF_CTRL                    ((0x0062 << 2))
+#define CLKCTRL_PWM_CLK_GH_CTRL                    ((0x0063 << 2))
+#define CLKCTRL_PWM_CLK_IJ_CTRL                    ((0x0064 << 2))
+#define CLKCTRL_TIMESTAMP_CTRL                     ((0x0100 << 2))
+#define CLKCTRL_TIMESTAMP_CTRL1                    ((0x0101 << 2))
+#define CLKCTRL_TIMESTAMP_CTRL2                    ((0x0103 << 2))
+#define CLKCTRL_TIMESTAMP_RD0                      ((0x0104 << 2))
+#define CLKCTRL_TIMESTAMP_RD1                      ((0x0105 << 2))
+#define CLKCTRL_TIMEBASE_CTRL0                     ((0x0106 << 2))
+#define CLKCTRL_TIMEBASE_CTRL1                     ((0x0107 << 2))
+#define CLKCTRL_EFUSE_CPU_CFG01                    ((0x0120 << 2))
+#define CLKCTRL_EFUSE_CPU_CFG2                     ((0x0121 << 2))
+#define CLKCTRL_EFUSE_ENCP_CFG0                    ((0x0122 << 2))
+#define CLKCTRL_EFUSE_MALI_CFG01                   ((0x0123 << 2))
+#define CLKCTRL_EFUSE_HEVCB_CFG01                  ((0x0124 << 2))
+#define CLKCTRL_EFUSE_HEVCB_CFG2                   ((0x0125 << 2))
+#define CLKCTRL_EFUSE_LOCK                         ((0x0126 << 2))
+
+/*  ANA_CTRL - Registers
+ *REG_BASE:  REGISTER_BASE_ADDR = 0xfe008000
+ */
+#define ANACTRL_SYSPLL_CTRL0                       ((0x0000 << 2))
+#define ANACTRL_SYSPLL_CTRL1                       ((0x0001 << 2))
+#define ANACTRL_SYSPLL_CTRL2                       ((0x0002 << 2))
+#define ANACTRL_SYSPLL_CTRL3                       ((0x0003 << 2))
+#define ANACTRL_SYSPLL_CTRL4                       ((0x0004 << 2))
+#define ANACTRL_SYSPLL_CTRL5                       ((0x0005 << 2))
+#define ANACTRL_SYSPLL_CTRL6                       ((0x0006 << 2))
+#define ANACTRL_SYSPLL_STS                         ((0x0007 << 2))
+#define ANACTRL_FIXPLL_CTRL0                       ((0x0010 << 2))
+#define ANACTRL_FIXPLL_CTRL1                       ((0x0011 << 2))
+#define ANACTRL_FIXPLL_CTRL2                       ((0x0012 << 2))
+#define ANACTRL_FIXPLL_CTRL3                       ((0x0013 << 2))
+#define ANACTRL_FIXPLL_CTRL4                       ((0x0014 << 2))
+#define ANACTRL_FIXPLL_CTRL5                       ((0x0015 << 2))
+#define ANACTRL_FIXPLL_CTRL6                       ((0x0016 << 2))
+#define ANACTRL_FIXPLL_STS                         ((0x0017 << 2))
+#define ANACTRL_GP0PLL_CTRL0                       ((0x0020 << 2))
+#define ANACTRL_GP0PLL_CTRL1                       ((0x0021 << 2))
+#define ANACTRL_GP0PLL_CTRL2                       ((0x0022 << 2))
+#define ANACTRL_GP0PLL_CTRL3                       ((0x0023 << 2))
+#define ANACTRL_GP0PLL_CTRL4                       ((0x0024 << 2))
+#define ANACTRL_GP0PLL_CTRL5                       ((0x0025 << 2))
+#define ANACTRL_GP0PLL_CTRL6                       ((0x0026 << 2))
+#define ANACTRL_GP0PLL_STS                         ((0x0027 << 2))
+#define ANACTRL_GP1PLL_CTRL0                       ((0x0030 << 2))
+#define ANACTRL_GP1PLL_CTRL1                       ((0x0031 << 2))
+#define ANACTRL_GP1PLL_CTRL2                       ((0x0032 << 2))
+#define ANACTRL_GP1PLL_CTRL3                       ((0x0033 << 2))
+#define ANACTRL_GP1PLL_CTRL4                       ((0x0034 << 2))
+#define ANACTRL_GP1PLL_CTRL5                       ((0x0035 << 2))
+#define ANACTRL_GP1PLL_CTRL6                       ((0x0036 << 2))
+#define ANACTRL_GP1PLL_STS                         ((0x0037 << 2))
+#define ANACTRL_HIFIPLL_CTRL0                      ((0x0040 << 2))
+#define ANACTRL_HIFIPLL_CTRL1                      ((0x0041 << 2))
+#define ANACTRL_HIFIPLL_CTRL2                      ((0x0042 << 2))
+#define ANACTRL_HIFIPLL_CTRL3                      ((0x0043 << 2))
+#define ANACTRL_HIFIPLL_CTRL4                      ((0x0044 << 2))
+#define ANACTRL_HIFIPLL_CTRL5                      ((0x0045 << 2))
+#define ANACTRL_HIFIPLL_CTRL6                      ((0x0046 << 2))
+#define ANACTRL_HIFIPLL_STS                        ((0x0047 << 2))
+#define ANACTRL_PCIEPLL_CTRL0                      ((0x0050 << 2))
+#define ANACTRL_PCIEPLL_CTRL1                      ((0x0051 << 2))
+#define ANACTRL_PCIEPLL_CTRL2                      ((0x0052 << 2))
+#define ANACTRL_PCIEPLL_CTRL3                      ((0x0053 << 2))
+#define ANACTRL_PCIEPLL_CTRL4                      ((0x0054 << 2))
+#define ANACTRL_PCIEPLL_CTRL5                      ((0x0055 << 2))
+#define ANACTRL_PCIEPLL_STS                        ((0x0056 << 2))
+#define ANACTRL_MPLL_CTRL0                         ((0x0060 << 2))
+#define ANACTRL_MPLL_CTRL1                         ((0x0061 << 2))
+#define ANACTRL_MPLL_CTRL2                         ((0x0062 << 2))
+#define ANACTRL_MPLL_CTRL3                         ((0x0063 << 2))
+#define ANACTRL_MPLL_CTRL4                         ((0x0064 << 2))
+#define ANACTRL_MPLL_CTRL5                         ((0x0065 << 2))
+#define ANACTRL_MPLL_CTRL6                         ((0x0066 << 2))
+#define ANACTRL_MPLL_CTRL7                         ((0x0067 << 2))
+#define ANACTRL_MPLL_CTRL8                         ((0x0068 << 2))
+#define ANACTRL_MPLL_STS                           ((0x0069 << 2))
+#define ANACTRL_HDMIPLL_CTRL0                      ((0x0070 << 2))
+#define ANACTRL_HDMIPLL_CTRL1                      ((0x0071 << 2))
+#define ANACTRL_HDMIPLL_CTRL2                      ((0x0072 << 2))
+#define ANACTRL_HDMIPLL_CTRL3                      ((0x0073 << 2))
+#define ANACTRL_HDMIPLL_CTRL4                      ((0x0074 << 2))
+#define ANACTRL_HDMIPLL_CTRL5                      ((0x0075 << 2))
+#define ANACTRL_HDMIPLL_CTRL6                      ((0x0076 << 2))
+#define ANACTRL_HDMIPLL_STS                        ((0x0077 << 2))
+#define ANACTRL_HDMIPLL_VLOCK                      ((0x0079 << 2))
+#define ANACTRL_HDMIPHY_CTRL0                      ((0x0080 << 2))
+#define ANACTRL_HDMIPHY_CTRL1                      ((0x0081 << 2))
+#define ANACTRL_HDMIPHY_CTRL2                      ((0x0082 << 2))
+#define ANACTRL_HDMIPHY_CTRL3                      ((0x0083 << 2))
+#define ANACTRL_HDMIPHY_CTRL4                      ((0x0084 << 2))
+#define ANACTRL_HDMIPHY_CTRL5                      ((0x0085 << 2))
+#define ANACTRL_HDMIPHY_STS                        ((0x0086 << 2))
+#define ANACTRL_MIPICSI_CTRL0                      ((0x0090 << 2))
+#define ANACTRL_MIPICSI_CTRL1                      ((0x0091 << 2))
+#define ANACTRL_MIPICSI_CTRL2                      ((0x0092 << 2))
+#define ANACTRL_MIPICSI_CTRL3                      ((0x0093 << 2))
+#define ANACTRL_MIPICSI_CTRL4                      ((0x0094 << 2))
+#define ANACTRL_MIPICSI_CTRL5                      ((0x0095 << 2))
+#define ANACTRL_MIPIDSI_CTRL0                      ((0x00a0 << 2))
+#define ANACTRL_MIPIDSI_CTRL1                      ((0x00a1 << 2))
+#define ANACTRL_MIPIDSI_CTRL2                      ((0x00a2 << 2))
+#define ANACTRL_MIPIDSI_STS                        ((0x00a3 << 2))
+#define ANACTRL_VDAC_CTRL0                         ((0x00b0 << 2))
+#define ANACTRL_VDAC_CTRL1                         ((0x00b1 << 2))
+#define ANACTRL_POR_CTRL                           ((0x00b6 << 2))
+#define ANACTRL_LOCK_BIT                           ((0x00b8 << 2))
+#define ANACTRL_PROT_BIT                           ((0x00b9 << 2))
+
+/* CPU_CTRL
+ * REG_BASE:  REGISTER_BASE_ADDR = 0xfe00e000
+ */
+#define CPUCTRL_SYS_CPU_RESET_CNTL                 ((0x0050 << 2))
+#define CPUCTRL_SYS_CPU_CLK_CTRL                   ((0x0051 << 2))
+#define CPUCTRL_SYS_CPU_CLK_CTRL1                  ((0x0052 << 2))
+#define CPUCTRL_SYS_CPU_CLK_CTRL2                  ((0x0053 << 2))
+#define CPUCTRL_SYS_CPU_CLK_CTRL3                  ((0x0054 << 2))
+#define CPUCTRL_SYS_CPU_CLK_CTRL4                  ((0x0055 << 2))
+#define CPUCTRL_SYS_CPU_CLK_CTRL5                  ((0x0056 << 2))
+#define CPUCTRL_SYS_CPU_CLK_CTRL6                  ((0x0057 << 2))
+#define CPUCTRL_SYS_CPU_CLK_RESULT                 ((0x0058 << 2))
+
+#if 0
+/*SC2: pll: FDCO: 3G~6G FDCO = 24*(M+frac)/N
+ *N: recommend is 1
+ *clk_out = FDCO >> OD
+ */
+static const struct pll_rate_table sc2_pll_rate_table[] = {
+	PLL_RATE(24000000ULL,  128, 1, 7), /*DCO=3072M*/
+	PLL_RATE(48000000ULL,  128, 1, 6), /*DCO=3072M*/
+	PLL_RATE(96000000ULL,  128, 1, 5), /*DCO=3072M*/
+	PLL_RATE(192000000ULL,  128, 1, 4), /*DCO=3072M*/
+	PLL_RATE(312000000ULL,  208, 1, 4), /*DCO=4992M*/
+	PLL_RATE(408000000ULL,  136, 1, 3), /*DCO=3264M*/
+	PLL_RATE(600000000ULL,  200, 1, 3), /*DCO=4800M*/
+	PLL_RATE(696000000ULL,  232, 1, 3), /*DCO=5568M*/
+	PLL_RATE(792000000ULL,  132, 1, 2), /*DCO=3168M*/
+	PLL_RATE(846000000ULL,  141, 1, 2), /*DCO=3384M*/
+	PLL_RATE(912000000ULL,  152, 1, 2), /*DCO=3648M*/
+	PLL_RATE(1008000000ULL, 168, 1, 2), /*DCO=4032M*/
+	PLL_RATE(1104000000ULL, 184, 1, 2), /*DCO=4416M*/
+	PLL_RATE(1200000000ULL, 200, 1, 2), /*DCO=4800M*/
+	PLL_RATE(1296000000ULL, 216, 1, 2), /*DCO=5184M*/
+	PLL_RATE(1302000000ULL, 217, 1, 2), /*DCO=5208M*/
+	PLL_RATE(1398000000ULL, 233, 1, 2), /*DCO=5592M*/
+	PLL_RATE(1404000000ULL, 234, 1, 2), /*DCO=5616M*/
+	PLL_RATE(1494000000ULL, 249, 1, 2), /*DCO=5976M*/
+	PLL_RATE(1500000000ULL, 125, 1, 1), /*DCO=3000M*/
+	PLL_RATE(1512000000ULL, 126, 1, 1), /*DCO=3024M*/
+	PLL_RATE(1608000000ULL, 134, 1, 1), /*DCO=3216M*/
+	PLL_RATE(1704000000ULL, 142, 1, 1), /*DCO=3408M*/
+	PLL_RATE(1800000000ULL, 150, 1, 1), /*DCO=3600M*/
+	PLL_RATE(1896000000ULL, 158, 1, 1), /*DCO=3792M*/
+	PLL_RATE(1908000000ULL, 159, 1, 1), /*DCO=3816M*/
+	PLL_RATE(1920000000ULL, 160, 1, 1), /*DCO=3840M*/
+	PLL_RATE(2004000000ULL, 167, 1, 1), /*DCO=4008M*/
+	PLL_RATE(2016000000ULL, 168, 1, 1), /*DCO=4032M*/
+	PLL_RATE(2100000000ULL, 175, 1, 1), /*DCO=4200M*/
+	PLL_RATE(2196000000ULL, 183, 1, 1), /*DCO=4392M*/
+	PLL_RATE(2208000000ULL, 184, 1, 1), /*DCO=4416M*/
+	PLL_RATE(2292000000ULL, 191, 1, 1), /*DCO=4584M*/
+	PLL_RATE(2304000000ULL, 192, 1, 1), /*DCO=4608M*/
+	PLL_RATE(2400000000ULL, 200, 1, 1), /*DCO=4800M*/
+	PLL_RATE(2496000000ULL, 208, 1, 1), /*DCO=4992M*/
+	PLL_RATE(2592000000ULL, 216, 1, 1), /*DCO=5184M*/
+	PLL_RATE(2700000000ULL, 225, 1, 1), /*DCO=5400M*/
+	PLL_RATE(2796000000ULL, 233, 1, 1), /*DCO=5592M*/
+	PLL_RATE(2892000000ULL, 241, 1, 1), /*DCO=5784M*/
+	PLL_RATE(3000000000ULL, 125, 1, 0), /*DCO=3000M*/
+	PLL_RATE(3096000000ULL, 129, 1, 0), /*DCO=3096M*/
+	PLL_RATE(3192000000ULL, 133, 1, 0), /*DCO=3192M*/
+	PLL_RATE(3288000000ULL, 137, 1, 0), /*DCO=3288M*/
+	PLL_RATE(3408000000ULL, 142, 1, 0), /*DCO=3408M*/
+	PLL_RATE(3504000000ULL, 146, 1, 0), /*DCO=3504M*/
+	PLL_RATE(3600000000ULL, 150, 1, 0), /*DCO=3600M*/
+	PLL_RATE(3696000000ULL, 154, 1, 0), /*DCO=3696M*/
+	PLL_RATE(3792000000ULL, 158, 1, 0), /*DCO=3792M*/
+	PLL_RATE(3888000000ULL, 162, 1, 0), /*DCO=3888M*/
+	PLL_RATE(4008000000ULL, 167, 1, 0), /*DCO=4008M*/
+	PLL_RATE(4104000000ULL, 171, 1, 0), /*DCO=4104M*/
+	PLL_RATE(4200000000ULL, 175, 1, 0), /*DCO=4200M*/
+	PLL_RATE(4296000000ULL, 179, 1, 0), /*DCO=4296M*/
+	PLL_RATE(4392000000ULL, 183, 1, 0), /*DCO=4392M*/
+	PLL_RATE(4488000000ULL, 187, 1, 0), /*DCO=4488M*/
+	PLL_RATE(4608000000ULL, 192, 1, 0), /*DCO=4608M*/
+	PLL_RATE(4704000000ULL, 196, 1, 0), /*DCO=4704M*/
+	PLL_RATE(4800000000ULL, 200, 1, 0), /*DCO=4800M*/
+	PLL_RATE(4896000000ULL, 204, 1, 0), /*DCO=4896M*/
+	PLL_RATE(4992000000ULL, 208, 1, 0), /*DCO=4992M*/
+	PLL_RATE(5088000000ULL, 212, 1, 0), /*DCO=5088M*/
+	PLL_RATE(5208000000ULL, 217, 1, 0), /*DCO=5208M*/
+	PLL_RATE(5304000000ULL, 221, 1, 0), /*DCO=5304M*/
+	PLL_RATE(5400000000ULL, 225, 1, 0), /*DCO=5400M*/
+	PLL_RATE(5496000000ULL, 229, 1, 0), /*DCO=5496M*/
+	PLL_RATE(5592000000ULL, 233, 1, 0), /*DCO=5592M*/
+	PLL_RATE(5688000000ULL, 237, 1, 0), /*DCO=5688M*/
+	PLL_RATE(5808000000ULL, 242, 1, 0), /*DCO=5808M*/
+	PLL_RATE(5904000000ULL, 246, 1, 0), /*DCO=5904M*/
+	PLL_RATE(6000000000ULL, 250, 1, 0), /*DCO=6000M*/
+
+	{ /* sentinel */ }
+};
+
+/*fix pll rate table*/
+static const struct fclk_rate_table fclk_pll_rate_table[] = {
+	FCLK_PLL_RATE(50000000, 1, 1, 19),
+	FCLK_PLL_RATE(100000000, 1, 1, 9),
+	FCLK_PLL_RATE(167000000, 2, 1, 3),
+	FCLK_PLL_RATE(200000000, 1, 1, 4),
+	FCLK_PLL_RATE(250000000, 1, 1, 3),
+	FCLK_PLL_RATE(333000000, 2, 1, 1),
+	FCLK_PLL_RATE(500000000, 1, 1, 1),
+	FCLK_PLL_RATE(667000000, 2, 0, 0),
+	FCLK_PLL_RATE(1000000000, 1, 0, 0)
+};
+
+/*PCIE clk_out = 24M*m/2/2/OD*/
+static const struct pll_rate_table sc2_pcie_pll_rate_table[] = {
+	PLL_RATE(100000000, 150, 0, 9),
+	{ /* sentinel */ }
+};
+
+static const struct pll_rate_table sc2_hifi_pll_rate_table[] = {
+	PLL_RATE(666000000ULL,	222, 1, 3), /*DCO=5328M*/
+	PLL_FRAC_RATE(1806336000ULL, 150, 1, 1, 0, 0x00010E56),
+	{ /* sentinel */ }
+};
+
+/* include the CLKIDs that have been made part of the DT binding */
+#endif
+
+#endif /* __SC2_H */
diff --git a/drivers/clk/meson/sc2_clk_regmap.c b/drivers/clk/meson/sc2_clk_regmap.c
new file mode 100644
index 000000000..b6ba1a98e
--- /dev/null
+++ b/drivers/clk/meson/sc2_clk_regmap.c
@@ -0,0 +1,236 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 AMLOGIC.
+ */
+
+#include <linux/module.h>
+#include <linux/arm-smccc.h>
+#include "clk-regmap.h"
+#include "clk-cpu-dyndiv.h"
+#include "clk-secure.h"
+
+static unsigned long clk_regmap_secure_div_recalc_rate(struct clk_hw *hw,
+						       unsigned long prate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
+	struct arm_smccc_res res;
+	unsigned int val;
+
+	if (!strcmp(clk_hw_get_name(hw), "cpu_clk_dyn1_div"))
+		arm_smccc_smc(CPUCLK_SECURE_RW, CLK_CPU_REG_RW,
+			      0, 0, 0, 0, 0, 0, &res);
+	else
+		arm_smccc_smc(CPUCLK_SECURE_RW, CLK_DSU_REG_RW,
+			      0, 0, 0, 0, 0, 0, &res);
+	val = res.a0;
+
+	val >>= div->shift;
+	val &= clk_div_mask(div->width);
+	return divider_recalc_rate(hw, prate, val, div->table, div->flags,
+				   div->width);
+}
+
+static long clk_regmap_secure_div_round_rate(struct clk_hw *hw, unsigned long rate,
+					     unsigned long *prate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
+	struct arm_smccc_res res;
+	unsigned int val;
+
+	/* if read only, just return current value */
+	if (div->flags & CLK_DIVIDER_READ_ONLY) {
+		if (!strcmp(clk_hw_get_name(hw), "cpu_clk_dyn1_div"))
+			arm_smccc_smc(CPUCLK_SECURE_RW, CLK_CPU_REG_RW,
+				      0, 0, 0, 0, 0, 0, &res);
+		else
+			arm_smccc_smc(CPUCLK_SECURE_RW, CLK_DSU_REG_RW,
+				      0, 0, 0, 0, 0, 0, &res);
+		val = res.a0;
+
+		val >>= div->shift;
+		val &= clk_div_mask(div->width);
+
+		return divider_ro_round_rate(hw, rate, prate, div->table,
+					     div->width, div->flags, val);
+	}
+
+	return divider_round_rate(hw, rate, prate, div->table, div->width,
+				  div->flags);
+}
+
+static int clk_regmap_secure_div_set_rate(struct clk_hw *hw, unsigned long rate,
+					  unsigned long parent_rate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
+	struct arm_smccc_res res;
+	int ret;
+
+	ret = divider_get_val(rate, parent_rate, div->table, div->width,
+			      div->flags);
+	if (ret < 0)
+		return ret;
+
+	if (!strcmp(clk_hw_get_name(hw), "cpu_clk_dyn1_div"))
+		arm_smccc_smc(CPUCLK_SECURE_RW, CPU_DIVIDER_SET_RATE, ret,
+			      div->width, div->shift, 0, 0, 0, &res);
+	else
+		arm_smccc_smc(CPUCLK_SECURE_RW, DSU_DIVIDER_SET_RATE, ret,
+			      div->width, div->shift, 0, 0, 0, &res);
+	return 0;
+};
+
+/* Would prefer clk_regmap_div_ro_ops but clashes with qcom */
+
+const struct clk_ops meson_clk_regmap_secure_divider_ops = {
+	.recalc_rate = clk_regmap_secure_div_recalc_rate,
+	.round_rate = clk_regmap_secure_div_round_rate,
+	.set_rate = clk_regmap_secure_div_set_rate,
+};
+
+const struct clk_ops meson_clk_regmap_secure_divider_ro_ops = {
+	.recalc_rate = clk_regmap_secure_div_recalc_rate,
+	.round_rate = clk_regmap_secure_div_round_rate,
+};
+
+static u8 clk_regmap_secure_mux_get_parent(struct clk_hw *hw)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
+	struct arm_smccc_res res;
+	unsigned int val;
+
+	if (!strcmp(clk_hw_get_name(hw), "cpu_clk_dyn0_sel") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk_dyn1_sel") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk_dyn0") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk_dyn1") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk_dyn") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk"))
+		arm_smccc_smc(CPUCLK_SECURE_RW, CLK_CPU_REG_RW,
+			      0, 0, 0, 0, 0, 0, &res);
+	else if (!strcmp(clk_hw_get_name(hw), "cpu1_clk") ||
+		 !strcmp(clk_hw_get_name(hw), "cpu2_clk") ||
+		 !strcmp(clk_hw_get_name(hw), "cpu3_clk") ||
+		 !strcmp(clk_hw_get_name(hw), "dsu_clk"))
+		arm_smccc_smc(CPUCLK_SECURE_RW, CLK_CPU_DSU_REG_RW,
+			      0, 0, 0, 0, 0, 0, &res);
+	else
+		arm_smccc_smc(CPUCLK_SECURE_RW, CLK_DSU_REG_RW,
+			      0, 0, 0, 0, 0, 0, &res);
+
+	val = res.a0;
+	val >>= mux->shift;
+	val &= mux->mask;
+	return clk_mux_val_to_index(hw, mux->table, mux->flags, val);
+}
+
+static int clk_regmap__secure_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
+	unsigned int val = clk_mux_index_to_val(mux->table, mux->flags, index);
+	struct arm_smccc_res res;
+
+	if (!strcmp(clk_hw_get_name(hw), "cpu_clk_dyn0_sel") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk_dyn1_sel") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk_dyn0") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk_dyn1") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk_dyn") ||
+	    !strcmp(clk_hw_get_name(hw), "cpu_clk"))
+		arm_smccc_smc(CPUCLK_SECURE_RW, SET_CPU0_MUX_PARENT,
+			      val, mux->mask, mux->shift, 0, 0, 0, &res);
+	else if (!strcmp(clk_hw_get_name(hw), "cpu1_clk") ||
+		 !strcmp(clk_hw_get_name(hw), "cpu2_clk") ||
+		 !strcmp(clk_hw_get_name(hw), "cpu3_clk") ||
+		 !strcmp(clk_hw_get_name(hw), "dsu_clk"))
+		arm_smccc_smc(CPUCLK_SECURE_RW, SET_CPU123_DSU_MUX_PARENT,
+			      val, mux->mask, mux->shift, 0, 0, 0, &res);
+	else
+		arm_smccc_smc(CPUCLK_SECURE_RW, SET_DSU_PRE_MUX_PARENT,
+			      val, mux->mask, mux->shift, 0, 0, 0, &res);
+
+	return 0;
+}
+
+static int clk_regmap_secure_mux_determine_rate(struct clk_hw *hw,
+						struct clk_rate_request *req)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
+
+	return clk_mux_determine_rate_flags(hw, req, mux->flags);
+}
+
+const struct clk_ops meson_clk_regmap_secure_mux_ops = {
+	.get_parent = clk_regmap_secure_mux_get_parent,
+	.set_parent = clk_regmap__secure_mux_set_parent,
+	.determine_rate = clk_regmap_secure_mux_determine_rate,
+};
+
+const struct clk_ops meson_clk_regmap_secure_mux_ro_ops = {
+	.get_parent = clk_regmap_secure_mux_get_parent,
+};
+
+static struct meson_clk_cpu_dyndiv_data *
+meson_clk_cpu_dyndiv_data(struct clk_regmap *clk)
+{
+	return (struct meson_clk_cpu_dyndiv_data *)clk->data;
+}
+
+static unsigned long
+meson_secure_clk_cpu_dyndiv_recalc_rate(struct clk_hw *hw,
+					unsigned long prate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct meson_clk_cpu_dyndiv_data *data = meson_clk_cpu_dyndiv_data(clk);
+	struct arm_smccc_res res;
+	unsigned int val;
+
+	arm_smccc_smc(CPUCLK_SECURE_RW, CLK_CPU_REG_RW,
+		      0, 0, 0, 0, 0, 0, &res);
+	val = res.a0;
+
+	val >>= data->div.shift;
+	val &= clk_div_mask(data->div.width);
+	return divider_recalc_rate(hw, prate, val,
+				   NULL, 0, data->div.width);
+}
+
+static long meson_secure_clk_cpu_dyndiv_round_rate(struct clk_hw *hw,
+						   unsigned long rate,
+						   unsigned long *prate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct meson_clk_cpu_dyndiv_data *data = meson_clk_cpu_dyndiv_data(clk);
+
+	return divider_round_rate(hw, rate, prate, NULL, data->div.width, 0);
+}
+
+static int meson_secure_clk_cpu_dyndiv_set_rate(struct clk_hw *hw,
+						unsigned long rate,
+						unsigned long parent_rate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct meson_clk_cpu_dyndiv_data *data = meson_clk_cpu_dyndiv_data(clk);
+	struct arm_smccc_res res;
+	int ret;
+
+	ret = divider_get_val(rate, parent_rate, NULL, data->div.width, 0);
+	if (ret < 0)
+		return ret;
+
+	arm_smccc_smc(CPUCLK_SECURE_RW, CPU_DIVIDER_SET_RATE, ret,
+		      data->div.width, data->div.shift, 0, 0, 0, &res);
+	return 0;
+};
+
+const struct clk_ops meson_secure_clk_cpu_dyndiv_ops = {
+	.recalc_rate = meson_secure_clk_cpu_dyndiv_recalc_rate,
+	.round_rate = meson_secure_clk_cpu_dyndiv_round_rate,
+	.set_rate = meson_secure_clk_cpu_dyndiv_set_rate,
+};
+
+MODULE_DESCRIPTION("Amlogic regmap backed clock driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/dt-bindings/clock/amlogic,sc2-clkc.h b/include/dt-bindings/clock/amlogic,sc2-clkc.h
new file mode 100644
index 000000000..bab3de845
--- /dev/null
+++ b/include/dt-bindings/clock/amlogic,sc2-clkc.h
@@ -0,0 +1,365 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __SC2_CLKC_H
+#define __SC2_CLKC_H
+
+/*
+ * CLKID index values
+ */
+
+#define CLKID_PLL_BASE			0
+#define CLKID_FIXED_PLL_DCO		(CLKID_PLL_BASE + 0)
+#define CLKID_FIXED_PLL			(CLKID_PLL_BASE + 1)
+#define CLKID_SYS_PLL_DCO		(CLKID_PLL_BASE + 2)
+#define CLKID_SYS_PLL			(CLKID_PLL_BASE + 3)
+#define CLKID_FCLK_DIV2_DIV		(CLKID_PLL_BASE + 4)
+#define CLKID_FCLK_DIV2			(CLKID_PLL_BASE + 5)
+#define CLKID_FCLK_DIV3_DIV		(CLKID_PLL_BASE + 6)
+#define CLKID_FCLK_DIV3			(CLKID_PLL_BASE + 7)
+#define CLKID_FCLK_DIV4_DIV		(CLKID_PLL_BASE + 8)
+#define CLKID_FCLK_DIV4			(CLKID_PLL_BASE + 9)
+#define CLKID_FCLK_DIV5_DIV		(CLKID_PLL_BASE + 10)
+#define CLKID_FCLK_DIV5			(CLKID_PLL_BASE + 11)
+#define CLKID_FCLK_DIV7_DIV		(CLKID_PLL_BASE + 12)
+#define CLKID_FCLK_DIV7			(CLKID_PLL_BASE + 13)
+#define CLKID_FCLK_DIV2P5_DIV		(CLKID_PLL_BASE + 14)
+#define CLKID_FCLK_DIV2P5		(CLKID_PLL_BASE + 15)
+#define CLKID_GP0_PLL_DCO		(CLKID_PLL_BASE + 16)
+#define CLKID_GP0_PLL			(CLKID_PLL_BASE + 17)
+#define CLKID_GP1_PLL_DCO		(CLKID_PLL_BASE + 18)
+#define CLKID_GP1_PLL			(CLKID_PLL_BASE + 19)
+
+#define CLKID_CPU_BASE			(CLKID_PLL_BASE  + 20)
+#define CLKID_CPU_CLK_DYN0_SEL		(CLKID_CPU_BASE + 0)
+#define CLKID_CPU_CLK_DYN0_DIV		(CLKID_CPU_BASE + 1)
+#define CLKID_CPU_CLK_DYN0		(CLKID_CPU_BASE + 2)
+#define CLKID_CPU_CLK_DYN1_SEL		(CLKID_CPU_BASE + 3)
+#define CLKID_CPU_CLK_DYN1_DIV		(CLKID_CPU_BASE + 4)
+#define CLKID_CPU_CLK_DYN1		(CLKID_CPU_BASE + 5)
+#define CLKID_CPU_CLK_DYN		(CLKID_CPU_BASE + 6)
+#define CLKID_CPU_CLK			(CLKID_CPU_BASE + 7)
+#define CLKID_DSU_CLK_DYN0_SEL		(CLKID_CPU_BASE + 8)
+#define CLKID_DSU_CLK_DYN0_DIV		(CLKID_CPU_BASE + 9)
+#define CLKID_DSU_CLK_DYN0		(CLKID_CPU_BASE + 10)
+#define CLKID_DSU_CLK_DYN1_SEL		(CLKID_CPU_BASE + 11)
+#define CLKID_DSU_CLK_DYN1_DIV		(CLKID_CPU_BASE + 12)
+#define CLKID_DSU_CLK_DYN1		(CLKID_CPU_BASE + 13)
+#define CLKID_DSU_CLK_DYN		(CLKID_CPU_BASE + 14)
+#define CLKID_DSU_CLK_FINAL		(CLKID_CPU_BASE + 15)
+#define CLKID_DSU_CLK			(CLKID_CPU_BASE + 16)
+#define CLKID_CPU1_CLK			(CLKID_CPU_BASE + 17)
+#define CLKID_CPU2_CLK			(CLKID_CPU_BASE + 18)
+#define CLKID_CPU3_CLK			(CLKID_CPU_BASE + 19)
+
+#define CLKID_PLL1_BASE			(CLKID_CPU_BASE + 20)
+#define CLKID_HIFI_PLL_DCO		(CLKID_PLL1_BASE + 0)
+#define CLKID_HIFI_PLL			(CLKID_PLL1_BASE + 1)
+#define CLKID_PCIE_PLL_DCO		(CLKID_PLL1_BASE + 2)
+#define CLKID_PCIE_PLL_DCO_DIV2		(CLKID_PLL1_BASE + 3)
+#define CLKID_PCIE_PLL_OD		(CLKID_PLL1_BASE + 4)
+#define CLKID_PCIE_PLL			(CLKID_PLL1_BASE + 5)
+#define CLKID_HDMI_PLL_DCO		(CLKID_PLL1_BASE + 6)
+#define CLKID_HDMI_PLL_OD		(CLKID_PLL1_BASE + 7)
+#define CLKID_HDMI_PLL			(CLKID_PLL1_BASE + 8)
+#define CLKID_MPLL_50M_DIV		(CLKID_PLL1_BASE + 9)
+#define CLKID_MPLL_50M			(CLKID_PLL1_BASE + 10)
+#define CLKID_MPLL_PREDIV		(CLKID_PLL1_BASE + 11)
+#define CLKID_MPLL0_DIV			(CLKID_PLL1_BASE + 12)
+#define CLKID_MPLL0			(CLKID_PLL1_BASE + 13)
+#define CLKID_MPLL1_DIV			(CLKID_PLL1_BASE + 14)
+#define CLKID_MPLL1			(CLKID_PLL1_BASE + 15)
+#define CLKID_MPLL2_DIV			(CLKID_PLL1_BASE + 16)
+#define CLKID_MPLL2			(CLKID_PLL1_BASE + 17)
+#define CLKID_MPLL3_DIV			(CLKID_PLL1_BASE + 18)
+#define CLKID_MPLL3			(CLKID_PLL1_BASE + 19)
+#define CLKID_PCIE_BGP			(CLKID_PLL1_BASE + 20)
+#define CLKID_PCIE_HCSL			(CLKID_PLL1_BASE + 21)
+
+#define CLKID_BASE			(CLKID_PLL1_BASE + 22)
+#define CLKID_RTC_32K_CLKIN		(CLKID_BASE + 0)
+#define CLKID_RTC_32K_DIV		(CLKID_BASE + 1)
+#define CLKID_RTC_32K_XATL		(CLKID_BASE + 2)
+#define CLKID_RTC_32K_MUX		(CLKID_BASE + 3)
+#define CLKID_RTC_CLK			(CLKID_BASE + 4)
+#define CLKID_SYS_CLK_B_MUX		(CLKID_BASE + 5)
+#define CLKID_SYS_CLK_B_DIV		(CLKID_BASE + 6)
+#define CLKID_SYS_CLK_B_GATE		(CLKID_BASE + 7)
+#define CLKID_SYS_CLK_A_MUX		(CLKID_BASE + 8)
+#define CLKID_SYS_CLK_A_DIV		(CLKID_BASE + 9)
+#define CLKID_SYS_CLK_A_GATE		(CLKID_BASE + 10)
+#define CLKID_SYS_CLK			(CLKID_BASE + 11)
+
+#define CLKID_CECA_32K_CLKIN		(CLKID_BASE + 12)
+#define CLKID_CECA_32K_DIV		(CLKID_BASE + 13)
+#define CLKID_CECA_32K_MUX_PRE		(CLKID_BASE + 14)
+#define CLKID_CECA_32K_MUX		(CLKID_BASE + 15)
+#define CLKID_CECA_32K_CLKOUT		(CLKID_BASE + 16)
+#define CLKID_CECB_32K_CLKIN		(CLKID_BASE + 17)
+#define CLKID_CECB_32K_DIV		(CLKID_BASE + 18)
+#define CLKID_CECB_32K_MUX_PRE		(CLKID_BASE + 19)
+#define CLKID_CECB_32K_MUX		(CLKID_BASE + 20)
+#define CLKID_CECB_32K_CLKOUT		(CLKID_BASE + 21)
+
+#define CLKID_SC_CLK_MUX		(CLKID_BASE + 22)
+#define CLKID_SC_CLK_DIV		(CLKID_BASE + 23)
+#define CLKID_SC_CLK_GATE		(CLKID_BASE + 24)
+
+#define CLKID_DSPA_CLK_B_MUX		(CLKID_BASE + 25)
+#define CLKID_DSPA_CLK_B_DIV		(CLKID_BASE + 26)
+#define CLKID_DSPA_CLK_B_GATE		(CLKID_BASE + 27)
+#define CLKID_DSPA_CLK_A_MUX		(CLKID_BASE + 28)
+#define CLKID_DSPA_CLK_A_DIV		(CLKID_BASE + 29)
+#define CLKID_DSPA_CLK_A_GATE		(CLKID_BASE + 30)
+#define CLKID_DSPA_CLK			(CLKID_BASE + 31)
+
+#define CLKID_24M_CLK_GATE		(CLKID_BASE + 32)
+#define CLKID_12M_CLK_DIV		(CLKID_BASE + 33)
+#define CLKID_12M_CLK_GATE		(CLKID_BASE + 34)
+#define CLKID_25M_CLK_DIV		(CLKID_BASE + 35)
+#define CLKID_25M_CLK_GATE		(CLKID_BASE + 36)
+
+#define CLKID_VID_PLL_DIV		(CLKID_BASE + 37)
+#define CLKID_VID_PLL_MUX		(CLKID_BASE + 38)
+#define CLKID_VID_PLL			(CLKID_BASE + 39)
+#define CLKID_VCLK_MUX			(CLKID_BASE + 40)
+#define CLKID_VCLK2_MUX			(CLKID_BASE + 41)
+#define CLKID_VCLK_INPUT		(CLKID_BASE + 42)
+#define CLKID_VCLK2_INPUT		(CLKID_BASE + 43)
+#define CLKID_VCLK_DIV			(CLKID_BASE + 44)
+#define CLKID_VCLK2_DIV			(CLKID_BASE + 45)
+#define CLKID_VCLK			(CLKID_BASE + 46)
+#define CLKID_VCLK2			(CLKID_BASE + 47)
+#define CLKID_VCLK_DIV1			(CLKID_BASE + 48)
+#define CLKID_VCLK_DIV2_EN		(CLKID_BASE + 49)
+#define CLKID_VCLK_DIV4_EN		(CLKID_BASE + 50)
+#define CLKID_VCLK_DIV6_EN		(CLKID_BASE + 51)
+#define CLKID_VCLK_DIV12_EN		(CLKID_BASE + 52)
+#define CLKID_VCLK2_DIV1		(CLKID_BASE + 53)
+#define CLKID_VCLK2_DIV2_EN		(CLKID_BASE + 54)
+#define CLKID_VCLK2_DIV4_EN		(CLKID_BASE + 55)
+#define CLKID_VCLK2_DIV6_EN		(CLKID_BASE + 56)
+#define CLKID_VCLK2_DIV12_EN		(CLKID_BASE + 57)
+#define CLKID_VCLK_DIV2			(CLKID_BASE + 58)
+#define CLKID_VCLK_DIV4			(CLKID_BASE + 59)
+#define CLKID_VCLK_DIV6			(CLKID_BASE + 60)
+#define CLKID_VCLK_DIV12		(CLKID_BASE + 61)
+#define CLKID_VCLK2_DIV2		(CLKID_BASE + 62)
+#define CLKID_VCLK2_DIV4		(CLKID_BASE + 63)
+#define CLKID_VCLK2_DIV6		(CLKID_BASE + 64)
+#define CLKID_VCLK2_DIV12		(CLKID_BASE + 65)
+#define CLKID_CTS_ENCI_MUX		(CLKID_BASE + 66)
+#define CLKID_CTS_ENCP_MUX		(CLKID_BASE + 67)
+#define CLKID_CTS_VDAC_MUX		(CLKID_BASE + 68)
+#define CLKID_HDMI_TX_MUX		(CLKID_BASE + 69)
+#define CLKID_CTS_ENCI			(CLKID_BASE + 70)
+#define CLKID_CTS_ENCP			(CLKID_BASE + 71)
+#define CLKID_CTS_VDAC			(CLKID_BASE + 72)
+#define CLKID_HDMI_TX			(CLKID_BASE + 73)
+
+#define CLKID_HDMI_MUX			(CLKID_BASE + 74)
+#define CLKID_HDMI_DIV			(CLKID_BASE + 75)
+#define CLKID_HDMI			(CLKID_BASE + 76)
+#define CLKID_TS_CLK_DIV		(CLKID_BASE + 77)
+#define CLKID_TS_CLK_GATE		(CLKID_BASE + 78)
+
+#define CLKID_MALI_0_SEL		(CLKID_BASE + 79)
+#define CLKID_MALI_0_DIV		(CLKID_BASE + 80)
+#define CLKID_MALI_0			(CLKID_BASE + 81)
+#define CLKID_MALI_1_SEL		(CLKID_BASE + 82)
+#define CLKID_MALI_1_DIV		(CLKID_BASE + 83)
+#define CLKID_MALI_1			(CLKID_BASE + 84)
+#define CLKID_MALI			(CLKID_BASE + 85)
+
+#define CLKID_VDEC_P0_MUX		(CLKID_BASE + 86)
+#define CLKID_VDEC_P0_DIV		(CLKID_BASE + 87)
+#define CLKID_VDEC_P0			(CLKID_BASE + 88)
+#define CLKID_VDEC_P1_MUX		(CLKID_BASE + 89)
+#define CLKID_VDEC_P1_DIV		(CLKID_BASE + 90)
+#define CLKID_VDEC_P1			(CLKID_BASE + 91)
+#define CLKID_VDEC_MUX			(CLKID_BASE + 92)
+
+#define CLKID_HCODEC_P0_MUX		(CLKID_BASE + 93)
+#define CLKID_HCODEC_P0_DIV		(CLKID_BASE + 94)
+#define CLKID_HCODEC_P0			(CLKID_BASE + 95)
+#define CLKID_HCODEC_P1_MUX		(CLKID_BASE + 96)
+#define CLKID_HCODEC_P1_DIV		(CLKID_BASE + 97)
+#define CLKID_HCODEC_P1			(CLKID_BASE + 98)
+#define CLKID_HCODEC_MUX		(CLKID_BASE + 99)
+
+#define CLKID_HEVCB_P0_MUX		(CLKID_BASE + 100)
+#define CLKID_HEVCB_P0_DIV		(CLKID_BASE + 101)
+#define CLKID_HEVCB_P0			(CLKID_BASE + 102)
+#define CLKID_HEVCB_P1_MUX		(CLKID_BASE + 103)
+#define CLKID_HEVCB_P1_DIV		(CLKID_BASE + 104)
+#define CLKID_HEVCB_P1			(CLKID_BASE + 105)
+#define CLKID_HEVCB_MUX			(CLKID_BASE + 106)
+
+#define CLKID_HEVCF_P0_MUX		(CLKID_BASE + 107)
+#define CLKID_HEVCF_P0_DIV		(CLKID_BASE + 108)
+#define CLKID_HEVCF_P0			(CLKID_BASE + 109)
+#define CLKID_HEVCF_P1_MUX		(CLKID_BASE + 110)
+#define CLKID_HEVCF_P1_DIV		(CLKID_BASE + 111)
+#define CLKID_HEVCF_P1			(CLKID_BASE + 112)
+#define CLKID_HEVCF_MUX			(CLKID_BASE + 113)
+
+#define CLKID_WAVE_A_MUX		(CLKID_BASE + 114)
+#define CLKID_WAVE_A_DIV		(CLKID_BASE + 115)
+#define CLKID_WAVE_A_GATE		(CLKID_BASE + 116)
+#define CLKID_WAVE_B_MUX		(CLKID_BASE + 117)
+#define CLKID_WAVE_B_DIV		(CLKID_BASE + 118)
+#define CLKID_WAVE_B_GATE		(CLKID_BASE + 119)
+#define CLKID_WAVE_C_MUX		(CLKID_BASE + 120)
+#define CLKID_WAVE_C_DIV		(CLKID_BASE + 121)
+#define CLKID_WAVE_C_GATE		(CLKID_BASE + 122)
+
+#define CLKID_VPU_0_MUX			(CLKID_BASE + 123)
+#define CLKID_VPU_0_DIV			(CLKID_BASE + 124)
+#define CLKID_VPU_0			(CLKID_BASE + 125)
+#define CLKID_VPU_1_MUX			(CLKID_BASE + 126)
+#define CLKID_VPU_1_DIV			(CLKID_BASE + 127)
+#define CLKID_VPU_1			(CLKID_BASE + 128)
+#define CLKID_VPU			(CLKID_BASE + 129)
+
+#define CLKID_VPU_CLKB_TMP_MUX		(CLKID_BASE + 130)
+#define CLKID_VPU_CLKB_TMP_DIV		(CLKID_BASE + 131)
+#define CLKID_VPU_CLKB_TMP		(CLKID_BASE + 132)
+#define CLKID_VPU_CLKB_DIV		(CLKID_BASE + 133)
+#define CLKID_VPU_CLKB			(CLKID_BASE + 134)
+
+#define CLKID_VPU_CLKC_P0_MUX		(CLKID_BASE + 135)
+#define CLKID_VPU_CLKC_P0_DIV		(CLKID_BASE + 136)
+#define CLKID_VPU_CLKC_P0		(CLKID_BASE + 137)
+#define CLKID_VPU_CLKC_P1_MUX		(CLKID_BASE + 138)
+#define CLKID_VPU_CLKC_P1_DIV		(CLKID_BASE + 139)
+#define CLKID_VPU_CLKC_P1		(CLKID_BASE + 140)
+#define CLKID_VPU_CLKC_MUX		(CLKID_BASE + 141)
+
+#define CLKID_VAPB_0_MUX		(CLKID_BASE + 142)
+#define CLKID_VAPB_0_DIV		(CLKID_BASE + 143)
+#define CLKID_VAPB_0			(CLKID_BASE + 144)
+#define CLKID_VAPB_1_MUX		(CLKID_BASE + 145)
+#define CLKID_VAPB_1_DIV		(CLKID_BASE + 146)
+#define CLKID_VAPB_1			(CLKID_BASE + 147)
+#define CLKID_VAPB			(CLKID_BASE + 148)
+
+#define CLKID_GE2D			(CLKID_BASE + 149)
+
+#define CLKID_VDIN_MEAS_MUX		(CLKID_BASE + 150)
+#define CLKID_VDIN_MEAS_DIV		(CLKID_BASE + 151)
+#define CLKID_VDIN_MEAS_GATE		(CLKID_BASE + 152)
+
+#define CLKID_SD_EMMC_C_CLK_MUX		(CLKID_BASE + 153)
+#define CLKID_SD_EMMC_C_CLK_DIV		(CLKID_BASE + 154)
+#define CLKID_SD_EMMC_C_CLK		(CLKID_BASE + 155)
+#define CLKID_SD_EMMC_A_CLK_MUX		(CLKID_BASE + 156)
+#define CLKID_SD_EMMC_A_CLK_DIV		(CLKID_BASE + 157)
+#define CLKID_SD_EMMC_A_CLK		(CLKID_BASE + 158)
+#define CLKID_SD_EMMC_B_CLK_MUX		(CLKID_BASE + 159)
+#define CLKID_SD_EMMC_B_CLK_DIV		(CLKID_BASE + 160)
+#define CLKID_SD_EMMC_B_CLK		(CLKID_BASE + 161)
+
+#define CLKID_SPICC0_MUX		(CLKID_BASE + 162)
+#define CLKID_SPICC0_DIV		(CLKID_BASE + 163)
+#define CLKID_SPICC0_GATE		(CLKID_BASE + 164)
+#define CLKID_SPICC1_MUX		(CLKID_BASE + 165)
+#define CLKID_SPICC1_DIV		(CLKID_BASE + 166)
+#define CLKID_SPICC1_GATE		(CLKID_BASE + 167)
+
+#define CLKID_PWM_A_MUX			(CLKID_BASE + 168)
+#define CLKID_PWM_A_DIV			(CLKID_BASE + 169)
+#define CLKID_PWM_A_GATE		(CLKID_BASE + 170)
+#define CLKID_PWM_B_MUX			(CLKID_BASE + 171)
+#define CLKID_PWM_B_DIV			(CLKID_BASE + 172)
+#define CLKID_PWM_B_GATE		(CLKID_BASE + 173)
+#define CLKID_PWM_C_MUX			(CLKID_BASE + 174)
+#define CLKID_PWM_C_DIV			(CLKID_BASE + 175)
+#define CLKID_PWM_C_GATE		(CLKID_BASE + 176)
+#define CLKID_PWM_D_MUX			(CLKID_BASE + 177)
+#define CLKID_PWM_D_DIV			(CLKID_BASE + 178)
+#define CLKID_PWM_D_GATE		(CLKID_BASE + 179)
+#define CLKID_PWM_E_MUX			(CLKID_BASE + 180)
+#define CLKID_PWM_E_DIV			(CLKID_BASE + 181)
+#define CLKID_PWM_E_GATE		(CLKID_BASE + 182)
+#define CLKID_PWM_F_MUX			(CLKID_BASE + 183)
+#define CLKID_PWM_F_DIV			(CLKID_BASE + 184)
+#define CLKID_PWM_F_GATE		(CLKID_BASE + 185)
+#define CLKID_PWM_G_MUX			(CLKID_BASE + 186)
+#define CLKID_PWM_G_DIV			(CLKID_BASE + 187)
+#define CLKID_PWM_G_GATE		(CLKID_BASE + 188)
+#define CLKID_PWM_H_MUX			(CLKID_BASE + 189)
+#define CLKID_PWM_H_DIV			(CLKID_BASE + 190)
+#define CLKID_PWM_H_GATE		(CLKID_BASE + 191)
+#define CLKID_PWM_I_MUX			(CLKID_BASE + 192)
+#define CLKID_PWM_I_DIV			(CLKID_BASE + 193)
+#define CLKID_PWM_I_GATE		(CLKID_BASE + 194)
+#define CLKID_PWM_J_MUX			(CLKID_BASE + 195)
+#define CLKID_PWM_J_DIV			(CLKID_BASE + 196)
+#define CLKID_PWM_J_GATE		(CLKID_BASE + 197)
+
+#define CLKID_SARADC_MUX		(CLKID_BASE + 198)
+#define CLKID_SARADC_DIV		(CLKID_BASE + 199)
+#define CLKID_SARADC_GATE		(CLKID_BASE + 200)
+#define CLKID_GEN_MUX			(CLKID_BASE + 201)
+#define CLKID_GEN_DIV			(CLKID_BASE + 202)
+#define CLKID_GEN_GATE			(CLKID_BASE + 203)
+
+#define CLKID_DDR			(CLKID_BASE + 204)
+#define CLKID_DOS			(CLKID_BASE + 205)
+#define CLKID_ETHPHY			(CLKID_BASE + 206)
+#define CLKID_MALI_GATE			(CLKID_BASE + 207)
+#define CLKID_AOCPU			(CLKID_BASE + 208)
+#define CLKID_AUCPU			(CLKID_BASE + 209)
+#define CLKID_CEC			(CLKID_BASE + 210)
+#define CLKID_SD_EMMC_A			(CLKID_BASE + 211)
+#define CLKID_SD_EMMC_B			(CLKID_BASE + 212)
+#define CLKID_NAND			(CLKID_BASE + 213)
+#define CLKID_SMARTCARD			(CLKID_BASE + 214)
+#define CLKID_ACODEC			(CLKID_BASE + 215)
+#define CLKID_SPIFC			(CLKID_BASE + 216)
+#define CLKID_MSR_CLK			(CLKID_BASE + 217)
+#define CLKID_IR_CTRL			(CLKID_BASE + 218)
+#define CLKID_AUDIO			(CLKID_BASE + 219)
+#define CLKID_ETH			(CLKID_BASE + 220)
+#define CLKID_UART_A			(CLKID_BASE + 221)
+#define CLKID_UART_B			(CLKID_BASE + 222)
+#define CLKID_UART_C			(CLKID_BASE + 223)
+#define CLKID_UART_D			(CLKID_BASE + 224)
+#define CLKID_UART_E			(CLKID_BASE + 225)
+#define CLKID_AIFIFO			(CLKID_BASE + 226)
+#define CLKID_TS_DDR			(CLKID_BASE + 227)
+#define CLKID_TS_PLL			(CLKID_BASE + 228)
+#define CLKID_G2D			(CLKID_BASE + 229)
+#define CLKID_SPICC0			(CLKID_BASE + 230)
+#define CLKID_SPICC1			(CLKID_BASE + 231)
+#define CLKID_PCIE			(CLKID_BASE + 232)
+#define CLKID_USB			(CLKID_BASE + 233)
+#define CLKID_PCIE_PHY			(CLKID_BASE + 234)
+#define CLKID_I2C_M_A			(CLKID_BASE + 235)
+#define CLKID_I2C_M_B			(CLKID_BASE + 236)
+#define CLKID_I2C_M_C			(CLKID_BASE + 237)
+#define CLKID_I2C_M_D			(CLKID_BASE + 238)
+#define CLKID_I2C_M_E			(CLKID_BASE + 239)
+#define CLKID_I2C_M_F			(CLKID_BASE + 240)
+#define CLKID_HDMITX_APB		(CLKID_BASE + 241)
+#define CLKID_I2C_S_A			(CLKID_BASE + 242)
+#define CLKID_USB1_TO_DDR		(CLKID_BASE + 243)
+#define CLKID_HDCP22			(CLKID_BASE + 244)
+#define CLKID_MMC_APB			(CLKID_BASE + 245)
+#define CLKID_RSA			(CLKID_BASE + 246)
+#define CLKID_CPU_DEBUG			(CLKID_BASE + 247)
+#define CLKID_DSPA			(CLKID_BASE + 248)
+#define CLKID_VPU_INTR			(CLKID_BASE + 249)
+#define CLKID_SAR_ADC			(CLKID_BASE + 250)
+#define CLKID_GIC			(CLKID_BASE + 251)
+#define CLKID_PWM_AB			(CLKID_BASE + 252)
+#define CLKID_PWM_CD			(CLKID_BASE + 253)
+#define CLKID_PWM_EF			(CLKID_BASE + 254)
+#define CLKID_PWM_GH			(CLKID_BASE + 255)
+#define CLKID_PWM_IJ			(CLKID_BASE + 256)
+
+#define NR_CLKS				(CLKID_BASE + 257)
+
+#endif /* __SC2_CLKC_H */
--
2.43.0.windows.1


From 0b50f79f10ef6ed576dc1b17ea5769bbb1a800c1 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:23:21 +0200
Subject: [PATCH 13/26] dt-bindings: interrupt-controller: New binding for
 Meson SC2 SoCs Update dt-binding document for GPIO interrupt controller of
 Meson SC2 SoCs.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 .../bindings/interrupt-controller/amlogic,meson-gpio-intc.txt    | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Documentation/devicetree/bindings/interrupt-controller/amlogic,meson-gpio-intc.txt b/Documentation/devicetree/bindings/interrupt-controller/amlogic,meson-gpio-intc.txt
index bde63f8f0..f21de9262 100644
--- a/Documentation/devicetree/bindings/interrupt-controller/amlogic,meson-gpio-intc.txt
+++ b/Documentation/devicetree/bindings/interrupt-controller/amlogic,meson-gpio-intc.txt
@@ -19,6 +19,7 @@ Required properties:
     "amlogic,meson-sm1-gpio-intc" for SM1 SoCs (S905D3, S905X3, S905Y3)
     "amlogic,meson-a1-gpio-intc" for A1 SoCs (A113L)
     "amlogic,meson-s4-gpio-intc" for S4 SoCs (S802X2, S905Y4, S805X2G, S905W2)
+    "amlogic,meson-sc2-gpio-intc" for SC2 SoCs (S905X4)
 - reg : Specifies base physical address and size of the registers.
 - interrupt-controller : Identifies the node as an interrupt controller.
 - #interrupt-cells : Specifies the number of cells needed to encode an
--
2.43.0.windows.1


From 070f48aeba4fcd051b6d4f31c957dbad246e8b8c Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:26:30 +0200
Subject: [PATCH 14/26] irqchip/meson-gpio: Add support for meson SC2 SoCs This
 adds support for SC2 (S905X4) SoCs.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/irqchip/irq-meson-gpio.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/drivers/irqchip/irq-meson-gpio.c b/drivers/irqchip/irq-meson-gpio.c
index 7da18ef95..e948a3831 100644
--- a/drivers/irqchip/irq-meson-gpio.c
+++ b/drivers/irqchip/irq-meson-gpio.c
@@ -150,6 +150,10 @@ static const struct meson_gpio_irq_params s4_params = {
 	INIT_MESON_S4_COMMON_DATA(82)
 };

+static const struct meson_gpio_irq_params sc2_params = {
+	INIT_MESON_S4_COMMON_DATA(87)
+};
+
 static const struct of_device_id meson_irq_gpio_matches[] __maybe_unused = {
 	{ .compatible = "amlogic,meson8-gpio-intc", .data = &meson8_params },
 	{ .compatible = "amlogic,meson8b-gpio-intc", .data = &meson8b_params },
@@ -160,6 +164,7 @@ static const struct of_device_id meson_irq_gpio_matches[] __maybe_unused = {
 	{ .compatible = "amlogic,meson-sm1-gpio-intc", .data = &sm1_params },
 	{ .compatible = "amlogic,meson-a1-gpio-intc", .data = &a1_params },
 	{ .compatible = "amlogic,meson-s4-gpio-intc", .data = &s4_params },
+	{ .compatible = "amlogic,meson-sc2-gpio-intc", .data = &sc2_params },
 	{ }
 };

--
2.43.0.windows.1


From 001f611f55c9e6a06a6e505637cc5537a6bba898 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:30:40 +0200
Subject: [PATCH 15/26] dt-bindings: pinctrl: meson: Add compatible for SC2 Add
 new compatible for Amlogic's Meson-SC2 pin controller.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 Documentation/devicetree/bindings/pinctrl/meson,pinctrl.txt | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Documentation/devicetree/bindings/pinctrl/meson,pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/meson,pinctrl.txt
index 8146193bd..b703d2ed3 100644
--- a/Documentation/devicetree/bindings/pinctrl/meson,pinctrl.txt
+++ b/Documentation/devicetree/bindings/pinctrl/meson,pinctrl.txt
@@ -17,6 +17,7 @@ Required properties for the root node:
 		      "amlogic,meson-g12a-aobus-pinctrl"
 		      "amlogic,meson-a1-periphs-pinctrl"
 		      "amlogic,meson-s4-periphs-pinctrl"
+                      "amlogic,meson-sc2-periphs-pinctrl"
  - reg: address and size of registers controlling irq functionality

 === GPIO sub-nodes ===
--
2.43.0.windows.1


From acd6c4b66ec3304d6d79713977803ed2b05a3dcf Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:38:45 +0200
Subject: [PATCH 16/26] pinctrl: meson: add pinctrl driver support for
 Meson-SC2 Soc Add new pinctrl driver for Amlogic's Meson-SC2 SoC.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/pinctrl/meson/Kconfig             |    6 +
 drivers/pinctrl/meson/Makefile            |    2 +
 drivers/pinctrl/meson/pinctrl-meson-sc2.c | 1357 +++++++++++++++++++++
 3 files changed, 1365 insertions(+)
 create mode 100644 drivers/pinctrl/meson/pinctrl-meson-sc2.c

diff --git a/drivers/pinctrl/meson/Kconfig b/drivers/pinctrl/meson/Kconfig
index 64fb9e074..6117357d0 100644
--- a/drivers/pinctrl/meson/Kconfig
+++ b/drivers/pinctrl/meson/Kconfig
@@ -67,4 +67,10 @@ config PINCTRL_MESON_S4
 	select PINCTRL_MESON_AXG_PMX
 	default y

+config PINCTRL_MESON_SC2
+	tristate "Meson sc2 Soc pinctrl driver"
+	depends on ARM64
+	select PINCTRL_MESON_AXG_PMX
+	default y
+
 endif
diff --git a/drivers/pinctrl/meson/Makefile b/drivers/pinctrl/meson/Makefile
index 694f0596b..753511cff 100644
--- a/drivers/pinctrl/meson/Makefile
+++ b/drivers/pinctrl/meson/Makefile
@@ -10,3 +10,5 @@ obj-$(CONFIG_PINCTRL_MESON_AXG) += pinctrl-meson-axg.o
 obj-$(CONFIG_PINCTRL_MESON_G12A) += pinctrl-meson-g12a.o
 obj-$(CONFIG_PINCTRL_MESON_A1) += pinctrl-meson-a1.o
 obj-$(CONFIG_PINCTRL_MESON_S4) += pinctrl-meson-s4.o
+obj-$(CONFIG_PINCTRL_MESON_SC2) += pinctrl-meson-sc2.o
+
diff --git a/drivers/pinctrl/meson/pinctrl-meson-sc2.c b/drivers/pinctrl/meson/pinctrl-meson-sc2.c
new file mode 100644
index 000000000..7351467b7
--- /dev/null
+++ b/drivers/pinctrl/meson/pinctrl-meson-sc2.c
@@ -0,0 +1,1357 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <dt-bindings/gpio/meson-sc2-gpio.h>
+#include "pinctrl-meson.h"
+#include "pinctrl-meson-axg-pmx.h"
+
+static const struct pinctrl_pin_desc meson_sc2_periphs_pins[] = {
+	MESON_PIN(GPIOD_0),
+	MESON_PIN(GPIOD_1),
+	MESON_PIN(GPIOD_2),
+	MESON_PIN(GPIOD_3),
+	MESON_PIN(GPIOD_4),
+	MESON_PIN(GPIOD_5),
+	MESON_PIN(GPIOD_6),
+	MESON_PIN(GPIOD_7),
+	MESON_PIN(GPIOD_8),
+	MESON_PIN(GPIOD_9),
+	MESON_PIN(GPIOD_10),
+	MESON_PIN(GPIOD_11),
+	MESON_PIN(GPIOE_0),
+	MESON_PIN(GPIOE_1),
+	MESON_PIN(GPIOE_2),
+	MESON_PIN(GPIOB_0),
+	MESON_PIN(GPIOB_1),
+	MESON_PIN(GPIOB_2),
+	MESON_PIN(GPIOB_3),
+	MESON_PIN(GPIOB_4),
+	MESON_PIN(GPIOB_5),
+	MESON_PIN(GPIOB_6),
+	MESON_PIN(GPIOB_7),
+	MESON_PIN(GPIOB_8),
+	MESON_PIN(GPIOB_9),
+	MESON_PIN(GPIOB_10),
+	MESON_PIN(GPIOB_11),
+	MESON_PIN(GPIOB_12),
+	MESON_PIN(GPIOB_13),
+	MESON_PIN(GPIOB_14),
+	MESON_PIN(GPIOB_15),
+	MESON_PIN(GPIOC_0),
+	MESON_PIN(GPIOC_1),
+	MESON_PIN(GPIOC_2),
+	MESON_PIN(GPIOC_3),
+	MESON_PIN(GPIOC_4),
+	MESON_PIN(GPIOC_5),
+	MESON_PIN(GPIOC_6),
+	MESON_PIN(GPIOC_7),
+	MESON_PIN(GPIOX_0),
+	MESON_PIN(GPIOX_1),
+	MESON_PIN(GPIOX_2),
+	MESON_PIN(GPIOX_3),
+	MESON_PIN(GPIOX_4),
+	MESON_PIN(GPIOX_5),
+	MESON_PIN(GPIOX_6),
+	MESON_PIN(GPIOX_7),
+	MESON_PIN(GPIOX_8),
+	MESON_PIN(GPIOX_9),
+	MESON_PIN(GPIOX_10),
+	MESON_PIN(GPIOX_11),
+	MESON_PIN(GPIOX_12),
+	MESON_PIN(GPIOX_13),
+	MESON_PIN(GPIOX_14),
+	MESON_PIN(GPIOX_15),
+	MESON_PIN(GPIOX_16),
+	MESON_PIN(GPIOX_17),
+	MESON_PIN(GPIOX_18),
+	MESON_PIN(GPIOX_19),
+	MESON_PIN(GPIOH_0),
+	MESON_PIN(GPIOH_1),
+	MESON_PIN(GPIOH_2),
+	MESON_PIN(GPIOH_3),
+	MESON_PIN(GPIOH_4),
+	MESON_PIN(GPIOH_5),
+	MESON_PIN(GPIOH_6),
+	MESON_PIN(GPIOH_7),
+	MESON_PIN(GPIOH_8),
+	MESON_PIN(GPIOZ_0),
+	MESON_PIN(GPIOZ_1),
+	MESON_PIN(GPIOZ_2),
+	MESON_PIN(GPIOZ_3),
+	MESON_PIN(GPIOZ_4),
+	MESON_PIN(GPIOZ_5),
+	MESON_PIN(GPIOZ_6),
+	MESON_PIN(GPIOZ_7),
+	MESON_PIN(GPIOZ_8),
+	MESON_PIN(GPIOZ_9),
+	MESON_PIN(GPIOZ_10),
+	MESON_PIN(GPIOZ_11),
+	MESON_PIN(GPIOZ_12),
+	MESON_PIN(GPIOZ_13),
+	MESON_PIN(GPIOZ_14),
+	MESON_PIN(GPIOZ_15),
+	MESON_PIN(GPIOA_14),
+	MESON_PIN(GPIOA_15),
+	MESON_PIN(GPIO_TEST_N),
+};
+
+/*bank D func1 */
+static const unsigned int uart_b_tx_d_pins[]		= { GPIOD_0 };
+static const unsigned int uart_b_rx_d_pins[]		= { GPIOD_1 };
+static const unsigned int i2c4_scl_d_pins[]		= { GPIOD_2 };
+static const unsigned int i2c4_sda_d_pins[]		= { GPIOD_3 };
+static const unsigned int remote_out_d4_pins[]		= { GPIOD_4 };
+static const unsigned int remote_input_d5_pins[]	= { GPIOD_5 };
+static const unsigned int jtag_2_clk_pins[]		= { GPIOD_6 };
+static const unsigned int jtag_2_tms_pins[]		= { GPIOD_7 };
+static const unsigned int jtag_2_tdi_pins[]		= { GPIOD_8 };
+static const unsigned int jtag_2_tdo_pins[]		= { GPIOD_9 };
+static const unsigned int cec_a_d_pins[]		= { GPIOD_10 };
+
+/*bank D func2 */
+static const unsigned int uart_a_tx_d2_pins[]		= { GPIOD_2 };
+static const unsigned int uart_a_rx_d3_pins[]		= { GPIOD_3 };
+static const unsigned int clk_32k_in_pins[]		= { GPIOD_4 };
+static const unsigned int remote_out_d9_pins[]		= { GPIOD_9 };
+static const unsigned int cec_b_d_pins[]		= { GPIOD_10 };
+static const unsigned int pwm_g_hiz_pins[]		= { GPIOD_11 };
+
+/*bank D func3 */
+static const unsigned int i2c_slave_scl_pins[]		= { GPIOD_2 };
+static const unsigned int i2c_slave_sda_pins[]		= { GPIOD_3 };
+static const unsigned int pwm_i_d4_pins[]		= { GPIOD_4 };
+static const unsigned int pwm_j_d5_pins[]		= { GPIOD_5 };
+static const unsigned int pwm_i_d6_pins[]		= { GPIOD_6 };
+static const unsigned int uart_a_tx_d8_pins[]		= { GPIOD_8 };
+static const unsigned int uart_a_rx_d9_pins[]		= { GPIOD_9 };
+static const unsigned int pwm_j_d10_pins[]		= { GPIOD_10 };
+static const unsigned int pwm_g_pins[]			= { GPIOD_11 };
+
+/*bank D func4 */
+static const unsigned int pwm_i_hiz_pins[]		= { GPIOD_4 };
+static const unsigned int tsin_a_sop_d_pins[]		= { GPIOD_6 };
+static const unsigned int tsin_a_din0_d_pins[]		= { GPIOD_7 };
+static const unsigned int tsin_a_clk_d_pins[]		= { GPIOD_8 };
+static const unsigned int tsin_a_valid_d_pins[]		= { GPIOD_9 };
+static const unsigned int spdif_out_d_pins[]		= { GPIOD_10 };
+static const unsigned int gen_clk_d_pins[]		= { GPIOD_11 };
+
+/*bank D func5 */
+static const unsigned int mic_mute_en_pins[]		= { GPIOD_2 };
+static const unsigned int tdm_d0_pins[]			= { GPIOD_4 };
+static const unsigned int tdm_d1_pins[]			= { GPIOD_6 };
+static const unsigned int tdm_fs1_pins[]		= { GPIOD_7 };
+static const unsigned int tdm_sclk1_pins[]		= { GPIOD_8 };
+static const unsigned int mclk1_pins[]			= { GPIOD_9 };
+static const unsigned int tdm_d2_d_pins[]		= { GPIOD_10 };
+
+/*bank D func6 */
+static const unsigned int clk12_24_d_pins[]		= { GPIOD_10 };
+
+/*bank E func1 */
+static const unsigned int uart_b_cts_pins[]		= { GPIOE_0 };
+static const unsigned int uart_b_rts_pins[]		= { GPIOE_1 };
+static const unsigned int clk12_24_e_pins[]		= { GPIOE_2 };
+
+/*bank E funsc2 */
+static const unsigned int uart_a_cts_pins[]		= { GPIOE_0 };
+static const unsigned int uart_a_rts_pins[]		= { GPIOE_1 };
+static const unsigned int clk25_pins[]			= { GPIOE_2 };
+
+/*bank E func3 */
+static const unsigned int pwm_h_pins[]			= { GPIOE_0 };
+static const unsigned int pwm_j_e_pins[]		= { GPIOE_1 };
+static const unsigned int pwm_a_e_pins[]		= { GPIOE_2 };
+
+/*bank E func4 */
+static const unsigned int i2c4_scl_e_pins[]		= { GPIOE_0 };
+static const unsigned int i2c4_sda_e_pins[]		= { GPIOE_1 };
+
+/*bank E func5 */
+static const unsigned int mic_mute_key_pins[]		= { GPIOE_2 };
+
+/*bank B func1 */
+static const unsigned int emmc_nand_d0_pins[]		= { GPIOB_0 };
+static const unsigned int emmc_nand_d1_pins[]		= { GPIOB_1 };
+static const unsigned int emmc_nand_d2_pins[]		= { GPIOB_2 };
+static const unsigned int emmc_nand_d3_pins[]		= { GPIOB_3 };
+static const unsigned int emmc_nand_d4_pins[]		= { GPIOB_4 };
+static const unsigned int emmc_nand_d5_pins[]		= { GPIOB_5 };
+static const unsigned int emmc_nand_d6_pins[]		= { GPIOB_6 };
+static const unsigned int emmc_nand_d7_pins[]		= { GPIOB_7 };
+static const unsigned int emmc_clk_pins[]		= { GPIOB_8 };
+static const unsigned int emmc_cmd_pins[]		= { GPIOB_10 };
+static const unsigned int emmc_nand_dqs_pins[]		= { GPIOB_13 };
+
+/*bank B funsc2 */
+static const unsigned int nand_wen_clk_pins[]		= { GPIOB_8 };
+static const unsigned int nand_ale_pins[]		= { GPIOB_9 };
+static const unsigned int nand_cle_pins[]		= { GPIOB_10 };
+static const unsigned int nand_ce0_pins[]		= { GPIOB_11 };
+static const unsigned int nand_ren_wr_pins[]		= { GPIOB_12 };
+static const unsigned int nand_rb0_pins[]		= { GPIOB_14 };
+static const unsigned int nand_ce1_pins[]		= { GPIOB_15 };
+
+/*bank B func3 */
+static const unsigned int nor_hold_pins[]		= { GPIOB_3 };
+static const unsigned int nor_d_pins[]			= { GPIOB_4 };
+static const unsigned int nor_q_pins[]			= { GPIOB_5 };
+static const unsigned int nor_c_pins[]			= { GPIOB_6 };
+static const unsigned int nor_wp_pins[]			= { GPIOB_7 };
+static const unsigned int nor_cs_pins[]			= { GPIOB_14 };
+
+/*bank C func1 */
+static const unsigned int sdcard_d0_c_pins[]		= { GPIOC_0 };
+static const unsigned int sdcard_d1_c_pins[]		= { GPIOC_1 };
+static const unsigned int sdcard_d2_c_pins[]		= { GPIOC_2 };
+static const unsigned int sdcard_d3_c_pins[]		= { GPIOC_3 };
+static const unsigned int sdcard_clk_c_pins[]		= { GPIOC_4 };
+static const unsigned int sdcard_cmd_c_pins[]		= { GPIOC_5 };
+static const unsigned int sdcard_cd_pins[]		= { GPIOC_6 };
+static const unsigned int pcieck_reqn_pins[]		= { GPIOC_7 };
+
+/*bank C funsc2 */
+static const unsigned int jtag_1_tdo_pins[]		= { GPIOC_0 };
+static const unsigned int jtag_1_tdi_pins[]		= { GPIOC_1 };
+static const unsigned int uart_b_rx_c_pins[]		= { GPIOC_2 };
+static const unsigned int uart_b_tx_c_pins[]		= { GPIOC_3 };
+static const unsigned int jtag_1_clk_pins[]		= { GPIOC_4 };
+static const unsigned int jtag_1_tms_pins[]		= { GPIOC_5 };
+
+/*bank C func3 */
+static const unsigned int tsin_c_valid_c_pins[]		= { GPIOC_0 };
+static const unsigned int tsin_c_sop_c_pins[]		= { GPIOC_1 };
+static const unsigned int tsin_c_din0_c_pins[]		= { GPIOC_2 };
+static const unsigned int tsin_c_clk_c_pins[]		= { GPIOC_3 };
+static const unsigned int i2c0_sda_c_pins[]		= { GPIOC_5 };
+static const unsigned int i2c0_scl_c_pins[]		= { GPIOC_6 };
+
+/*bank C func4 */
+static const unsigned int pdm_din0_c_pins[]		= { GPIOC_0 };
+static const unsigned int pdm_din1_c1_pins[]		= { GPIOC_1 };
+static const unsigned int pdm_din2_c_pins[]		= { GPIOC_2 };
+static const unsigned int pdm_din3_c_pins[]		= { GPIOC_3 };
+static const unsigned int pdm_dclk_c_pins[]		= { GPIOC_4 };
+static const unsigned int pdm_din1_c7_pins[]		= { GPIOC_7 };
+
+/*bank C func5 */
+static const unsigned int spi_a_mosi_c_pins[]		= { GPIOC_0 };
+static const unsigned int spi_a_miso_c_pins[]		= { GPIOC_1 };
+static const unsigned int spi_a_ss0_c_pins[]		= { GPIOC_2 };
+static const unsigned int spi_a_sclk_c_pins[]		= { GPIOC_3 };
+static const unsigned int pwm_c_c_pins[]		= { GPIOC_4 };
+static const unsigned int iso7816_clk_c_pins[]		= { GPIOC_5 };
+static const unsigned int iso7816_data_c_pins[]		= { GPIOC_6 };
+
+/*bank X func1*/
+static const unsigned int sdio_d0_x_pins[]		= { GPIOX_0 };
+static const unsigned int sdio_d1_x_pins[]		= { GPIOX_1 };
+static const unsigned int sdio_d2_x_pins[]		= { GPIOX_2 };
+static const unsigned int sdio_d3_x_pins[]		= { GPIOX_3 };
+static const unsigned int sdio_clk_x_pins[]		= { GPIOX_4 };
+static const unsigned int sdio_cmd_x_pins[]		= { GPIOX_5 };
+static const unsigned int pwm_a_x_pins[]		= { GPIOX_6 };
+static const unsigned int pwm_f_x_pins[]		= { GPIOX_7 };
+static const unsigned int tdm_d3_pins[]			= { GPIOX_8 };
+static const unsigned int tdm_d4_pins[]			= { GPIOX_9 };
+static const unsigned int tdm_fs0_pins[]		= { GPIOX_10 };
+static const unsigned int tdm_sclk0_pins[]		= { GPIOX_11 };
+static const unsigned int uart_e_tx_pins[]		= { GPIOX_12 };
+static const unsigned int uart_e_rx_pins[]		= { GPIOX_13 };
+static const unsigned int uart_e_cts_pins[]		= { GPIOX_14 };
+static const unsigned int uart_e_rts_pins[]		= { GPIOX_15 };
+static const unsigned int pwm_e_pins[]			= { GPIOX_16 };
+static const unsigned int i2c2_sda_x_pins[]		= { GPIOX_17 };
+static const unsigned int i2c2_scl_x_pins[]		= { GPIOX_18 };
+static const unsigned int pwm_b_x19_pins[]		= { GPIOX_19 };
+
+/*bank X func2*/
+static const unsigned int pdm_din0_x_pins[]		= { GPIOX_0 };
+static const unsigned int pdm_din1_x_pins[]		= { GPIOX_1 };
+static const unsigned int pdm_din2_x_pins[]		= { GPIOX_2 };
+static const unsigned int pdm_din3_x_pins[]		= { GPIOX_3 };
+static const unsigned int pdm_dclk_x_pins[]		= { GPIOX_4 };
+static const unsigned int mclk_0_pins[]			= { GPIOX_5 };
+static const unsigned int uart_d_tx_x6_pins[]		= { GPIOX_6 };
+static const unsigned int uart_d_rx_x7_pins[]		= { GPIOX_7 };
+static const unsigned int uart_d_cts_pins[]		= { GPIOX_8 };
+static const unsigned int uart_d_rts_pins[]		= { GPIOX_9 };
+static const unsigned int uart_d_tx_x10_pins[]		= { GPIOX_10 };
+static const unsigned int uart_d_rx_x11_pins[]		= { GPIOX_11};
+static const unsigned int tdm_d15_pins[]		= { GPIOX_19};
+
+/*bank X func3*/
+static const unsigned int tsin_a_din0_x_pins[]		= { GPIOX_0 };
+static const unsigned int tsin_a_sop_x_pins[]		= { GPIOX_1 };
+static const unsigned int tsin_a_valid_x_pins[]		= { GPIOX_2 };
+static const unsigned int tsin_a_clk_x_pins[]		= { GPIOX_3 };
+static const unsigned int tsin_d_sop_x_pins[]		= { GPIOX_8 };
+static const unsigned int tsin_d_valid_x_pins[]		= { GPIOX_9 };
+static const unsigned int tsin_d_din0_x_pins[]		= { GPIOX_10 };
+static const unsigned int tsin_d_clk_x_pins[]		= { GPIOX_11 };
+
+/*bank X func4*/
+static const unsigned int pwm_d_x3_pins[]		= { GPIOX_3 };
+static const unsigned int pwm_c_x_pins[]		= { GPIOX_5 };
+static const unsigned int pwm_d_x6_pins[]		= { GPIOX_6 };
+static const unsigned int pwm_b_x7_pins[]		= { GPIOX_7 };
+static const unsigned int spi_a_mosi_x_pins[]		= { GPIOX_8 };
+static const unsigned int spi_a_miso_x_pins[]		= { GPIOX_9 };
+static const unsigned int spi_a_ss0_x_pins[]		= { GPIOX_10 };
+static const unsigned int spi_a_sclk_x_pins[]		= { GPIOX_11 };
+
+/*bank X func5 */
+static const unsigned int sdcard_d0_x_pins[]		= { GPIOX_0 };
+static const unsigned int sdcard_d1_x_pins[]		= { GPIOX_1 };
+static const unsigned int sdcard_d2_x_pins[]		= { GPIOX_2 };
+static const unsigned int sdcard_d3_x_pins[]		= { GPIOX_3 };
+static const unsigned int sdcard_clk_x_pins[]		= { GPIOX_4 };
+static const unsigned int sdcard_cd_x_pins[]		= { GPIOX_5 };
+static const unsigned int iso7816_clk_x_pins[]		= { GPIOX_8 };
+static const unsigned int iso7816_data_x_pins[]		= { GPIOX_9 };
+static const unsigned int i2c1_sda_x_pins[]		= { GPIOX_10 };
+static const unsigned int i2c1_scl_x_pins[]		= { GPIOX_11 };
+static const unsigned int gen_clk_x_pins[]		= { GPIOX_19 };
+
+/*bank H func1 */
+static const unsigned int hdmitx_sda_pins[]		= { GPIOH_0 };
+static const unsigned int hdmitx_sck_pins[]		= { GPIOH_1 };
+static const unsigned int hdmitx_hpd_in_pins[]		= { GPIOH_2 };
+static const unsigned int spdif_out_h_pins[]		= { GPIOH_4 };
+static const unsigned int spdif_in_h_pins[]		= { GPIOH_5 };
+static const unsigned int iso7816_clk_h_pins[]		= { GPIOH_6 };
+static const unsigned int iso7816_data_h_pins[]		= { GPIOH_7 };
+
+/*bank H func2 */
+static const unsigned int i2c3_sda_h_pins[]		= { GPIOH_0 };
+static const unsigned int i2c3_scl_h_pins[]		= { GPIOH_1 };
+static const unsigned int i2c1_sda_h2_pins[]		= { GPIOH_2 };
+static const unsigned int i2c1_scl_h3_pins[]		= { GPIOH_3 };
+static const unsigned int uart_c_rts_pins[]		= { GPIOH_4 };
+static const unsigned int uart_c_cts_pins[]		= { GPIOH_5 };
+static const unsigned int uart_c_rx_pins[]		= { GPIOH_6 };
+static const unsigned int uart_c_tx_pins[]		= { GPIOH_7 };
+
+/*bank H func3 */
+static const unsigned int spi_b_mosi_h_pins[]		= { GPIOH_4 };
+static const unsigned int spi_b_miso_h_pins[]		= { GPIOH_5 };
+static const unsigned int spi_b_ss0_h_pins[]		= { GPIOH_6 };
+static const unsigned int spi_b_sclk_h_pins[]		= { GPIOH_7 };
+
+/*bank H func4 */
+static const unsigned int cec_a_h_pins[]		= { GPIOH_3 };
+static const unsigned int pwm_f_h_pins[]		= { GPIOH_5 };
+static const unsigned int i2c1_sda_h6_pins[]		= { GPIOH_6 };
+static const unsigned int i2c1_scl_h7_pins[]		= { GPIOH_7 };
+
+/*bank H func5 */
+static const unsigned int cec_b_h_pins[]		= { GPIOH_3 };
+static const unsigned int tdm_d5_pins[]			= { GPIOH_5 };
+static const unsigned int remote_out_h_pins[]		= { GPIOH_6 };
+static const unsigned int pwm_b_h_pins[]		= { GPIOH_7 };
+
+/*bank H func6 */
+static const unsigned int i2c0_sda_h_pins[]		= { GPIOH_4 };
+static const unsigned int i2c0_scl_h_pins[]		= { GPIOH_5 };
+
+/*bank Z func1 */
+static const unsigned int eth_mdio_pins[]		= { GPIOZ_0 };
+static const unsigned int eth_mdc_pins[]		= { GPIOZ_1 };
+static const unsigned int eth_rgmii_rx_clk_pins[]	= { GPIOZ_2 };
+static const unsigned int eth_rx_dv_pins[]		= { GPIOZ_3 };
+static const unsigned int eth_rxd0_pins[]		= { GPIOZ_4 };
+static const unsigned int eth_rxd1_pins[]		= { GPIOZ_5 };
+static const unsigned int eth_rxd2_rgmii_pins[]		= { GPIOZ_6 };
+static const unsigned int eth_rxd3_rgmii_pins[]		= { GPIOZ_7 };
+static const unsigned int eth_rgmii_tx_clk_pins[]	= { GPIOZ_8 };
+static const unsigned int eth_txen_pins[]		= { GPIOZ_9 };
+static const unsigned int eth_txd0_pins[]		= { GPIOZ_10 };
+static const unsigned int eth_txd1_pins[]		= { GPIOZ_11 };
+static const unsigned int eth_txd2_rgmii_pins[]		= { GPIOZ_12 };
+static const unsigned int eth_txd3_rgmii_pins[]		= { GPIOZ_13 };
+static const unsigned int eth_link_led_pins[]		= { GPIOZ_14 };
+static const unsigned int eth_act_led_pins[]		= { GPIOZ_15 };
+
+/*bank Z func2 */
+static const unsigned int pwm_d_z_pins[]		= { GPIOZ_2 };
+static const unsigned int clk12_24_z_pins[]		= { GPIOZ_13 };
+
+/*bank Z func3 */
+static const unsigned int iso7816_clk_z0_pins[]		= { GPIOZ_0 };
+static const unsigned int iso7816_data_z1_pins[]	= { GPIOZ_1 };
+static const unsigned int tsin_b_valid_pins[]		= { GPIOZ_2 };
+static const unsigned int tsin_b_sop_pins[]		= { GPIOZ_3 };
+static const unsigned int tsin_b_din0_pins[]		= { GPIOZ_4 };
+static const unsigned int tsin_b_clk_pins[]		= { GPIOZ_5 };
+static const unsigned int tsin_b_fail_pins[]		= { GPIOZ_6 };
+static const unsigned int tsin_b_din1_pins[]		= { GPIOZ_7 };
+static const unsigned int tsin_b_din2_pins[]		= { GPIOZ_8 };
+static const unsigned int tsin_b_din3_pins[]		= { GPIOZ_9 };
+static const unsigned int tsin_b_din4_pins[]		= { GPIOZ_10 };
+static const unsigned int tsin_b_din5_pins[]		= { GPIOZ_11 };
+static const unsigned int tsin_b_din6_pins[]		= { GPIOZ_12 };
+static const unsigned int tsin_b_din7_pins[]		= { GPIOZ_13 };
+static const unsigned int i2c2_sda_z14_pins[]		= { GPIOZ_14 };
+static const unsigned int i2c2_scl_z15_pins[]		= { GPIOZ_15 };
+
+/*bank Z func4 */
+static const unsigned int i2c0_sda_z0_pins[]		= { GPIOZ_0 };
+static const unsigned int i2c0_scl_z1_pins[]		= { GPIOZ_1 };
+static const unsigned int tdm_d6_pins[]			= { GPIOZ_2 };
+static const unsigned int tdm_d7_pins[]			= { GPIOZ_3 };
+static const unsigned int tdm_d8_pins[]			= { GPIOZ_4 };
+static const unsigned int tdm_d9_pins[]			= { GPIOZ_5 };
+static const unsigned int tdm_fs2_pins[]		= { GPIOZ_6 };
+static const unsigned int tdm_sclk2_pins[]		= { GPIOZ_7 };
+static const unsigned int mclk_2_pins[]			= { GPIOZ_8 };
+static const unsigned int tdm_d10_pins[]		= { GPIOZ_9 };
+static const unsigned int tdm_d11_pins[]		= { GPIOZ_10 };
+static const unsigned int tdm_d12_pins[]		= { GPIOZ_11 };
+static const unsigned int tdm_d13_pins[]		= { GPIOZ_12 };
+static const unsigned int tdm_d14_pins[]		= { GPIOZ_13 };
+
+/*bank Z func5 */
+static const unsigned int pwm_b_z0_pins[]		= { GPIOZ_0 };
+static const unsigned int pwm_c_z_pins[]		= { GPIOZ_1 };
+static const unsigned int sdcard_d0_z_pins[]		= { GPIOZ_2 };
+static const unsigned int sdcard_d1_z_pins[]		= { GPIOZ_3 };
+static const unsigned int sdcard_d2_z_pins[]		= { GPIOZ_4 };
+static const unsigned int sdcard_d3_z_pins[]		= { GPIOZ_5 };
+static const unsigned int sdcard_clk_z_pins[]		= { GPIOZ_6 };
+static const unsigned int sdcard_cmd_z_pins[]		= { GPIOZ_7 };
+static const unsigned int iso7816_clk_z8_pins[]		= { GPIOZ_8 };
+static const unsigned int iso7816_data_z9_pins[]	= { GPIOZ_9 };
+static const unsigned int remote_out_z_pins[]		= { GPIOZ_10 };
+static const unsigned int pwm_f_z_pins[]		= { GPIOZ_12 };
+static const unsigned int pwm_b_z13_pins[]		= { GPIOZ_13 };
+
+/*bank Z func6 */
+static const unsigned int i2c1_sda_z_pins[]		= { GPIOZ_0 };
+static const unsigned int i2c1_scl_z_pins[]		= { GPIOZ_1 };
+static const unsigned int tdm_fs3_pins[]		= { GPIOZ_2 };
+static const unsigned int tdm_sclk3_pins[]		= { GPIOZ_3 };
+static const unsigned int tdm_fs4_pins[]		= { GPIOZ_4 };
+static const unsigned int tdm_sclk4_pins[]		= { GPIOZ_5 };
+static const unsigned int tsin_c_valid_z_pins[]		= { GPIOZ_6 };
+static const unsigned int tsin_c_sop_z_pins[]		= { GPIOZ_7 };
+static const unsigned int tsin_c_din0_z_pins[]		= { GPIOZ_8 };
+static const unsigned int tsin_c_clk_z_pins[]		= { GPIOZ_9 };
+static const unsigned int tsin_d_valid_z_pins[]		= { GPIOZ_10 };
+static const unsigned int tsin_d_sop_z_pins[]		= { GPIOZ_11 };
+static const unsigned int tsin_d_din0_z_pins[]		= { GPIOZ_12 };
+static const unsigned int tsin_d_clk_z_pins[]		= { GPIOZ_13 };
+
+/*bank Z func7 */
+static const unsigned int pdm_din0_z_pins[]		= { GPIOZ_2 };
+static const unsigned int pdm_din1_z_pins[]		= { GPIOZ_3 };
+static const unsigned int pdm_din2_z_pins[]		= { GPIOZ_4 };
+static const unsigned int pdm_din3_z_pins[]		= { GPIOZ_5 };
+static const unsigned int pdm_dclk_z_pins[]		= { GPIOZ_6 };
+static const unsigned int i2c0_sda_z7_pins[]		= { GPIOZ_7 };
+static const unsigned int i2c0_scl_z8_pins[]		= { GPIOZ_8 };
+static const unsigned int i2c2_sda_z10_pins[]		= { GPIOZ_10 };
+static const unsigned int i2c2_scl_z11_pins[]		= { GPIOZ_11 };
+static const unsigned int gen_clk_z_pins[]		= { GPIOZ_13 };
+
+/*bank A func1 */
+static const unsigned int remote_input_a_pins[]		= { GPIOA_15 };
+/*bank A func3 */
+static const unsigned int i2c3_sda_a_pins[]		= { GPIOA_14 };
+static const unsigned int i2c3_scl_a_pins[]		= { GPIOA_15 };
+/*bank A func5 */
+static const unsigned int pdm_din0_a_pins[]		= { GPIOA_14 };
+static const unsigned int pdm_dclk_a_pins[]		= { GPIOA_15 };
+/*bank A func7 */
+static const unsigned int gen_clk_a_pins[]		= { GPIOA_15 };
+
+static struct meson_pmx_group meson_sc2_periphs_groups[] = {
+	GPIO_GROUP(GPIOD_0),
+	GPIO_GROUP(GPIOD_1),
+	GPIO_GROUP(GPIOD_2),
+	GPIO_GROUP(GPIOD_3),
+	GPIO_GROUP(GPIOD_4),
+	GPIO_GROUP(GPIOD_5),
+	GPIO_GROUP(GPIOD_6),
+	GPIO_GROUP(GPIOD_7),
+	GPIO_GROUP(GPIOD_8),
+	GPIO_GROUP(GPIOD_9),
+	GPIO_GROUP(GPIOD_10),
+	GPIO_GROUP(GPIOD_11),
+	GPIO_GROUP(GPIOE_0),
+	GPIO_GROUP(GPIOE_1),
+	GPIO_GROUP(GPIOE_2),
+	GPIO_GROUP(GPIOB_0),
+	GPIO_GROUP(GPIOB_1),
+	GPIO_GROUP(GPIOB_2),
+	GPIO_GROUP(GPIOB_3),
+	GPIO_GROUP(GPIOB_4),
+	GPIO_GROUP(GPIOB_5),
+	GPIO_GROUP(GPIOB_6),
+	GPIO_GROUP(GPIOB_7),
+	GPIO_GROUP(GPIOB_8),
+	GPIO_GROUP(GPIOB_9),
+	GPIO_GROUP(GPIOB_10),
+	GPIO_GROUP(GPIOB_11),
+	GPIO_GROUP(GPIOB_12),
+	GPIO_GROUP(GPIOB_13),
+	GPIO_GROUP(GPIOB_14),
+	GPIO_GROUP(GPIOB_15),
+	GPIO_GROUP(GPIOC_0),
+	GPIO_GROUP(GPIOC_1),
+	GPIO_GROUP(GPIOC_2),
+	GPIO_GROUP(GPIOC_3),
+	GPIO_GROUP(GPIOC_4),
+	GPIO_GROUP(GPIOC_5),
+	GPIO_GROUP(GPIOC_6),
+	GPIO_GROUP(GPIOC_7),
+	GPIO_GROUP(GPIOX_0),
+	GPIO_GROUP(GPIOX_1),
+	GPIO_GROUP(GPIOX_2),
+	GPIO_GROUP(GPIOX_3),
+	GPIO_GROUP(GPIOX_4),
+	GPIO_GROUP(GPIOX_5),
+	GPIO_GROUP(GPIOX_6),
+	GPIO_GROUP(GPIOX_7),
+	GPIO_GROUP(GPIOX_8),
+	GPIO_GROUP(GPIOX_9),
+	GPIO_GROUP(GPIOX_10),
+	GPIO_GROUP(GPIOX_11),
+	GPIO_GROUP(GPIOX_12),
+	GPIO_GROUP(GPIOX_13),
+	GPIO_GROUP(GPIOX_14),
+	GPIO_GROUP(GPIOX_15),
+	GPIO_GROUP(GPIOX_16),
+	GPIO_GROUP(GPIOX_17),
+	GPIO_GROUP(GPIOX_18),
+	GPIO_GROUP(GPIOX_19),
+	GPIO_GROUP(GPIOH_0),
+	GPIO_GROUP(GPIOH_1),
+	GPIO_GROUP(GPIOH_2),
+	GPIO_GROUP(GPIOH_3),
+	GPIO_GROUP(GPIOH_4),
+	GPIO_GROUP(GPIOH_5),
+	GPIO_GROUP(GPIOH_6),
+	GPIO_GROUP(GPIOH_7),
+	GPIO_GROUP(GPIOH_8),
+	GPIO_GROUP(GPIOZ_0),
+	GPIO_GROUP(GPIOZ_1),
+	GPIO_GROUP(GPIOZ_2),
+	GPIO_GROUP(GPIOZ_3),
+	GPIO_GROUP(GPIOZ_4),
+	GPIO_GROUP(GPIOZ_5),
+	GPIO_GROUP(GPIOZ_6),
+	GPIO_GROUP(GPIOZ_7),
+	GPIO_GROUP(GPIOZ_8),
+	GPIO_GROUP(GPIOZ_9),
+	GPIO_GROUP(GPIOZ_10),
+	GPIO_GROUP(GPIOZ_11),
+	GPIO_GROUP(GPIOZ_12),
+	GPIO_GROUP(GPIOZ_13),
+	GPIO_GROUP(GPIOZ_14),
+	GPIO_GROUP(GPIOZ_15),
+	GPIO_GROUP(GPIOA_14),
+	GPIO_GROUP(GPIOA_15),
+	GPIO_GROUP(GPIO_TEST_N),
+
+	/* bank D func1 */
+	GROUP(uart_b_tx_d,		1),
+	GROUP(uart_b_rx_d,		1),
+	GROUP(i2c4_scl_d,		1),
+	GROUP(i2c4_sda_d,		1),
+	GROUP(remote_out_d4,		1),
+	GROUP(remote_input_d5,		1),
+	GROUP(jtag_2_clk,		1),
+	GROUP(jtag_2_tms,		1),
+	GROUP(jtag_2_tdi,		1),
+	GROUP(jtag_2_tdo,		1),
+	GROUP(cec_a_d,			1),
+
+	/* bank D funsc2 */
+	GROUP(uart_a_tx_d2,		2),
+	GROUP(uart_a_rx_d3,		2),
+	GROUP(clk_32k_in,		2),
+	GROUP(remote_out_d9,		2),
+	GROUP(cec_b_d,			2),
+	GROUP(pwm_g_hiz,		2),
+
+	/* bank D func3 */
+	GROUP(i2c_slave_scl,		3),
+	GROUP(i2c_slave_sda,		3),
+	GROUP(pwm_i_d4,			3),
+	GROUP(pwm_j_d5,			3),
+	GROUP(pwm_i_d6,			3),
+	GROUP(uart_a_tx_d8,		3),
+	GROUP(uart_a_rx_d9,		3),
+	GROUP(pwm_j_d10,		3),
+	GROUP(pwm_g,			3),
+
+	/* bank D func4 */
+	GROUP(pwm_i_hiz,		4),
+	GROUP(tsin_a_sop_d,		4),
+	GROUP(tsin_a_din0_d,		4),
+	GROUP(tsin_a_clk_d,		4),
+	GROUP(tsin_a_valid_d,		4),
+	GROUP(spdif_out_d,		4),
+	GROUP(gen_clk_d,		4),
+
+	/* bank D func5 */
+	GROUP(mic_mute_en,		5),
+	GROUP(tdm_d0,			5),
+	GROUP(tdm_d1,			5),
+	GROUP(tdm_fs1,			5),
+	GROUP(tdm_sclk1,		5),
+	GROUP(mclk1,			5),
+	GROUP(tdm_d2_d,			5),
+
+	/* bank D func6 */
+	GROUP(clk12_24_d,		6),
+
+	/* bank E func1 */
+	GROUP(uart_b_cts,		1),
+	GROUP(uart_b_rts,		1),
+	GROUP(clk12_24_e,		1),
+
+	/* bank E funsc2 */
+	GROUP(uart_a_cts,		2),
+	GROUP(uart_a_rts,		2),
+	GROUP(clk25,			2),
+
+	/* bank E func3 */
+	GROUP(pwm_h,			3),
+	GROUP(pwm_j_e,			3),
+	GROUP(pwm_a_e,			3),
+
+	/* bank E func4 */
+	GROUP(i2c4_scl_e,		4),
+	GROUP(i2c4_sda_e,		4),
+
+	/*bank E func5 */
+	GROUP(mic_mute_key,		5),
+
+	/* bank B func1 */
+	GROUP(emmc_nand_d0,		1),
+	GROUP(emmc_nand_d1,		1),
+	GROUP(emmc_nand_d2,		1),
+	GROUP(emmc_nand_d3,		1),
+	GROUP(emmc_nand_d4,		1),
+	GROUP(emmc_nand_d5,		1),
+	GROUP(emmc_nand_d6,		1),
+	GROUP(emmc_nand_d7,		1),
+	GROUP(emmc_clk,			1),
+	GROUP(emmc_cmd,			1),
+	GROUP(emmc_nand_dqs,		1),
+
+	/* bank B funsc2 */
+	GROUP(nand_wen_clk,		2),
+	GROUP(nand_ale,			2),
+	GROUP(nand_cle,			2),
+	GROUP(nand_ce0,			2),
+	GROUP(nand_ren_wr,		2),
+	GROUP(nand_rb0,			2),
+	GROUP(nand_ce1,			2),
+
+	/* bank B func3 */
+	GROUP(nor_hold,			3),
+	GROUP(nor_d,			3),
+	GROUP(nor_q,			3),
+	GROUP(nor_c,			3),
+	GROUP(nor_wp,			3),
+	GROUP(nor_cs,			3),
+
+	/* bank C func1 */
+	GROUP(sdcard_d0_c,		1),
+	GROUP(sdcard_d1_c,		1),
+	GROUP(sdcard_d2_c,		1),
+	GROUP(sdcard_d3_c,		1),
+	GROUP(sdcard_clk_c,		1),
+	GROUP(sdcard_cmd_c,		1),
+	GROUP(sdcard_cd,		1),
+	GROUP(pcieck_reqn,		1),
+
+	/* bank C funsc2 */
+	GROUP(jtag_1_tdo,		2),
+	GROUP(jtag_1_tdi,		2),
+	GROUP(uart_b_rx_c,		2),
+	GROUP(uart_b_tx_c,		2),
+	GROUP(jtag_1_clk,		2),
+	GROUP(jtag_1_tms,		2),
+
+	/* bank C func3 */
+	GROUP(tsin_c_valid_c,		3),
+	GROUP(tsin_c_sop_c,		3),
+	GROUP(tsin_c_din0_c,		3),
+	GROUP(tsin_c_clk_c,		3),
+	GROUP(i2c0_sda_c,		3),
+	GROUP(i2c0_scl_c,		3),
+
+	/* bank C func4 */
+	GROUP(pdm_din0_c,		4),
+	GROUP(pdm_din1_c1,		4),
+	GROUP(pdm_din2_c,		4),
+	GROUP(pdm_din3_c,		4),
+	GROUP(pdm_dclk_c,		4),
+	GROUP(pdm_din1_c7,		4),
+
+	/* bank C func5 */
+	GROUP(spi_a_mosi_c,		5),
+	GROUP(spi_a_miso_c,		5),
+	GROUP(spi_a_ss0_c,		5),
+	GROUP(spi_a_sclk_c,		5),
+	GROUP(pwm_c_c,			5),
+	GROUP(iso7816_clk_c,		5),
+	GROUP(iso7816_data_c,		5),
+
+	/* bank X func1 */
+	GROUP(sdio_d0_x,		1),
+	GROUP(sdio_d1_x,		1),
+	GROUP(sdio_d2_x,		1),
+	GROUP(sdio_d3_x,		1),
+	GROUP(sdio_clk_x,		1),
+	GROUP(sdio_cmd_x,		1),
+	GROUP(pwm_a_x,			1),
+	GROUP(pwm_f_x,			1),
+	GROUP(tdm_d3,			1),
+	GROUP(tdm_d4,			1),
+	GROUP(tdm_fs0,			1),
+	GROUP(tdm_sclk0,		1),
+	GROUP(uart_e_tx,		1),
+	GROUP(uart_e_rx,		1),
+	GROUP(uart_e_cts,		1),
+	GROUP(uart_e_rts,		1),
+	GROUP(pwm_e,			1),
+	GROUP(i2c2_sda_x,		1),
+	GROUP(i2c2_scl_x,		1),
+	GROUP(pwm_b_x19,		1),
+
+	/* bank X funsc2 */
+	GROUP(pdm_din0_x,		2),
+	GROUP(pdm_din1_x,		2),
+	GROUP(pdm_din2_x,		2),
+	GROUP(pdm_din3_x,		2),
+	GROUP(pdm_dclk_x,		2),
+	GROUP(mclk_0,			2),
+	GROUP(uart_d_tx_x6,		2),
+	GROUP(uart_d_rx_x7,		2),
+	GROUP(uart_d_rts,		2),
+	GROUP(uart_d_cts,		2),
+	GROUP(uart_d_tx_x10,		2),
+	GROUP(uart_d_rx_x11,		2),
+	GROUP(tdm_d15,			2),
+
+	/* bank X func3 */
+	GROUP(tsin_a_din0_x,		3),
+	GROUP(tsin_a_sop_x,		3),
+	GROUP(tsin_a_valid_x,		3),
+	GROUP(tsin_a_clk_x,		3),
+	GROUP(tsin_d_sop_x,		3),
+	GROUP(tsin_d_valid_x,		3),
+	GROUP(tsin_d_din0_x,		3),
+	GROUP(tsin_d_clk_x,		3),
+
+	/* bank X func4 */
+	GROUP(pwm_d_x3,			4),
+	GROUP(pwm_c_x,			4),
+	GROUP(pwm_d_x6,			4),
+	GROUP(pwm_b_x7,			4),
+	GROUP(spi_a_mosi_x,		4),
+	GROUP(spi_a_miso_x,		4),
+	GROUP(spi_a_ss0_x,		4),
+	GROUP(spi_a_sclk_x,		4),
+
+	/* bank X func5 */
+	GROUP(sdcard_d0_x,		5),
+	GROUP(sdcard_d1_x,		5),
+	GROUP(sdcard_d2_x,		5),
+	GROUP(sdcard_d3_x,		5),
+	GROUP(sdcard_clk_x,		5),
+	GROUP(sdcard_cd_x,		5),
+	GROUP(iso7816_clk_x,		5),
+	GROUP(iso7816_data_x,		5),
+	GROUP(i2c1_sda_x,		5),
+	GROUP(i2c1_scl_x,		5),
+	GROUP(gen_clk_x,		5),
+
+	/* bank H func1 */
+	GROUP(hdmitx_sda,		1),
+	GROUP(hdmitx_sck,		1),
+	GROUP(hdmitx_hpd_in,		1),
+	GROUP(spdif_out_h,		1),
+	GROUP(spdif_in_h,		1),
+	GROUP(iso7816_data_h,		1),
+	GROUP(iso7816_clk_h,		1),
+
+	/* bank H funsc2 */
+	GROUP(i2c3_sda_h,		2),
+	GROUP(i2c3_scl_h,		2),
+	GROUP(i2c1_sda_h2,		2),
+	GROUP(i2c1_scl_h3,		2),
+	GROUP(uart_c_rts,		2),
+	GROUP(uart_c_cts,		2),
+	GROUP(uart_c_rx,		2),
+	GROUP(uart_c_tx,		2),
+
+	/* bank H func3 */
+	GROUP(spi_b_mosi_h,		3),
+	GROUP(spi_b_miso_h,		3),
+	GROUP(spi_b_ss0_h,		3),
+	GROUP(spi_b_sclk_h,		3),
+
+	/* bank H func4 */
+	GROUP(cec_a_h,			4),
+	GROUP(pwm_f_h,			4),
+	GROUP(i2c1_sda_h6,		4),
+	GROUP(i2c1_scl_h7,		4),
+
+	/* bank H func5 */
+	GROUP(cec_b_h,			5),
+	GROUP(tdm_d5,			5),
+	GROUP(remote_out_h,		5),
+	GROUP(pwm_b_h,			5),
+
+	/* bank H func6 */
+	GROUP(i2c0_sda_h,		6),
+	GROUP(i2c0_scl_h,		6),
+
+	/* bank Z func1 */
+	GROUP(eth_mdio,			1),
+	GROUP(eth_mdc,			1),
+	GROUP(eth_rgmii_rx_clk,		1),
+	GROUP(eth_rx_dv,		1),
+	GROUP(eth_rxd0,			1),
+	GROUP(eth_rxd1,			1),
+	GROUP(eth_rxd2_rgmii,		1),
+	GROUP(eth_rxd3_rgmii,		1),
+	GROUP(eth_rgmii_tx_clk,		1),
+	GROUP(eth_txen,			1),
+	GROUP(eth_txd0,			1),
+	GROUP(eth_txd1,			1),
+	GROUP(eth_txd2_rgmii,		1),
+	GROUP(eth_txd3_rgmii,		1),
+	GROUP(eth_link_led,		1),
+	GROUP(eth_act_led,		1),
+
+	/* bank Z funsc2 */
+	GROUP(pwm_d_z,			2),
+	GROUP(clk12_24_z,		2),
+
+	/* bank Z func3 */
+	GROUP(iso7816_clk_z0,		3),
+	GROUP(iso7816_data_z1,		3),
+	GROUP(tsin_b_valid,		3),
+	GROUP(tsin_b_sop,		3),
+	GROUP(tsin_b_din0,		3),
+	GROUP(tsin_b_clk,		3),
+	GROUP(tsin_b_fail,		3),
+	GROUP(tsin_b_din1,		3),
+	GROUP(tsin_b_din2,		3),
+	GROUP(tsin_b_din3,		3),
+	GROUP(tsin_b_din4,		3),
+	GROUP(tsin_b_din5,		3),
+	GROUP(tsin_b_din6,		3),
+	GROUP(tsin_b_din7,		3),
+	GROUP(i2c2_sda_z14,		3),
+	GROUP(i2c2_scl_z15,		3),
+
+	/* bank Z func4 */
+	GROUP(i2c0_sda_z0,		4),
+	GROUP(i2c0_scl_z1,		4),
+	GROUP(tdm_d6,			4),
+	GROUP(tdm_d7,			4),
+	GROUP(tdm_d8,			4),
+	GROUP(tdm_d9,			4),
+	GROUP(tdm_fs2,			4),
+	GROUP(tdm_sclk2,		4),
+	GROUP(mclk_2,			4),
+	GROUP(tdm_d10,			4),
+	GROUP(tdm_d11,			4),
+	GROUP(tdm_d12,			4),
+	GROUP(tdm_d13,			4),
+	GROUP(tdm_d14,			4),
+
+	/* bank Z func5 */
+	GROUP(pwm_b_z0,			5),
+	GROUP(pwm_c_z,			5),
+	GROUP(sdcard_d0_z,		5),
+	GROUP(sdcard_d1_z,		5),
+	GROUP(sdcard_d2_z,		5),
+	GROUP(sdcard_d3_z,		5),
+	GROUP(sdcard_clk_z,		5),
+	GROUP(sdcard_cmd_z,		5),
+	GROUP(iso7816_clk_z8,		5),
+	GROUP(iso7816_data_z9,		5),
+	GROUP(remote_out_z,		5),
+	GROUP(pwm_f_z,			5),
+	GROUP(pwm_b_z13,		5),
+
+	/* bank Z func6 */
+	GROUP(i2c1_sda_z,		6),
+	GROUP(i2c1_scl_z,		6),
+	GROUP(tdm_fs3,			6),
+	GROUP(tdm_sclk3,		6),
+	GROUP(tdm_fs4,			6),
+	GROUP(tdm_sclk4,		6),
+	GROUP(tsin_c_valid_z,		6),
+	GROUP(tsin_c_sop_z,		6),
+	GROUP(tsin_c_din0_z,		6),
+	GROUP(tsin_c_clk_z,		6),
+	GROUP(tsin_d_valid_z,		6),
+	GROUP(tsin_d_sop_z,		6),
+	GROUP(tsin_d_din0_z,		6),
+	GROUP(tsin_d_clk_z,		6),
+
+	/* bank Z func7 */
+	GROUP(pdm_din0_z,		7),
+	GROUP(pdm_din1_z,		7),
+	GROUP(pdm_din2_z,		7),
+	GROUP(pdm_din3_z,		7),
+	GROUP(pdm_dclk_z,		7),
+	GROUP(i2c0_sda_z7,		7),
+	GROUP(i2c0_scl_z8,		7),
+	GROUP(i2c2_sda_z10,		7),
+	GROUP(i2c2_scl_z11,		7),
+	GROUP(gen_clk_z,		7),
+
+	/* bank A func1 */
+	GROUP(remote_input_a,		1),
+	/* bank A func3 */
+	GROUP(i2c3_sda_a,		3),
+	GROUP(i2c3_scl_a,		3),
+	/* bank A func5 */
+	GROUP(pdm_din0_a,		5),
+	GROUP(pdm_dclk_a,		5),
+	/* bank A func7 */
+	GROUP(gen_clk_a,		7),
+
+};
+
+static const char * const gpio_periphs_groups[] = {
+	"GPIO_TEST_N",
+
+	"GPIOD_0", "GPIOD_1", "GPIOD_2", "GPIOD_3", "GPIOD_4",
+	"GPIOD_5", "GPIOD_6", "GPIOD_7", "GPIOD_8", "GPIOD_9",
+	"GPIOD_10", "GPIOD_11", "GPIOD_12",
+
+	"GPIOE_0", "GPIOE_1", "GPIOE_2",
+
+	"GPIOB_0", "GPIOB_1", "GPIOB_2", "GPIOB_3", "GPIOB_4",
+	"GPIOB_5", "GPIOB_6", "GPIOB_7", "GPIOB_8", "GPIOB_9",
+	"GPIOB_10", "GPIOB_11", "GPIOB_12", "GPIOB_13",
+	"GPIOB_14", "GPIOB_15",
+
+	"GPIOC_0", "GPIOC_1", "GPIOC_2", "GPIOC_3", "GPIOC_4",
+	"GPIOC_5", "GPIOC_6", "GPIOC_7",
+
+	"GPIOX_0", "GPIOX_1", "GPIOX_2", "GPIOX_3", "GPIOX_4",
+	"GPIOX_5", "GPIOX_6", "GPIOX_7", "GPIOX_8", "GPIOX_9",
+	"GPIOX_10", "GPIOX_11", "GPIOX_12", "GPIOX_13", "GPIOX_14",
+	"GPIOX_15", "GPIOX_16", "GPIOX_17", "GPIOX_18", "GPIOX_19",
+
+	"GPIOH_0", "GPIOH_1", "GPIOH_2", "GPIOH_3", "GPIOH_4",
+	"GPIOH_5", "GPIOH_6", "GPIOH_7", "GPIOH_8",
+
+	"GPIOZ_0", "GPIOZ_1", "GPIOZ_2", "GPIOZ_3", "GPIOZ_4",
+	"GPIOZ_5", "GPIOZ_6", "GPIOZ_7", "GPIOZ_8", "GPIOZ_9",
+	"GPIOZ_10", "GPIOZ_11", "GPIOZ_12", "GPIOZ_13",
+	"GPIOZ_14", "GPIOZ_15",
+
+	"GPIOA_14", "GPIOA_15",
+};
+
+static const char * const uart_a_groups[] = {
+	"uart_a_cts", "uart_a_rts", "uart_a_tx_d2", "uart_a_rx_d3",
+	"uart_a_tx_d8", "uart_a_rx_d9",
+};
+
+static const char * const uart_b_groups[] = {
+	"uart_b_tx_d", "uart_b_rx_d", "uart_b_cts", "uart_b_rts",
+	"uart_b_rx_c", "uart_b_tx_c",
+};
+
+static const char * const uart_c_groups[] = {
+	"uart_c_rts", "uart_c_cts", "uart_c_tx", "uart_c_rx",
+};
+
+static const char * const uart_d_groups[] = {
+	"uart_d_rts", "uart_d_cts", "uart_d_tx_x6", "uart_d_rx_x7",
+	"uart_d_tx_x10", "uart_d_rx_x11",
+};
+
+static const char * const uart_e_groups[] = {
+	"uart_e_tx", "uart_e_rx", "uart_e_cts", "uart_e_rts",
+};
+
+static const char * const i2c0_groups[] = {
+	"i2c0_scl_c", "i2c0_sda_c", "i2c0_scl_h", "i2c0_sda_h",
+	"i2c0_scl_z1", "i2c0_sda_z0", "i2c0_scl_z8", "i2c0_sda_z7",
+};
+
+static const char * const i2c1_groups[] = {
+	"i2c1_sda_z", "i2c1_scl_z", "i2c1_sda_x", "i2c1_scl_x",
+	"i2c1_sda_h2", "i2c1_scl_h3", "i2c1_sda_h6", "i2c1_scl_h7",
+};
+
+static const char * const i2c2_groups[] = {
+	"i2c2_sda_x", "i2c2_scl_x", "i2c2_sda_z10", "i2c2_scl_z11",
+	"i2c2_sda_z14", "i2c2_scl_z15",
+};
+
+static const char * const i2c3_groups[] = {
+	"i2c3_sda_h", "i2c3_scl_h", "i2c3_sda_a", "i2c3_scl_a",
+};
+
+static const char * const i2c4_groups[] = {
+	"i2c4_sda_d", "i2c4_scl_d", "i2c4_sda_e", "i2c4_scl_e",
+};
+
+static const char * const i2c_slave_groups[] = {
+	"i2c_slave_scl", "i2c_slave_sda",
+};
+
+static const char * const pwm_a_groups[] = {
+	"pwm_a_e", "pwm_a_x",
+};
+
+static const char * const pwm_b_groups[] = {
+	"pwm_b_h", "pwm_b_z0", "pwm_b_z13", "pwm_b_x7",
+	"pwm_b_x19",
+};
+
+static const char * const pwm_c_groups[] = {
+	"pwm_c_c", "pwm_c_x", "pwm_c_z",
+};
+
+static const char * const pwm_d_groups[] = {
+	"pwm_d_z", "pwm_d_x3", "pwm_d_x6",
+};
+
+static const char * const pwm_e_groups[] = {
+	"pwm_e",
+};
+
+static const char * const pwm_f_groups[] = {
+	"pwm_f_x", "pwm_f_h", "pwm_f_z"
+};
+
+static const char * const pwm_g_groups[] = {
+	"pwm_g",
+};
+
+static const char * const pwm_h_groups[] = {
+	"pwm_h",
+};
+
+static const char * const pwm_i_groups[] = {
+	"pwm_i_d4", "pwm_i_d6",
+};
+
+static const char * const pwm_j_groups[] = {
+	"pwm_j_e", "pwm_j_d5", "pwm_j_d10",
+};
+
+static const char * const pwm_i_hiz_groups[] = {
+	"pwm_i_hiz",
+};
+
+static const char * const pwm_g_hiz_groups[] = {
+	"pwm_g_hiz",
+};
+
+static const char * const remote_out_groups[] = {
+	"remote_out_h", "remote_out_z", "remote_out_d4", "remote_out_d9",
+};
+
+static const char * const remote_input_groups[] = {
+	"remote_input_a", "remote_input_d5",
+};
+
+static const char * const jtag_1_groups[] = {
+	"jtag_1_clk", "jtag_1_tms", "jtag_1_tdi", "jtag_1_tdo",
+};
+
+static const char * const jtag_2_groups[] = {
+	"jtag_2_tdo", "jtag_2_tdi", "jtag_2_clk", "jtag_2_tms",
+};
+
+static const char * const gen_clk_groups[] = {
+	"gen_clk_d", "gen_clk_z", "gen_clk_a", "gen_clk_x",
+};
+
+static const char * const clk12_24_groups[] = {
+	"clk12_24_d", "clk12_24_e", "clk12_24_z",
+};
+
+static const char * const clk25_groups[] = {
+	"clk25",
+};
+
+static const char * const clk_32k_in_groups[] = {
+	"clk_32k_in",
+};
+
+static const char * const emmc_groups[] = {
+	"emmc_nand_d0", "emmc_nand_d1", "emmc_nand_d2", "emmc_nand_d3",
+	"emmc_nand_d4", "emmc_nand_d5", "emmc_nand_d6", "emmc_nand_d7",
+	"emmc_clk", "emmc_cmd", "emmc_nand_dqs",
+};
+
+static const char * const nand_groups[] = {
+	"emmc_nand_d0", "emmc_nand_d1", "emmc_nand_d2", "emmc_nand_d3",
+	"emmc_nand_d4", "emmc_nand_d5", "emmc_nand_d6", "emmc_nand_d7",
+	"emmc_nand_dqs", "nand_wen_clk", "nand_ale", "nand_ren_wr",
+	"nand_cle", "nand_ce0", "nand_ce1", "nand_rb0",
+};
+
+static const char * const sdcard_groups[] = {
+	"sdcard_d0_c", "sdcard_d1_c", "sdcard_d2_c", "sdcard_d3_c",
+	"sdcaed_cd_c", "sdcard_clk_c", "sdcard_cmd_c",
+
+	"sdcard_d0_x", "sdcard_d1_x", "sdcard_d2_x", "sdcard_d3_x",
+	"sdcard_clk_x", "sdcard_cmd_x",
+
+	"sdcard_d0_z", "sdcard_d1_z", "sdcard_d2_z", "sdcard_d3_z",
+	"sdcard_clk_z", "sdcard_cmd_z",
+};
+
+static const char * const nor_groups[] = {
+	"nor_hold", "nor_d", "nor_q", "nor_c",
+	"nor_wp", "nor_cs",
+};
+
+static const char * const spi_a_groups[] = {
+	"spi_a_mosi_c", "spi_a_miso_c", "spi_a_ss0_c", "spi_a_sclk_c",
+	"spi_a_mosi_x", "spi_a_miso_x", "spi_a_sclk_x", "spi_a_ss0_x",
+};
+
+static const char * const spi_b_groups[] = {
+	"spi_b_mosi_h", "spi_b_miso_h", "spi_b_ss0_h", "spi_b_sclk_h",
+};
+
+static const char * const pdm_groups[] = {
+	"pdm_din0_c", "pdm_din1_c1", "pdm_din2_c", "pdm_din3_c",
+	"pdm_din1_c7", "pdm_dclk_c",
+
+	"pdm_din0_x", "pdm_din1_x", "pdm_din2_x", "pdm_din3_x",
+	"pdm_dclk_x",
+
+	"pdm_din0_z", "pdm_din1_z", "pdm_din2_z", "pdm_din3_z",
+	"pdm_dclk_z",
+
+	"pdm_din0_a", "pdm_dclk_a",
+
+};
+
+static const char * const sdio_groups[] = {
+	"sdio_d0_x", "sdio_d1_x", "sdio_d2_x", "sdio_d3_x",
+	"sdio_clk_x", "sdio_cmd_x",
+};
+
+static const char * const eth_groups[] = {
+	"eth_mdc", "eth_mdio", "eth_rxd0", "eth_rxd1",
+	"eth_txen", "eth_txd0", "eth_txd1", "eth_rx_dv",
+	"eth_act_led", "eth_link_led", "eth_rxd2_rgmii", "eth_rxd3_rgmii",
+	"eth_txd2_rgmii", "eth_txd3_rgmii", "eth_rgmii_rx_clk",
+	"eth_rgmii_tx_clk",
+};
+
+static const char * const mic_mute_groups[] = {
+	"mic_mute_en", "mic_mute_key",
+};
+
+static const char * const mclk_groups[] = {
+	"mclk1", "mclk_0", "mclk_2",
+};
+
+static const char * const tdm_groups[] = {
+	"tdm_d0", "tdm_d1", "tdm_d2", "tdm_d3",
+	"tdm_d4", "tdm_d5", "tdm_d6", "tdm_d7",
+	"tdm_d8", "tdm_d9", "tdm_d10", "tdm_d11",
+	"tdm_d12", "tdm_d13", "tdm_d14", "tdm_d15",
+	"tdm_fs0", "tdm_fs1", "tdm_fs2", "tdm_fs3",
+	"tdm_fs4", "tdm_sclk0", "tdm_sclk1", "tdm_sclk2",
+	"tdm_sclk3", "tdm_sclk4",
+};
+
+static const char * const tsin_a_groups[] = {
+	"tsin_a_sop_d", "tsin_a_clk_d", "tsin_a_clk_x", "tsin_a_sop_x",
+	"tsin_a_din0_d", "tsin_a_din0_x", "tsin_a_valid_d", "tsin_a_valid_x",
+};
+
+static const char * const tsin_b_groups[] = {
+	"tsin_b_sop", "tsin_b_clk", "tsin_b_din0", "tsin_b_fail",
+	"tsin_b_din1", "tsin_b_din2", "tsin_b_din3", "tsin_b_din4",
+	"tsin_b_din5", "tsin_b_din6", "tsin_b_din7", "tsin_b_valid",
+};
+
+static const char * const tsin_c_groups[] = {
+	"tsin_c_sop_c", "tsin_c_clk_c", "tsin_c_sop_z", "tsin_c_clk_z",
+	"tsin_c_din0_c", "tsin_c_din0_z", "tsin_c_valid_c", "tsin_c_valid_z",
+};
+
+static const char * const tsin_d_groups[] = {
+	"tsin_d_sop_x", "tsin_d_clk_x", "tsin_d_sop_z", "tsin_d_clk_z",
+	"tsin_d_din0_x", "tsin_d_din0_z", "tsin_d_valid_x", "tsin_d_valid_z",
+};
+
+static const char * const cec_a_groups[] = {
+	"cec_a_h", "cec_a_d",
+};
+
+static const char * const cec_b_groups[] = {
+	"cec_b_h", "cec_b_d",
+};
+
+static const char * const spdif_in_groups[] = {
+	"spdif_in_h",
+};
+
+static const char * const spdif_out_groups[] = {
+	"spdif_out_d", "spdif_out_h",
+};
+
+static const char * const pcieck_reqn_groups[] = {
+	"pcieck_reqn",
+};
+
+static const char * const iso7816_groups[] = {
+	"iso7816_clk_c", "iso7816_clk_h", "iso7816_data_c", "iso7816_clk_x",
+	"iso7816_data_x", "iso7816_data_h", "iso7816_clk_z0",
+	"iso7816_clk_z8", "iso7816_data_z1", "is7816_data_z9",
+};
+
+static const char * const hdmitx_groups[] = {
+	"hdmitx_sda", "hdmitx_sck", "hdmitx_hpd_in",
+};
+
+static struct meson_pmx_func meson_sc2_periphs_functions[] = {
+	FUNCTION(gpio_periphs),
+	FUNCTION(uart_a),
+	FUNCTION(uart_b),
+	FUNCTION(uart_c),
+	FUNCTION(uart_d),
+	FUNCTION(uart_e),
+	FUNCTION(i2c0),
+	FUNCTION(i2c1),
+	FUNCTION(i2c2),
+	FUNCTION(i2c3),
+	FUNCTION(i2c4),
+	FUNCTION(i2c_slave),
+	FUNCTION(pwm_a),
+	FUNCTION(pwm_b),
+	FUNCTION(pwm_c),
+	FUNCTION(pwm_d),
+	FUNCTION(pwm_e),
+	FUNCTION(pwm_f),
+	FUNCTION(pwm_g),
+	FUNCTION(pwm_h),
+	FUNCTION(pwm_i),
+	FUNCTION(pwm_j),
+	FUNCTION(pwm_i_hiz),
+	FUNCTION(pwm_g_hiz),
+	FUNCTION(remote_out),
+	FUNCTION(remote_input),
+	FUNCTION(jtag_1),
+	FUNCTION(jtag_2),
+	FUNCTION(gen_clk),
+	FUNCTION(clk12_24),
+	FUNCTION(clk25),
+	FUNCTION(clk_32k_in),
+	FUNCTION(emmc),
+	FUNCTION(nand),
+	FUNCTION(nor),
+	FUNCTION(sdcard),
+	FUNCTION(spi_a),
+	FUNCTION(spi_b),
+	FUNCTION(pdm),
+	FUNCTION(sdio),
+	FUNCTION(eth),
+	FUNCTION(mic_mute),
+	FUNCTION(mclk),
+	FUNCTION(tdm),
+	FUNCTION(tsin_a),
+	FUNCTION(tsin_b),
+	FUNCTION(tsin_c),
+	FUNCTION(tsin_d),
+	FUNCTION(cec_a),
+	FUNCTION(cec_b),
+	FUNCTION(spdif_in),
+	FUNCTION(spdif_out),
+	FUNCTION(pcieck_reqn),
+	FUNCTION(iso7816),
+	FUNCTION(hdmitx),
+};
+
+static struct meson_bank meson_sc2_periphs_banks[] = {
+	/* name  first  last  irq  pullen  pull  dir  out  in */
+	BANK_DS("Z", GPIOZ_0,    GPIOZ_15,  70, 85,
+		0x3,   0,  0x4,  0,   0x2,  0,  0x1,  0,  0x0,  0, 0x07, 0),
+	BANK_DS("X", GPIOX_0,    GPIOX_19,  50, 69,
+		0x13,  0,  0x14,  0,  0x12, 0,  0x11, 0,  0x10, 0, 0x17, 0),
+	BANK_DS("H", GPIOH_0,    GPIOH_8,   41, 49,
+		0x23,  0,  0x24,  0,  0x22, 0,  0x21, 0,  0x20, 0, 0x27, 0),
+	BANK_DS("D", GPIOD_0,    GPIOD_11,  29, 49,
+		0x33,  0,  0x34,  0,  0x32, 0,  0x31, 0,  0x30, 0, 0x37, 0),
+	BANK_DS("E", GPIOE_0,    GPIOE_2,   26, 28,
+		0x43,  0,  0x44,  0,  0x42, 0,  0x41, 0,  0x40, 0, 0x47, 0),
+	BANK_DS("C", GPIOC_0,    GPIOC_7,   18, 25,
+		0x53,  0,  0x54,  0,  0x52, 0,  0x51, 0,  0x50, 0, 0x57, 0),
+	BANK_DS("B", GPIOB_0,    GPIOB_15,   2, 17,
+		0x63,  0,  0x64,  0,  0x62, 0,  0x61, 0,  0x60, 0, 0x67, 0),
+	BANK_DS("A", GPIOA_14,   GPIOA_15,   0, 1,
+		0x73, 14,  0x74,  14, 0x72, 14, 0x71, 14, 0x70, 14, 0x77, 28),
+	BANK_DS("TEST_N", GPIO_TEST_N,    GPIO_TEST_N,   86, 86,
+		0x83,  0,  0x84,  0,  0x82, 0,  0x81,  0, 0x80, 0, 0x87, 0),
+};
+
+static struct meson_pmx_bank meson_sc2_periphs_pmx_banks[] = {
+	/*name	            first	 lask        reg offset*/
+	BANK_PMX("Z",      GPIOZ_0,     GPIOZ_15,    0x6, 0),
+	BANK_PMX("X",      GPIOX_0,     GPIOX_19,    0x3, 0),
+	BANK_PMX("H",      GPIOH_0,     GPIOH_8,     0xb, 0),
+	BANK_PMX("D",      GPIOD_0,     GPIOD_11,    0x10, 0),
+	BANK_PMX("E",      GPIOE_0,     GPIOE_2,     0x12, 0),
+	BANK_PMX("C",      GPIOC_0,     GPIOC_7,     0x9, 0),
+	BANK_PMX("B",      GPIOB_0,     GPIOB_15,    0x0, 0),
+	BANK_PMX("A",      GPIOA_14,    GPIOA_15,    0xe, 24),
+	BANK_PMX("TEST_N", GPIO_TEST_N, GPIO_TEST_N, 0xf, 0),
+};
+
+static struct meson_axg_pmx_data meson_sc2_periphs_pmx_banks_data = {
+	.pmx_banks	= meson_sc2_periphs_pmx_banks,
+	.num_pmx_banks	= ARRAY_SIZE(meson_sc2_periphs_pmx_banks),
+};
+
+static struct meson_pinctrl_data meson_sc2_periphs_pinctrl_data __refdata = {
+	.name		= "periphs-banks",
+	.pins		= meson_sc2_periphs_pins,
+	.groups		= meson_sc2_periphs_groups,
+	.funcs		= meson_sc2_periphs_functions,
+	.banks		= meson_sc2_periphs_banks,
+	.num_pins	= ARRAY_SIZE(meson_sc2_periphs_pins),
+	.num_groups	= ARRAY_SIZE(meson_sc2_periphs_groups),
+	.num_funcs	= ARRAY_SIZE(meson_sc2_periphs_functions),
+	.num_banks	= ARRAY_SIZE(meson_sc2_periphs_banks),
+	.pmx_ops	= &meson_axg_pmx_ops,
+	.pmx_data	= &meson_sc2_periphs_pmx_banks_data,
+	.parse_dt	= &meson_a1_parse_dt_extra,
+};
+
+static const struct of_device_id meson_sc2_pinctrl_dt_match[] = {
+	{
+		.compatible = "amlogic,meson-sc2-periphs-pinctrl",
+		.data = &meson_sc2_periphs_pinctrl_data,
+	},
+	{ },
+};
+
+static struct platform_driver meson_sc2_pinctrl_driver = {
+	.probe  = meson_pinctrl_probe,
+	.driver = {
+		.name	= "meson-sc2-pinctrl",
+		.of_match_table = meson_sc2_pinctrl_dt_match,
+	},
+};
+
+module_platform_driver(meson_sc2_pinctrl_driver);
+MODULE_LICENSE("Dual BSD/GPL");
--
2.43.0.windows.1


From ec3cd83e7a9927f54da8e01ae061ae440994a5db Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:39:44 +0200
Subject: [PATCH 17/26] dt-bindings: gpio: Add a header file for Amlogic Meson
 SC2 Add a new dt-binding header file which documents the detail pin names.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 include/dt-bindings/gpio/meson-sc2-gpio.h | 104 ++++++++++++++++++++++
 1 file changed, 104 insertions(+)
 create mode 100644 include/dt-bindings/gpio/meson-sc2-gpio.h

diff --git a/include/dt-bindings/gpio/meson-sc2-gpio.h b/include/dt-bindings/gpio/meson-sc2-gpio.h
new file mode 100644
index 000000000..e0ccc1f0b
--- /dev/null
+++ b/include/dt-bindings/gpio/meson-sc2-gpio.h
@@ -0,0 +1,104 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _DT_BINDINGS_MESON_SC2_GPIO_H
+#define _DT_BINDINGS_MESON_SC2_GPIO_H
+#define	GPIOA_14	0
+#define	GPIOA_15	1
+
+#define	GPIOB_0		2
+#define	GPIOB_1		3
+#define	GPIOB_2		4
+#define	GPIOB_3		5
+#define	GPIOB_4		6
+#define	GPIOB_5		7
+#define	GPIOB_6		8
+#define	GPIOB_7		9
+#define	GPIOB_8		10
+#define	GPIOB_9		11
+#define	GPIOB_10	12
+#define	GPIOB_11	13
+#define	GPIOB_12	14
+#define	GPIOB_13	15
+#define	GPIOB_14	16
+#define	GPIOB_15	17
+
+#define	GPIOC_0		18
+#define	GPIOC_1		19
+#define	GPIOC_2		20
+#define	GPIOC_3		21
+#define	GPIOC_4		22
+#define	GPIOC_5		23
+#define	GPIOC_6		24
+#define	GPIOC_7		25
+
+#define	GPIOE_0		26
+#define	GPIOE_1		27
+#define	GPIOE_2		28
+
+#define	GPIOD_0		29
+#define	GPIOD_1		30
+#define	GPIOD_2		31
+#define	GPIOD_3		32
+#define	GPIOD_4		33
+#define	GPIOD_5		34
+#define	GPIOD_6		35
+#define	GPIOD_7		36
+#define	GPIOD_8		37
+#define	GPIOD_9		38
+#define	GPIOD_10	39
+#define	GPIOD_11	40
+
+#define	GPIOH_0		41
+#define	GPIOH_1		42
+#define	GPIOH_2		43
+#define	GPIOH_3		44
+#define	GPIOH_4		45
+#define	GPIOH_5		46
+#define	GPIOH_6		47
+#define	GPIOH_7		48
+#define	GPIOH_8		49
+
+#define	GPIOX_0		50
+#define	GPIOX_1		51
+#define	GPIOX_2		52
+#define	GPIOX_3		53
+#define	GPIOX_4		54
+#define	GPIOX_5		55
+#define	GPIOX_6		56
+#define	GPIOX_7		57
+#define	GPIOX_8		58
+#define	GPIOX_9		59
+#define	GPIOX_10	60
+#define	GPIOX_11	61
+#define	GPIOX_12	62
+#define	GPIOX_13	63
+#define	GPIOX_14	64
+#define	GPIOX_15	65
+#define	GPIOX_16	66
+#define	GPIOX_17	67
+#define	GPIOX_18	68
+#define	GPIOX_19	69
+
+#define	GPIOZ_0		70
+#define	GPIOZ_1		71
+#define	GPIOZ_2		72
+#define	GPIOZ_3		73
+#define	GPIOZ_4		74
+#define	GPIOZ_5		75
+#define	GPIOZ_6		76
+#define	GPIOZ_7		77
+#define	GPIOZ_8		78
+#define	GPIOZ_9		79
+#define	GPIOZ_10	80
+#define	GPIOZ_11	81
+#define	GPIOZ_12	82
+#define	GPIOZ_13	83
+#define	GPIOZ_14	84
+#define	GPIOZ_15	85
+
+#define	GPIO_TEST_N	86
+#endif /* _DT_BINDINGS_MESON_SC2_GPIO_H */
+
--
2.43.0.windows.1


From 3d28317d9e039deeacd5d069c527387dee594ab9 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:40:29 +0200
Subject: [PATCH 18/26] dt-bindings: pwm: Add binding for Amlogic SoCs This
 adds definitions of the PWM controllers on Amlogic SoCs.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 include/dt-bindings/pwm/meson.h | 63 +++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)
 create mode 100644 include/dt-bindings/pwm/meson.h

diff --git a/include/dt-bindings/pwm/meson.h b/include/dt-bindings/pwm/meson.h
new file mode 100644
index 000000000..6fe58e953
--- /dev/null
+++ b/include/dt-bindings/pwm/meson.h
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+
+/*
+
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+
+ */
+
+
+
+
+#ifndef _DT_BINDINGS_PWM_MESON_H
+
+#define _DT_BINDINGS_PWM_MESON_H
+
+
+
+
+/*defination for meson pwm channel index
+
+ *	for example:
+
+ *	1.there are four pwm controllers for axg:
+
+ *	pwm A/B ,pwm C/D, pwm AOA/AOB, pwm AOC/AOD.
+
+ *	each controller has four pwm channels:
+
+ *	MESON_PWM_0,MESON_PWM_1,MESON_PWM_2,MESON_PWM_3
+
+ *	when double pwm channels used, pwm channel
+
+ *	[ MESON_PWM_0 and MESON_PWM_2 ],
+
+ *	[ MESON_PWM_1 and MESON_PWM_3 ],
+
+ *	should be used together.
+
+ *
+
+ *	2.there are two three pwm controllers for m8b:
+
+ *	pwm A/B,pwm C/D,pwm E/F.
+
+ *	each controllere has two pwm channels:
+
+ *	MESON_PWM_0 and MESON_PWM_1.
+
+ */
+
+#define		MESON_PWM_0  0
+
+#define		MESON_PWM_1  1
+
+#define		MESON_PWM_2  2
+
+#define		MESON_PWM_3  3
+
+
+
+
+#endif
+
--
2.43.0.windows.1


From 34f19efa4a5ec94f744087b8c84f7dcae9492644 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:46:19 +0200
Subject: [PATCH 19/26] pwm: meson: Add support for the modified S4 pwm Add
 support for the modified pwm introduced with the S4 platform. Logic is copied
 from the vendor driver and was tested on a system with SC2 platform.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/pwm/pwm-meson.c | 36 +++++++++++++++++++++++++++++++++++-
 1 file changed, 35 insertions(+), 1 deletion(-)

diff --git a/drivers/pwm/pwm-meson.c b/drivers/pwm/pwm-meson.c
index 33107204a..7c97c5be8 100644
--- a/drivers/pwm/pwm-meson.c
+++ b/drivers/pwm/pwm-meson.c
@@ -62,6 +62,8 @@

 #define MESON_NUM_PWMS		2

+#define XTAL_RATE 24000000
+
 static struct meson_pwm_channel_data {
 	u8		reg_offset;
 	u8		clk_sel_shift;
@@ -98,6 +100,7 @@ struct meson_pwm_channel {
 struct meson_pwm_data {
 	const char * const *parent_names;
 	unsigned int num_parents;
+	unsigned int nomux:1;
 };

 struct meson_pwm {
@@ -124,7 +127,13 @@ static int meson_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
 	struct device *dev = chip->dev;
 	int err;

-	if (channel->clk_parent) {
+	if (meson->data->nomux) {
+		err = clk_set_rate(channel->clk, XTAL_RATE);
+		if (err) {
+			dev_err(dev, "failed to set pwm clock rate\n");
+			return err;
+		}
+	} else if (channel->clk_parent) {
 		err = clk_set_parent(channel->clk, channel->clk_parent);
 		if (err < 0) {
 			dev_err(dev, "failed to set parent %s for %s: %d\n",
@@ -228,6 +237,7 @@ static void meson_pwm_enable(struct meson_pwm *meson, struct pwm_device *pwm)
 	struct meson_pwm_channel_data *channel_data;
 	unsigned long flags;
 	u32 value;
+	int err;

 	channel_data = &meson_pwm_per_channel_data[pwm->hwpwm];

@@ -248,6 +258,12 @@ static void meson_pwm_enable(struct meson_pwm *meson, struct pwm_device *pwm)
 	writel(value, meson->base + REG_MISC_AB);

 	spin_unlock_irqrestore(&meson->lock, flags);
+
+	if (meson->data->nomux) {
+		err = clk_set_rate(channel->clk, XTAL_RATE / (channel->pre_div + 1));
+		if (err)
+			dev_err(meson->chip.dev, "failed to set pwm clock rate\n");
+	}
 }

 static void meson_pwm_disable(struct meson_pwm *meson, struct pwm_device *pwm)
@@ -443,6 +459,10 @@ static const struct meson_pwm_data pwm_g12a_ee_data = {
 	.num_parents = ARRAY_SIZE(pwm_g12a_ee_parent_names),
 };

+static const struct meson_pwm_data pwm_s4_data = {
+	.nomux = 1,
+};
+
 static const struct of_device_id meson_pwm_matches[] = {
 	{
 		.compatible = "amlogic,meson8b-pwm",
@@ -476,6 +496,10 @@ static const struct of_device_id meson_pwm_matches[] = {
 		.compatible = "amlogic,meson-g12a-ao-pwm-cd",
 		.data = &pwm_g12a_ao_cd_data
 	},
+	{
+		.compatible = "amlogic,meson-s4-pwm",
+		.data = &pwm_s4_data
+	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, meson_pwm_matches);
@@ -491,6 +515,16 @@ static int meson_pwm_init_channels(struct meson_pwm *meson)
 	for (i = 0; i < meson->chip.npwm; i++) {
 		struct meson_pwm_channel *channel = &meson->channels[i];

+		if (meson->data->nomux) {
+			snprintf(name, sizeof(name), "clkin%u", i);
+			channel->clk = devm_clk_get(dev, name);
+			if (IS_ERR(channel->clk)) {
+				dev_err(dev, "can't get pwm clock: %pe\n", channel->clk);
+				return PTR_ERR(channel->clk);
+			}
+			continue;
+		}
+
 		snprintf(name, sizeof(name), "%s#mux%u", dev_name(dev), i);

 		init.name = name;
--
2.43.0.windows.1


From c4263611f694967dc36e2364e30a75ff7a7445b6 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:47:25 +0200
Subject: [PATCH 20/26] dt-bindings: pwm: Add binding for Amlogic meson S4
 platform This adds support for the PWM found on S4 and later platforms.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 Documentation/devicetree/bindings/pwm/pwm-meson.txt | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Documentation/devicetree/bindings/pwm/pwm-meson.txt b/Documentation/devicetree/bindings/pwm/pwm-meson.txt
index bd02b0a14..0fbedf200 100644
--- a/Documentation/devicetree/bindings/pwm/pwm-meson.txt
+++ b/Documentation/devicetree/bindings/pwm/pwm-meson.txt
@@ -10,6 +10,7 @@ Required properties:
                          or "amlogic,meson-g12a-ee-pwm"
                          or "amlogic,meson-g12a-ao-pwm-ab"
                          or "amlogic,meson-g12a-ao-pwm-cd"
+                         or "amlogic,meson-s4-pwm"
 - #pwm-cells: Should be 3. See pwm.yaml in this directory for a description of
   the cells format.

--
2.43.0.windows.1


From 9286b6dd27b4c03ce9594234618201241bcbb8e5 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 17:48:07 +0200
Subject: [PATCH 21/26] dt-bindings: reset: add bindings for the Meson-SC2 SoC
 Reset Controller Add DT bindings for the Meson-SC2 SoC Reset Controller
 include file.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 .../reset/amlogic,meson-sc2-reset.h           | 110 ++++++++++++++++++
 1 file changed, 110 insertions(+)
 create mode 100644 include/dt-bindings/reset/amlogic,meson-sc2-reset.h

diff --git a/include/dt-bindings/reset/amlogic,meson-sc2-reset.h b/include/dt-bindings/reset/amlogic,meson-sc2-reset.h
new file mode 100644
index 000000000..0be554e6f
--- /dev/null
+++ b/include/dt-bindings/reset/amlogic,meson-sc2-reset.h
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _DT_BINDINGS_AMLOGIC_MESON_SC2_RESET_H
+#define _DT_BINDINGS_AMLOGIC_MESON_SC2_RESET_H
+
+/* RESET0 */
+#define RESET_USB_DDR0			0
+#define RESET_USB_DDR1			1
+#define RESET_USB_DDR2			2
+#define RESET_USB_DDR3			3
+#define RESET_USBCTRL			4
+#define RESET_USBPHY20			8
+#define RESET_USBPHY21			9
+#define RESET_HDMITX_APB		16
+#define	RESET_BRG_VCBUS_DEC		17
+#define RESET_VCBUS			18
+#define RESET_VID_PLL_DIV		19
+#define RESET_VDI6			20
+#define RESET_GE2D			21
+#define	RESET_HDMITXPHY			22
+#define	RESET_VID_LOCK			23
+#define	RESET_VENCL			24
+#define	RESET_VDAC			25
+#define	RESET_VENCP			26
+#define RESET_VENCI			27
+#define	RESET_RDMA			28
+#define	RESET_HDMI_TX			29
+#define	RESET_VIU			30
+#define	RESET_VENC			31
+
+/* RESET1 */
+#define RESET_AUDIO			32
+#define	RESET_MALI_APB			33
+#define	RESET_MALI			34
+#define RESET_DDR_APB			35
+#define	RESET_DDR			36
+#define	RESET_DOS_APB			37
+#define	RESET_DOS			38
+#define RESET_DSPA_DEBUG		41
+#define	RESET_DSPA			43
+#define	RESET_PCIE_CTRL			44
+#define	RESET_PCIE_PHY			45
+#define	RESET_PCIE_APB			46
+#define	RESET_ETH			48
+
+/* RESET2 */
+#define RESET_ABUS_ARB			64
+#define RESET_IR_CTRL			65
+#define RESET_TEMPSENSOR_DDR		66
+#define RESET_TEMPSENSOR_PLL		67
+#define RESET_SMART_CARD		72
+#define RESET_SPICC0			73
+#define RESET_SPICC1			74
+#define RESET_RSA			75
+#define RESET_MSR_CLK			80
+#define RESET_SPIFC			81
+#define RESET_SARADC			82
+#define RESET_ACODEC			88
+#define RESET_CEC			89
+#define RESET_AFIFO			90
+#define RESET_WATCHDOG			91
+
+/* RESET3 */
+/* 96 ~ 127 */
+
+/* RESET4 */
+#define RESET_PWM_AB			132
+#define RESET_PWM_CD			133
+#define RESET_PWM_EF			134
+#define RESET_PWM_GH			135
+#define RESET_PWM_IJ			136
+#define RESET_UART_A			138
+#define RESET_UART_B			139
+#define RESET_UART_C			140
+#define RESET_UART_D			141
+#define RESET_UART_E			142
+#define RESET_I2C_S_A			144
+#define RESET_I2C_M_A			145
+#define RESET_I2C_M_B			146
+#define RESET_I2C_M_C			147
+#define RESET_I2C_M_D			148
+#define RESET_I2C_M_E			149
+#define RESET_I2C_M_F			150
+#define RESET_SD_EMMC_A			152
+#define RESET_SD_EMMC_B			153
+#define RESET_NAND_EMMC			154
+
+/* RESET5 */
+#define RESET_BRG_VDEC_PIPL0		160
+#define RESET_BRG_HEVCF_PIPL0		161
+#define RESET_BRG_HCODEC_PIPL0		163
+#define RESET_BRG_GE2D_PIPL0		164
+#define RESET_BRG_VPU_PIPL0		165
+#define RESET_BRG_CPU_PIPL0		166
+#define RESET_BRG_MALI_PIPL0		167
+#define RESET_BRG_MALI_PIPL1		169
+#define RESET_BRG_HEVCF_PIPL1		172
+#define RESET_BRG_HEVCB_PIPL1		173
+#define RESET_BRG_NIC_DSPA		186
+#define RESET_BRG_NIC_VAPB		187
+#define RESET_BRG_NIC_DSU		188
+#define RESET_BRG_NIC_SYSCLK		189
+#define RESET_BRG_NIC_MAIN		190
+#define RESET_BRG_NIC_ALL		191
+
+#endif
+
--
2.43.0.windows.1


From c28a1d31eb849ace7ec4013018fc87c646b39099 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 18:02:32 +0200
Subject: [PATCH 22/26] add basic DT support for SC2 AH212 board(s)
 Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>

---
 arch/arm64/boot/dts/amlogic/Makefile          |    3 +-
 .../meson-sc2-s905x4-ah212-gbit-2g.dts        |  552 ++++++
 .../dts/amlogic/meson-sc2-s905x4-ah212.dts    |  420 +++++
 arch/arm64/boot/dts/amlogic/meson-sc2.dtsi    | 1514 +++++++++++++++++
 .../boot/dts/amlogic/mesong12a-bifrost.dtsi   |  109 ++
 5 files changed, 2597 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212-gbit-2g.dts
 create mode 100644 arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212.dts
 create mode 100644 arch/arm64/boot/dts/amlogic/meson-sc2.dtsi
 create mode 100644 arch/arm64/boot/dts/amlogic/mesong12a-bifrost.dtsi

diff --git a/arch/arm64/boot/dts/amlogic/Makefile b/arch/arm64/boot/dts/amlogic/Makefile
index 3c19f7e1e..93dd2c8b3 100644
--- a/arch/arm64/boot/dts/amlogic/Makefile
+++ b/arch/arm64/boot/dts/amlogic/Makefile
@@ -130,5 +130,6 @@ dtb-$(CONFIG_ARCH_MESON) += meson-sm1-x96-max-plus-oc.dtb
 dtb-$(CONFIG_ARCH_MESON) += meson-sm1-x96-max-plus-q1.dtb
 dtb-$(CONFIG_ARCH_MESON) += meson-sm1-x96-max-plus-q2.dtb
 dtb-$(CONFIG_ARCH_MESON) += meson-sm1-x96-max-plus-2101.dtb
-
+dtb-$(CONFIG_ARCH_MESON) += meson-sc2-s905x4-ah212.dtb
+dtb-$(CONFIG_ARCH_MESON) += meson-sc2-s905x4-ah212-gbit-2g.dtb
 subdir-y       := $(dts-dirs) overlay
diff --git a/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212-gbit-2g.dts b/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212-gbit-2g.dts
new file mode 100644
index 000000000..2db2113b6
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212-gbit-2g.dts
@@ -0,0 +1,552 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include "meson-sc2.dtsi"
+
+/ {
+	model = "Amlogic SC2 AH212 ";
+	compatible = "amlogic,sc2";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart_B;
+		serial1 = &uart_E;
+		serial2 = &uart_C;
+		serial3 = &uart_D;
+		serial4 = &uart_A;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		spi1 = &spicc0;
+		spi2 = &spicc1;
+	};
+
+	memory {
+		device_type = "memory";
+		linux,usable-memory = <0x0 0x000000 0x0 0x80000000>;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	emmc_pwrseq: emmc-pwrseq {
+		compatible = "mmc-pwrseq-emmc";
+		reset-gpios = <&gpio GPIOB_12 GPIO_ACTIVE_LOW>;
+	};
+
+	wifi32k: wifi32k {
+		compatible = "pwm-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		pwms = <&pwm_ef 0 30518 0>; /* PWM_E at 32.768KHz */
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpio GPIOX_6 GPIO_ACTIVE_LOW>;
+		clocks = <&wifi32k>;
+		clock-names = "ext_clock";
+	};
+
+	vdd_3v3: regulator-vdd_3v3 {
+                compatible = "regulator-fixed";
+                regulator-name = "VDD_3V3";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+        };
+
+	vdd_1v8: regulator-vdd_1v8 {
+                compatible = "regulator-fixed";
+                regulator-name = "VDD_1V8";
+                regulator-min-microvolt = <1800000>;
+                regulator-max-microvolt = <1800000>;
+        };
+
+	vbus_pwr: regulator-vbus_pwr {
+		compatible = "regulator-fixed";
+		regulator-name = "VBUS_PWR";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+//		vin-supply = <&vcc_5v>;
+
+		gpio = <&gpio GPIOH_6 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* 16 MiB reserved for Hardware ROM Firmware */
+		hwrom_reserved: hwrom@0 {
+			reg = <0x0 0x0 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* Reserved for ARM Trusted Firmware (BL31) */
+		secmon_reserved1: secmon@10000000 {
+			reg = <0x0 0x10000000 0x0 0x200000>;
+			no-map;
+		};
+
+		/* Reserved for ARM Trusted Firmware (BL31) */
+		secmon_reserved2: secmon@5000000 {
+			reg = <0x0 0x05000000 0x0 0x3400000>;
+			no-map;
+		};
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0xbc00000>;
+			alignment = <0x0 0x400000>;
+			linux,cma-default;
+		};
+
+	};
+
+	cpu_opp_table0: cpu_opp_table0 {
+		compatible = "operating-points-v2";
+		status = "okay";
+		opp-shared;
+
+		opp00 {
+			opp-hz = /bits/ 64 <100000000>;
+			opp-microvolt = <779000>;
+		};
+		opp01 {
+			opp-hz = /bits/ 64 <250000000>;
+			opp-microvolt = <779000>;
+		};
+		opp02 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <779000>;
+		};
+		opp03 {
+			opp-hz = /bits/ 64 <667000000>;
+			opp-microvolt = <799000>;
+		};
+		opp04 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-microvolt = <799000>;
+		};
+		opp05 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <809000>;
+		};
+		opp06 {
+			opp-hz = /bits/ 64 <1404000000>;
+			opp-microvolt = <839000>;
+		};
+		opp07 {
+			opp-hz = /bits/ 64 <1500000000>;
+			opp-microvolt = <849000>;
+		};
+		opp08 {
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <879000>;
+		};
+		opp09 {
+			opp-hz = /bits/ 64 <1704000000>;
+			opp-microvolt = <919000>;
+		};
+		opp10 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <959000>;
+		};
+		opp11 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <989000>;
+		};
+		opp12 {
+			opp-hz = /bits/ 64 <2004000000>;
+			opp-microvolt = <1019000>;
+		};
+	};
+
+	cpufreq-meson {
+		compatible = "amlogic,cpufreq-meson";
+		status = "okay";
+	};
+
+	i2c-led {
+		compatible = "i2c-gpio";
+		sda-gpios = <&gpio GPIOA_14 GPIO_ACTIVE_HIGH>;
+		i2c-gpio,sda-output-only;
+		scl-gpios = <&gpio GPIOA_15 GPIO_ACTIVE_HIGH>;
+		i2c-gpio,scl-output-only;
+		i2c-gpio,delay-us = <5>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		disp_7seg@24 {
+			compatible = "fudahisi,fd6551";
+			reg = <0x24>, <0x37>, <0x36>, <0x35>, <0x34>, <0x33>;
+			reg-names = "cmd", "grid_0", "grid_1", "grid_2", "grid_3", "symbols";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			fudahisi,segment-mapping = /bits/ 8 <0 1 2 3 4 5 6>;
+
+			led@0 {
+				reg = <0>;
+				function = LED_FUNCTION_ALARM;
+			};
+
+			led@1 {
+				reg = <1>;
+				function = LED_FUNCTION_USB;
+			};
+
+			led@2 {
+				reg = <2>;
+				function = "pause";
+			};
+
+			led@3 {
+				reg = <3>;
+				function = "play";
+			};
+
+			led@4 {
+				reg = <4>;
+				function = "colon";
+			};
+
+			led@5 {
+				reg = <5>;
+				function = LED_FUNCTION_LAN;
+			};
+
+			led@6 {
+				reg = <6>;
+				function = LED_FUNCTION_WLAN;
+			};
+		};
+	};
+};
+
+&pwm_ij {
+	status = "okay";
+};
+
+&i2c2 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&i2c2_pins3>;
+	clock-frequency = <300000>;
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&i2c3_pins2>;
+	clock-frequency = <300000>; /* default 100k */
+};
+
+&vddcpu0 {
+	status = "okay";
+};
+
+&periphs_pinctrl {
+
+/*****/
+	eth_pins: eth {
+		mux {
+			groups = "eth_mdio",
+				 "eth_mdc",
+				 "eth_rgmii_rx_clk",
+				 "eth_rx_dv",
+				 "eth_rxd0",
+				 "eth_rxd1",
+				 "eth_txen",
+				 "eth_txd0",
+				 "eth_txd1";
+			function = "eth";
+			drive-strength-microamp = <4000>;
+			bias-disable;
+		};
+	};
+
+	eth_rgmii_pins: eth-rgmii {
+		mux {
+			groups = "eth_rxd2_rgmii",
+				 "eth_rxd3_rgmii",
+				 "eth_rgmii_tx_clk",
+				 "eth_txd2_rgmii",
+				 "eth_txd3_rgmii";
+			function = "eth";
+			drive-strength-microamp = <4000>;
+			bias-disable;
+		};
+	};
+/*****/
+
+	tdm_a: tdm_a {
+		mux { /* GPIOX_11, GPIOX_10, GPIOX_8, GPIOX_9 */
+			groups = "tdm_sclk0",
+				"tdm_fs0",
+				"tdm_d3",
+				"tdm_d4";
+			function = "tdm";
+		};
+	};
+
+	tdmin_a: tdmin_a {
+		mux { /* GPIOX_8 */
+			groups = "tdma_din1";
+			function = "tdma_in";
+		};
+	};
+
+	tdmb_mclk: tdmb_mclk {
+		mux {
+			groups = "mclk0_a";
+			function = "mclk0";
+		};
+	};
+	tdmout_b: tdmout_b {
+		mux { /* GPIOA_1, GPIOA_2, GPIOA_3 */
+			groups = "tdmb_sclk",
+				"tdmb_fs",
+				"tdmb_dout0";
+			function = "tdmb_out";
+		};
+	};
+
+	tdmin_b:tdmin_b {
+		mux { /* GPIOA_4 */
+			groups = "tdmb_din1"
+				/*,"tdmb_slv_sclk", "tdmb_slv_fs"*/;
+			function = "tdmb_in";
+		};
+	};
+
+	tdmc_mclk: tdmc_mclk {
+		mux { /* GPIOA_11 */
+			groups = "mclk1_a";
+			function = "mclk1";
+		};
+	};
+
+	tdmout_c:tdmout_c {
+		mux { /* GPIOA_12, GPIOA_13 */
+			groups = "tdmc_sclk_a",
+				"tdmc_fs_a"
+				/*, "tdmc_dout0_a"
+				 *,	"tdmc_dout2"
+				 *, "tdmc_dout3"
+				 */;
+			function = "tdmc_out";
+		};
+	};
+
+	tdmin_c:tdmin_c {
+		mux { /* GPIOA_10 */
+			groups = "tdmc_din0_a";
+			function = "tdmc_in";
+		};
+	};
+
+	spdifin: spdifin {
+		mux {/* GPIOH_5 */
+			groups = "spdif_in_h";
+			function = "spdif_in";
+		};
+	};
+
+	pdmin: pdmin {
+		mux { /* GPIOC_0, GPIOC_4 */
+			groups = "pdm_din0_c",
+				"pdm_dclk_c";
+			function = "pdm";
+		};
+	};
+
+	spdifout: spdifout {
+		mux { /* GPIOD_10 */
+			groups = "spdif_out_d";
+			function = "spdif_out";
+		};
+	};
+
+	spdifout_a_mute: spdifout_a_mute {
+		mux { /* GPIOD_10 */
+			groups = "GPIOD_10";
+			function = "gpio_periphs";
+			output-low;
+		};
+	};
+
+	dvb_s_ts0_pins: dvb_s_ts0_pins {
+		tsin_a {
+			groups = "tsin_a_sop_d",
+				"tsin_a_valid_d",
+				"tsin_a_clk_d",
+				"tsin_a_din0_d";
+			function = "tsin_a";
+		};
+	};
+
+	dvb_s_ts1_pins: dvb_s_ts1_pins {
+		tsin_b {
+			groups = "tsin_b_sop",
+				"tsin_b_valid",
+				"tsin_b_clk",
+				"tsin_b_din0";
+			function = "tsin_b";
+		};
+	};
+
+	dvb_s_ts2_pins: dvb_s_ts2_pins {
+		tsin_c {
+			groups = "tsin_c_sop_z",
+				"tsin_c_valid_z",
+				"tsin_c_clk_z",
+				"tsin_c_din0_z";
+			function = "tsin_c";
+		};
+	};
+
+	dvb_s_ts3_pins: dvb_s_ts3_pins {
+		tsin_d {
+			groups = "tsin_d_sop_z",
+				"tsin_d_valid_z",
+				"tsin_d_clk_z",
+				"tsin_d_din0_z";
+			function = "tsin_d";
+		};
+	};
+}; /* end of periphs_pinctrl */
+
+&usb {
+	status = "okay";
+};
+
+/* SDIO */
+&sd_emmc_a {
+	status = "okay";
+	pinctrl-0 = <&sdio_pins>;
+	pinctrl-1 = <&sdio_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	max-frequency = <200000000>;
+
+	non-removable;
+	disable-wp;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+	vmmc-supply = <&vdd_3v3>;
+	vqmmc-supply = <&vdd_1v8>;
+};
+
+/* SD card */
+&sd_emmc_b {
+	status = "okay";
+	pinctrl-0 = <&sdcard_pins>;
+	pinctrl-1 = <&sdcard_clk_gate_pins>;
+	pinctrl-names = "sd_default", "clk-gate";
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	max-frequency = <200000000>;
+	disable-wp;
+
+	cd-gpios = <&gpio GPIOC_6 GPIO_ACTIVE_HIGH>;
+	cd-inverted;
+	vmmc-supply = <&vdd_3v3>;
+	vqmmc-supply = <&vdd_1v8>;
+};
+
+&sd_emmc_c {
+	status = "okay";
+	pinctrl-0 = <&emmc_pins>, <&emmc_ds_pins>;
+	pinctrl-1 = <&emmc_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+
+	bus-width = <8>;
+	cap-mmc-highspeed;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	max-frequency = <200000000>;
+	non-removable;
+	disable-wp;
+
+	mmc-pwrseq = <&emmc_pwrseq>;
+	vmmc-supply = <&vdd_3v3>;
+	vqmmc-supply = <&vdd_1v8>;
+};
+
+&saradc {
+	status = "okay";
+};
+
+&ethmac {
+	status = "okay";
+
+	pinctrl-0 = <&eth_pins>, <&eth_rgmii_pins>;
+	pinctrl-names = "default";
+	phy-mode = "rgmii";
+	phy-handle = <&external_phy>;
+};
+
+&ext_mdio {
+	external_phy: ethernet-phy@0 {
+		/* Realtek RTL8211F (0x001cc916) */
+		reg = <0>;
+		max-speed = <1000>;
+
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		reset-gpios = <&gpio GPIOZ_15 (GPIO_ACTIVE_LOW | GPIO_OPEN_DRAIN)>;
+
+		interrupt-parent = <&gpio_intc>;
+		/* MAC_INTR on GPIOZ_14 */
+		interrupts = <26 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&spicc0 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spicc0_pins_x>;
+	cs-gpios = <&gpio GPIOX_10 0>;
+};
+
+&spicc1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spicc1_pins_h>;
+	cs-gpios = <&gpio GPIOH_6 0>;
+};
+
+&pwm_ef {
+	pinctrl-0 = <&pwm_e_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&uart_E {
+	status = "okay";
+	uart-has-rtscts;
+};
diff --git a/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212.dts b/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212.dts
new file mode 100644
index 000000000..09c721e53
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212.dts
@@ -0,0 +1,420 @@
+	i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		spi1 = &spicc0;
+		spi2 = &spicc1;
+	};
+
+	memory {
+		device_type = "memory";
+		linux,usable-memory = <0x0 0x000000 0x0 0x80000000>;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	emmc_pwrseq: emmc-pwrseq {
+		compatible = "mmc-pwrseq-emmc";
+		reset-gpios = <&gpio GPIOB_12 GPIO_ACTIVE_LOW>;
+	};
+
+	wifi32k: wifi32k {
+		compatible = "pwm-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		pwms = <&pwm_ef 0 30518 0>; /* PWM_E at 32.768KHz */
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpio GPIOX_6 GPIO_ACTIVE_LOW>;
+		clocks = <&wifi32k>;
+		clock-names = "ext_clock";
+	};
+
+	vdd_3v3: regulator-vdd_3v3 {
+                compatible = "regulator-fixed";
+                regulator-name = "VDD_3V3";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+        };
+
+	vdd_1v8: regulator-vdd_1v8 {
+                compatible = "regulator-fixed";
+                regulator-name = "VDD_1V8";
+                regulator-min-microvolt = <1800000>;
+                regulator-max-microvolt = <1800000>;
+        };
+
+	vbus_pwr: regulator-vbus_pwr {
+		compatible = "regulator-fixed";
+		regulator-name = "VBUS_PWR";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+//		vin-supply = <&vcc_5v>;
+
+		gpio = <&gpio GPIOH_6 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* 16 MiB reserved for Hardware ROM Firmware */
+		hwrom_reserved: hwrom@0 {
+			reg = <0x0 0x0 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* Reserved for ARM Trusted Firmware (BL31) */
+		secmon_reserved1: secmon@10000000 {
+			reg = <0x0 0x10000000 0x0 0x200000>;
+			no-map;
+		};
+
+		/* Reserved for ARM Trusted Firmware (BL31) */
+		secmon_reserved2: secmon@5000000 {
+			reg = <0x0 0x05000000 0x0 0x3400000>;
+			no-map;
+		};
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0xbc00000>;
+			alignment = <0x0 0x400000>;
+			linux,cma-default;
+		};
+
+	};
+
+	cpu_opp_table0: cpu_opp_table0 {
+		compatible = "operating-points-v2";
+		status = "okay";
+		opp-shared;
+
+		opp00 {
+			opp-hz = /bits/ 64 <100000000>;
+			opp-microvolt = <779000>;
+		};
+		opp01 {
+			opp-hz = /bits/ 64 <250000000>;
+			opp-microvolt = <779000>;
+		};
+		opp02 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <779000>;
+		};
+		opp03 {
+			opp-hz = /bits/ 64 <667000000>;
+			opp-microvolt = <799000>;
+		};
+		opp04 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-microvolt = <799000>;
+		};
+		opp05 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <809000>;
+		};
+		opp06 {
+			opp-hz = /bits/ 64 <1404000000>;
+			opp-microvolt = <839000>;
+		};
+		opp07 {
+			opp-hz = /bits/ 64 <1500000000>;
+			opp-microvolt = <849000>;
+		};
+		opp08 {
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <879000>;
+		};
+		opp09 {
+			opp-hz = /bits/ 64 <1704000000>;
+			opp-microvolt = <919000>;
+		};
+		opp10 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <959000>;
+		};
+		opp11 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <989000>;
+		};
+		opp12 {
+			opp-hz = /bits/ 64 <2004000000>;
+			opp-microvolt = <1019000>;
+		};
+	};
+
+	cpufreq-meson {
+		compatible = "amlogic,cpufreq-meson";
+		status = "okay";
+	};
+};
+
+&pwm_ij {
+	status = "okay";
+};
+
+&i2c2 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&i2c2_pins3>;
+	clock-frequency = <300000>;
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&i2c3_pins2>;
+	clock-frequency = <300000>; /* default 100k */
+};
+
+&vddcpu0 {
+	status = "okay";
+};
+
+&periphs_pinctrl {
+	tdm_a: tdm_a {
+		mux { /* GPIOX_11, GPIOX_10, GPIOX_8, GPIOX_9 */
+			groups = "tdm_sclk0",
+				"tdm_fs0",
+				"tdm_d3",
+				"tdm_d4";
+			function = "tdm";
+		};
+	};
+
+	tdmin_a: tdmin_a {
+		mux { /* GPIOX_8 */
+			groups = "tdma_din1";
+			function = "tdma_in";
+		};
+	};
+
+	tdmb_mclk: tdmb_mclk {
+		mux {
+			groups = "mclk0_a";
+			function = "mclk0";
+		};
+	};
+	tdmout_b: tdmout_b {
+		mux { /* GPIOA_1, GPIOA_2, GPIOA_3 */
+			groups = "tdmb_sclk",
+				"tdmb_fs",
+				"tdmb_dout0";
+			function = "tdmb_out";
+		};
+	};
+
+	tdmin_b:tdmin_b {
+		mux { /* GPIOA_4 */
+			groups = "tdmb_din1"
+				/*,"tdmb_slv_sclk", "tdmb_slv_fs"*/;
+			function = "tdmb_in";
+		};
+	};
+
+	tdmc_mclk: tdmc_mclk {
+		mux { /* GPIOA_11 */
+			groups = "mclk1_a";
+			function = "mclk1";
+		};
+	};
+
+	tdmout_c:tdmout_c {
+		mux { /* GPIOA_12, GPIOA_13 */
+			groups = "tdmc_sclk_a",
+				"tdmc_fs_a"
+				/*, "tdmc_dout0_a"
+				 *,	"tdmc_dout2"
+				 *, "tdmc_dout3"
+				 */;
+			function = "tdmc_out";
+		};
+	};
+
+	tdmin_c:tdmin_c {
+		mux { /* GPIOA_10 */
+			groups = "tdmc_din0_a";
+			function = "tdmc_in";
+		};
+	};
+
+	spdifin: spdifin {
+		mux {/* GPIOH_5 */
+			groups = "spdif_in_h";
+			function = "spdif_in";
+		};
+	};
+
+	pdmin: pdmin {
+		mux { /* GPIOC_0, GPIOC_4 */
+			groups = "pdm_din0_c",
+				"pdm_dclk_c";
+			function = "pdm";
+		};
+	};
+
+	spdifout: spdifout {
+		mux { /* GPIOD_10 */
+			groups = "spdif_out_d";
+			function = "spdif_out";
+		};
+	};
+
+	spdifout_a_mute: spdifout_a_mute {
+		mux { /* GPIOD_10 */
+			groups = "GPIOD_10";
+			function = "gpio_periphs";
+			output-low;
+		};
+	};
+
+	dvb_s_ts0_pins: dvb_s_ts0_pins {
+		tsin_a {
+			groups = "tsin_a_sop_d",
+				"tsin_a_valid_d",
+				"tsin_a_clk_d",
+				"tsin_a_din0_d";
+			function = "tsin_a";
+		};
+	};
+
+	dvb_s_ts1_pins: dvb_s_ts1_pins {
+		tsin_b {
+			groups = "tsin_b_sop",
+				"tsin_b_valid",
+				"tsin_b_clk",
+				"tsin_b_din0";
+			function = "tsin_b";
+		};
+	};
+
+	dvb_s_ts2_pins: dvb_s_ts2_pins {
+		tsin_c {
+			groups = "tsin_c_sop_z",
+				"tsin_c_valid_z",
+				"tsin_c_clk_z",
+				"tsin_c_din0_z";
+			function = "tsin_c";
+		};
+	};
+
+	dvb_s_ts3_pins: dvb_s_ts3_pins {
+		tsin_d {
+			groups = "tsin_d_sop_z",
+				"tsin_d_valid_z",
+				"tsin_d_clk_z",
+				"tsin_d_din0_z";
+			function = "tsin_d";
+		};
+	};
+}; /* end of periphs_pinctrl */
+
+&usb {
+	status = "okay";
+};
+
+/* SDIO */
+&sd_emmc_a {
+	status = "okay";
+	pinctrl-0 = <&sdio_pins>;
+	pinctrl-1 = <&sdio_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	max-frequency = <200000000>;
+
+	non-removable;
+	disable-wp;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+	vmmc-supply = <&vdd_3v3>;
+	vqmmc-supply = <&vdd_1v8>;
+};
+
+/* SD card */
+&sd_emmc_b {
+	status = "okay";
+	pinctrl-0 = <&sdcard_pins>;
+	pinctrl-1 = <&sdcard_clk_gate_pins>;
+	pinctrl-names = "sd_default", "clk-gate";
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	max-frequency = <200000000>;
+	disable-wp;
+
+	cd-gpios = <&gpio GPIOC_6 GPIO_ACTIVE_HIGH>;
+	cd-inverted;
+	vmmc-supply = <&vdd_3v3>;
+	vqmmc-supply = <&vdd_1v8>;
+};
+
+&sd_emmc_c {
+	status = "okay";
+	pinctrl-0 = <&emmc_pins>, <&emmc_ds_pins>;
+	pinctrl-1 = <&emmc_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+
+	bus-width = <8>;
+	cap-mmc-highspeed;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	max-frequency = <200000000>;
+	non-removable;
+	disable-wp;
+
+	mmc-pwrseq = <&emmc_pwrseq>;
+	vmmc-supply = <&vdd_3v3>;
+	vqmmc-supply = <&vdd_1v8>;
+};
+
+&saradc {
+	status = "okay";
+};
+
+&ethmac {
+	status = "okay";
+	phy-handle = <&internal_ephy>;
+	phy-mode = "rmii";
+};
+
+&spicc0 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spicc0_pins_x>;
+	cs-gpios = <&gpio GPIOX_10 0>;
+};
+
+&spicc1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spicc1_pins_h>;
+	cs-gpios = <&gpio GPIOH_6 0>;
+};
+
+&pwm_ef {
+	pinctrl-0 = <&pwm_e_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&uart_E {
+	status = "okay";
+	uart-has-rtscts;
+};
+
diff --git a/arch/arm64/boot/dts/amlogic/meson-sc2.dtsi b/arch/arm64/boot/dts/amlogic/meson-sc2.dtsi
new file mode 100644
index 000000000..e73deeb5b
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson-sc2.dtsi
@@ -0,0 +1,1514 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/clock/axg-audio-clkc.h>
+#include <dt-bindings/clock/amlogic,sc2-clkc.h>
+#include <dt-bindings/clock/g12a-aoclkc.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/gpio/meson-sc2-gpio.h>
+#include <dt-bindings/reset/amlogic,meson-sc2-reset.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pwm/meson.h>
+#include <dt-bindings/input/input.h>
+// #include <dt-bindings/mailbox/amlogic,mbox.h>
+#include "mesong12a-bifrost.dtsi"
+
+/ {
+	cpus:cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		CPU0:cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+			next-level-cache = <&l2>;
+			dynamic-power-coefficient = <230>;
+			#cooling-cells = <2>;
+			clocks = <&clkc CLKID_CPU_CLK>,
+				<&clkc CLKID_CPU_CLK_DYN>,
+				<&clkc CLKID_SYS_PLL>,
+				<&clkc CLKID_DSU_CLK>,
+				<&clkc CLKID_DSU_CLK_FINAL>;
+			clock-names = "core_clk",
+				"low_freq_clk_parent",
+				"high_freq_clk_parent",
+				"dsu_clk",
+				"dsu_pre_parent";
+			operating-points-v2 = <&cpu_opp_table0>;
+			cpu-supply = <&vddcpu0>;
+			voltage-tolerance = <0>;
+			clock-latency = <50000>;
+		};
+
+		CPU1:cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x0 0x1>;
+			enable-method = "psci";
+			next-level-cache = <&l2>;
+			dynamic-power-coefficient = <230>;
+			#cooling-cells = <2>;
+			clocks = <&clkc CLKID_CPU_CLK>,
+				<&clkc CLKID_CPU_CLK_DYN>,
+				<&clkc CLKID_SYS_PLL>,
+				<&clkc CLKID_DSU_CLK>,
+				<&clkc CLKID_DSU_CLK_FINAL>;
+			clock-names = "core_clk",
+				"low_freq_clk_parent",
+				"high_freq_clk_parent",
+				"dsu_clk",
+				"dsu_pre_parent";
+			operating-points-v2 = <&cpu_opp_table0>;
+			cpu-supply = <&vddcpu0>;
+			voltage-tolerance = <0>;
+			clock-latency = <50000>;
+		};
+
+		CPU2:cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x0 0x2>;
+			enable-method = "psci";
+			next-level-cache = <&l2>;
+			dynamic-power-coefficient = <230>;
+			#cooling-cells = <2>;
+			clocks = <&clkc CLKID_CPU_CLK>,
+				<&clkc CLKID_CPU_CLK_DYN>,
+				<&clkc CLKID_SYS_PLL>,
+				<&clkc CLKID_DSU_CLK>,
+				<&clkc CLKID_DSU_CLK_FINAL>;
+			clock-names = "core_clk",
+				"low_freq_clk_parent",
+				"high_freq_clk_parent",
+				"dsu_clk",
+				"dsu_pre_parent";
+			operating-points-v2 = <&cpu_opp_table0>;
+			cpu-supply = <&vddcpu0>;
+			voltage-tolerance = <0>;
+			clock-latency = <50000>;
+		};
+
+		CPU3:cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x0 0x3>;
+			enable-method = "psci";
+			next-level-cache = <&l2>;
+			dynamic-power-coefficient = <230>;
+			#cooling-cells = <2>;
+			clocks = <&clkc CLKID_CPU_CLK>,
+				<&clkc CLKID_CPU_CLK_DYN>,
+				<&clkc CLKID_SYS_PLL>,
+				<&clkc CLKID_DSU_CLK>,
+				<&clkc CLKID_DSU_CLK_FINAL>;
+			clock-names = "core_clk",
+				"low_freq_clk_parent",
+				"high_freq_clk_parent",
+				"dsu_clk",
+				"dsu_pre_parent";
+			operating-points-v2 = <&cpu_opp_table0>;
+			cpu-supply = <&vddcpu0>;
+			voltage-tolerance = <0>;
+			clock-latency = <50000>;
+		};
+
+		l2: l2-cache0 {
+			compatible = "cache";
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_RAW(0xff) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_RAW(0xff) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_RAW(0xff) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_RAW(0xff) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	arm_pmu {
+		compatible = "arm,armv8-pmuv3";
+		private-interrupts;
+		/* clusterb-enabled; */
+		interrupts = <GIC_SPI 235 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 236 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 237 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>;
+
+		reg = <0x0 0xff634680 0x0 0x4>;
+		cpumasks = <0xf>;
+		/* default 10ms */
+		relax-timer-ns = <10000000>;
+		/* default 10000us */
+		max-wait-cnt = <10000>;
+	};
+
+	gic: interrupt-controller@ffc01000 {
+		compatible = "arm,gic-400";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0x0 0xfff01000 0 0x1000>,
+		      <0x0 0xfff02000 0 0x2000>,
+		      <0x0 0xfff04000 0 0x2000>,
+		      <0x0 0xfff06000 0 0x2000>;
+		interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(8) | IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+	psci {
+		compatible = "arm,psci-0.2";
+		method = "smc";
+	};
+
+	xtal: xtal-clk {
+		compatible = "fixed-clock";
+		clock-frequency = <24000000>;
+		clock-output-names = "xtal";
+		#clock-cells = <0>;
+	};
+
+	vrtc: rtc@fe010288 {
+		compatible = "amlogic,meson-vrtc";
+		reg = <0x0 0xfe010288 0x0 0x4>;
+		status = "okay";
+	};
+
+	vddcpu0: pwm_j-regulator {
+		compatible = "pwm-regulator";
+		pwms = <&pwm_ij MESON_PWM_1 1500 0>;
+		regulator-name = "vddcpu0";
+		regulator-min-microvolt = <689000>;
+		regulator-max-microvolt = <1049000>;
+		regulator-always-on;
+		max-duty-cycle = <1500>;
+		/* Voltage Duty-Cycle */
+		voltage-table = <1049000 0>,
+				<1039000 3>,
+				<1029000 6>,
+				<1019000 9>,
+				<1009000 12>,
+				<999000 14>,
+				<989000 17>,
+				<979000 20>,
+				<969000 23>,
+				<959000 26>,
+				<949000 29>,
+				<939000 31>,
+				<929000 34>,
+				<919000 37>,
+				<909000 40>,
+				<899000 43>,
+				<889000 45>,
+				<879000 48>,
+				<869000 51>,
+				<859000 54>,
+				<849000 56>,
+				<839000 59>,
+				<829000 62>,
+				<819000 65>,
+				<809000 68>,
+				<799000 70>,
+				<789000 73>,
+				<779000 76>,
+				<769000 79>,
+				<759000 81>,
+				<749000 84>,
+				<739000 87>,
+				<729000 89>,
+				<719000 92>,
+				<709000 95>,
+				<699000 98>,
+				<689000 100>;
+		status = "disabled";
+	};
+
+	saradc: saradc@fe026000 {
+		compatible = "amlogic,meson-g12a-saradc",
+			   "amlogic,meson-saradc";
+		status = "disabled";
+		#io-channel-cells = <1>;
+		clocks = <&xtal>,
+		    <&clkc CLKID_SAR_ADC>,
+		    <&clkc CLKID_SARADC_GATE>,
+		    <&clkc CLKID_SARADC_MUX>;
+		clock-names = "clkin", "core",
+		    "adc_clk", "adc_sel";
+		interrupts = <GIC_SPI 181 IRQ_TYPE_EDGE_RISING>;
+		reg = <0x00 0xfe026000 0x00 0x48>;
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		apb4: apb4@fe000000 {
+			compatible = "simple-bus";
+			reg = <0x0 0xfe000000 0x0 0x480000>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges = <0x0 0x0 0x0 0xfe000000 0x0 0x480000>;
+
+			clkc: clock-controller {
+				compatible = "amlogic,sc2-clkc";
+				#clock-cells = <1>;
+				reg = <0x0 0x0 0x0 0x49c>,
+				      <0x0 0x8000 0x0 0x2e8>,
+				      <0x0 0xe140 0x0 0x24>;
+				reg-names = "basic", "pll",
+					    "cpu_clk";
+				clocks = <&xtal>;
+				clock-names = "xtal";
+				status = "okay";
+			};
+
+			periphs_pinctrl: pinctrl@4000 {
+				compatible = "amlogic,meson-sc2-periphs-pinctrl";
+				#address-cells = <2>;
+				#size-cells = <2>;
+				ranges;
+
+				gpio: bank@4000 {
+					reg = <0x0 0x4000 0x0 0x004c>,
+					      <0x0 0x40c0 0x0 0x0220>;
+					reg-names = "mux", "gpio";
+					gpio-controller;
+					#gpio-cells = <2>;
+					gpio-ranges = <&periphs_pinctrl 0 0 87>;
+				};
+			};
+
+			gpio_intc: interrupt-controller@4080 {
+				compatible = "amlogic,meson-sc2-gpio-intc",
+					     "amlogic,meson-gpio-intc";
+				reg = <0x0 0x4080 0x0 0x20>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				amlogic,channel-interrupts =
+					<10 11 12 13 14 15 16 17 18 19 20 21>;
+			};
+
+			spicc0: spi@50000 {
+				compatible = "amlogic,meson-g12a-spicc";
+				reg = <0x0 0x50000 0x0 0x44>;
+				interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clkc CLKID_SPICC0>,
+					 <&clkc CLKID_SPICC0_GATE>;
+				clock-names = "core", "async";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+			};
+
+			spicc1: spi@52000 {
+				compatible = "amlogic,meson-g12a-spicc";
+				reg = <0x0 0x52000 0x0 0x44>;
+				interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clkc CLKID_SPICC1>,
+					 <&clkc CLKID_SPICC1_GATE>;
+				clock-names = "core", "async";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+			};
+
+			pwm_ab: pwm@58000 {
+				compatible = "amlogic,meson-s4-pwm";
+				reg = <0x0 0x58000 0x0 0x24>;
+				#pwm-cells = <3>;
+				clocks = <&clkc CLKID_PWM_A_GATE>,
+						<&clkc CLKID_PWM_B_GATE>;
+				clock-names = "clkin0", "clkin1";
+				status = "disabled";
+			};
+
+			pwm_cd: pwm@5a000 {
+				compatible = "amlogic,meson-s4-pwm";
+				reg = <0x0 0x5a000 0x0 0x24>;
+				#pwm-cells = <3>;
+				clocks = <&clkc CLKID_PWM_C_GATE>,
+						<&clkc CLKID_PWM_D_GATE>;
+				clock-names = "clkin0", "clkin1";
+				status = "disabled";
+			};
+
+			pwm_ef: pwm@5c000 {
+				compatible = "amlogic,meson-s4-pwm";
+				reg = <0x0 0x5c000 0x0 0x24>;
+				#pwm-cells = <3>;
+				clocks = <&clkc CLKID_PWM_E_GATE>,
+						<&clkc CLKID_PWM_F_GATE>;
+				clock-names = "clkin0", "clkin1";
+				status = "disabled";
+			};
+
+			pwm_gh: pwm@5e000 {
+				compatible = "amlogic,meson-s4-pwm";
+				reg = <0x0 0x5e000 0x0 0x24>;
+				#pwm-cells = <3>;
+				clocks = <&clkc CLKID_PWM_G_GATE>,
+						<&clkc CLKID_PWM_H_GATE>;
+				clock-names = "clkin0", "clkin1";
+				status = "disabled";
+			};
+
+			pwm_ij: pwm@60000 {
+				compatible = "amlogic,meson-s4-pwm";
+				reg = <0x0 0x60000 0x0 0x24>;
+				#pwm-cells = <3>;
+				clocks = <&clkc CLKID_PWM_I_GATE>,
+						<&clkc CLKID_PWM_J_GATE>;
+				clock-names = "clkin0", "clkin1";
+				status = "disabled";
+			};
+
+			i2c0: i2c@66000 {
+				compatible = "amlogic,meson-axg-i2c";
+				reg = <0x0 0x66000 0x0 0x48>;
+				interrupts = <GIC_SPI 160 IRQ_TYPE_EDGE_RISING>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				clocks = <&clkc CLKID_I2C_M_A>;
+				status = "disabled";
+			};
+
+			i2c1: i2c@68000 {
+				compatible = "amlogic,meson-axg-i2c";
+				reg = <0x0 0x68000 0x0 0x48>;
+				interrupts = <GIC_SPI 161 IRQ_TYPE_EDGE_RISING>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				clocks = <&clkc CLKID_I2C_M_B>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@6a000 {
+				compatible = "amlogic,meson-axg-i2c";
+				reg = <0x0 0x6a000 0x0 0x48>;
+				interrupts = <GIC_SPI 162 IRQ_TYPE_EDGE_RISING>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				clocks = <&clkc CLKID_I2C_M_C>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@6c000 {
+				compatible = "amlogic,meson-axg-i2c";
+				reg = <0x0 0x6c000 0x0 0x48>;
+				interrupts = <GIC_SPI 163 IRQ_TYPE_EDGE_RISING>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				clocks = <&clkc CLKID_I2C_M_D>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@6e000 {
+				compatible = "amlogic,meson-axg-i2c";
+				reg = <0x0 0x6e000 0x0 0x48>;
+				interrupts = <GIC_SPI 164 IRQ_TYPE_EDGE_RISING>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				clocks = <&clkc CLKID_I2C_M_E>;
+				status = "disabled";
+			};
+
+			uart_B: serial@7a000 {
+				compatible = "amlogic,meson-gxl-uart",
+					     "amlogic,meson-ao-uart";
+				reg = <0x0 0x7a000 0x0 0x18>;
+				interrupts = <GIC_SPI 169 IRQ_TYPE_EDGE_RISING>;
+				status = "okay";
+				clocks = <&xtal>, <&xtal>, <&xtal>;
+				clock-names = "xtal", "pclk", "baud";
+			};
+
+			cpu_temp: temperature-sensor@20000 {
+				compatible = "amlogic,g12a-cpu-thermal",
+					     "amlogic,g12a-thermal";
+				reg = <0x0 0x20000 0x0 0x50>, <0x0 0x10328 0x0 0x4>;
+				clocks = <&clkc CLKID_TS_CLK_GATE>;
+				#thermal-sensor-cells = <0>;
+			};
+
+			ddr_temp: temperature-sensor@22000 {
+				compatible = "amlogic,g12a-ddr-thermal",
+					     "amlogic,g12a-thermal";
+				reg = <0x0 0x22000 0x0 0x50>, <0x0 0x10370 0x0 0x4>;
+				clocks = <&clkc CLKID_TS_CLK_GATE>;
+				#thermal-sensor-cells = <0>;
+			};
+
+			eth_phy: mdio-multiplexer@28000 {
+				compatible = "amlogic,g12a-mdio-mux";
+				reg = <0x0 0x28000 0x0 0xa4>;
+
+				clocks = <&clkc CLKID_ETHPHY>,
+					 <&xtal>,
+					 <&clkc CLKID_MPLL_50M>;
+				clock-names = "pclk", "clkin0", "clkin1";
+				mdio-parent-bus = <&mdio0>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				ext_mdio: mdio@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+				};
+
+				int_mdio: mdio@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					internal_ephy: ethernet_phy@8 {
+						compatible = "ethernet-phy-id0180.3301",
+							     "ethernet-phy-ieee802.3-c22";
+						interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+						reg = <8>;
+						max-speed = <100>;
+					};
+				};
+			};
+
+			reset: reset-controller@2000 {
+				compatible = "amlogic,meson-s4-reset";
+				reg = <0x0 0x2000 0x0 0x98>;
+				#reset-cells = <1>;
+			};
+
+			cpu_version {
+				compatible = "amlogic,meson-gx-ao-secure", "syscon";
+				reg=<0x0 0x10220 0x0 0x140>;
+				amlogic,has-chip-id;
+			};
+
+			usb2_phy0: phy@3c000 {
+				compatible = "amlogic,g12a-usb2-phy";
+				reg = <0x0 0x3c000 0x0 0x2000>;
+				clocks = <&xtal>;
+				clock-names = "xtal";
+				resets = <&reset RESET_USBPHY20>;
+				reset-names = "phy";
+				#phy-cells = <0>;
+			};
+
+			usb2_phy1: phy@3e000 {
+				compatible = "amlogic,g12a-usb2-phy";
+				reg = <0x0 0x3e000 0x0 0x2000>;
+				clocks = <&xtal>;
+				clock-names = "xtal";
+				resets = <&reset RESET_USBPHY21>;
+				reset-names = "phy";
+				#phy-cells = <0>;
+			};
+
+			usb3_pcie_phy: phy@2a000 {
+				compatible = "amlogic,g12a-usb3-pcie-phy";
+				reg = <0x0 0x2a000 0x0 0x2000>;
+				clocks = <&clkc CLKID_PCIE_PLL>;
+				clock-names = "ref_clk";
+				resets = <&reset RESET_PCIE_PHY>;
+				reset-names = "phy";
+				assigned-clocks = <&clkc CLKID_PCIE_PLL>;
+				assigned-clock-rates = <100000000>;
+				#phy-cells = <1>;
+			};
+		};
+
+		sd_emmc_c: mmc@fe08c000 {
+			compatible = "amlogic,meson-axg-mmc";
+			reg = <0x0 0xfe08c000 0x0 0x800>;
+			interrupts = <GIC_SPI 178 IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+
+			clocks = <&clkc CLKID_NAND>,
+				 <&clkc CLKID_SD_EMMC_C_CLK>,
+				 <&clkc CLKID_FCLK_DIV2>;
+			clock-names = "core", "clkin0", "clkin1";
+		};
+
+		sd_emmc_b: sd@fe08a000 {
+			compatible = "amlogic,meson-axg-mmc";
+			reg = <0x0 0xfe08a000 0x0 0x800>;
+			interrupts = <GIC_SPI 177 IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+			clocks = <&clkc CLKID_SD_EMMC_B>,
+				 <&clkc CLKID_SD_EMMC_B_CLK>,
+				 <&clkc CLKID_FCLK_DIV2>;
+			clock-names = "core", "clkin0", "clkin1";
+		};
+
+		sd_emmc_a: sdio@fe088000 {
+			compatible = "amlogic,meson-axg-mmc";
+			reg = <0x0 0xfe088000 0x0 0x800>;
+			interrupts = <GIC_SPI 176 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+			clocks = <&clkc CLKID_SD_EMMC_A>,
+				 <&clkc CLKID_SD_EMMC_A_CLK>,
+				 <&clkc CLKID_FCLK_DIV2>;
+			clock-names = "core", "clkin0", "clkin1";
+			cap-sdio-irq;
+			keep-power-in-suspend;
+		};
+
+		usb: usb@fe03a000 {
+			status = "disabled";
+			compatible = "amlogic,meson-g12a-usb-ctrl";
+			reg = <0x0 0xfe03a000 0x0 0xa0>;
+			interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+
+			clocks = <&clkc CLKID_USB>;
+			resets = <&reset RESET_USBCTRL>;
+
+			dr_mode = "host";
+
+			phys = <&usb2_phy0>, <&usb2_phy1>,
+			       <&usb3_pcie_phy PHY_TYPE_USB3>;
+			phy-names = "usb2-phy0", "usb2-phy1", "usb3-phy0";
+
+			dwc2: usb@fdd00000 {
+				compatible = "amlogic,meson-g12a-usb", "snps,dwc2";
+				reg = <0x0 0xfdd00000 0x0 0x100000>;
+				interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clkc CLKID_USB1_TO_DDR>;
+				clock-names = "otg";
+				phys = <&usb2_phy1>;
+				phy-names = "usb2-phy";
+				dr_mode = "peripheral";
+				g-rx-fifo-size = <192>;
+				g-np-tx-fifo-size = <128>;
+				g-tx-fifo-size = <128 128 16 16 16>;
+			};
+
+			dwc3: usb@fde00000 {
+				compatible = "snps,dwc3";
+				reg = <0x0 0xfde00000 0x0 0x100000>;
+				interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
+				dr_mode = "host";
+				snps,dis_u2_susphy_quirk;
+				snps,quirk-frame-length-adjustment = <0x20>;
+				snps,parkmode-disable-ss-quirk;
+			};
+		};
+
+		ethmac: ethernet@fdc00000 {
+			compatible = "amlogic,meson-axg-dwmac",
+				     "snps,dwmac-3.70a",
+				     "snps,dwmac";
+			reg = <0x0 0xfdc00000 0x0 0x10000>,
+			      <0x0 0xfe024000 0x0 0x8>;
+			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			clocks = <&clkc CLKID_ETH>,
+				 <&clkc CLKID_FCLK_DIV2>,
+				 <&clkc CLKID_MPLL2>;
+			clock-names = "stmmaceth", "clkin0", "clkin1";
+			rx-fifo-depth = <4096>;
+			tx-fifo-depth = <2048>;
+			mc_val = <0x4BE0C>;
+			status = "disabled";
+
+			mdio0: mdio {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "snps,dwmac-mdio";
+			};
+		};
+
+		uart_A: serial@fe078000 {
+			compatible = "amlogic,meson-gxl-uart";
+			reg = <0x0 0xfe078000 0x0 0x18>;
+			interrupts = <GIC_SPI 168 IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+			clocks = <&xtal>, <&xtal>, <&xtal>;
+			clock-names = "xtal", "pclk", "baud";
+			pinctrl-names = "default";
+			pinctrl-0 = <&a_uart_pins1>;
+		};
+
+		uart_C: serial@fe07c000 {
+			compatible = "amlogic,meson-gxl-uart";
+			reg = <0x0 0xfe07c000 0x0 0x18>;
+			interrupts = <GIC_SPI 170 IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+			clocks = <&xtal>, <&xtal>, <&xtal>;
+			clock-names = "xtal", "pclk", "baud";
+			pinctrl-names = "default";
+			pinctrl-0 = <&c_uart_pins>;
+		};
+
+		uart_D: serial@fe07e000 {
+			compatible = "amlogic,meson-gxl-uart";
+			reg = <0x0 0xfe07e000 0x0 0x18>;
+			interrupts = <GIC_SPI 171 IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+			clocks = <&xtal>, <&xtal>, <&xtal>;
+			clock-names = "xtal", "pclk", "baud";
+			pinctrl-names = "default";
+			pinctrl-0 = <&d_uart_pins1>;
+		};
+
+		uart_E: serial@fe080000 {
+			compatible = "amlogic,meson-gxl-uart";
+			reg = <0x0 0xfe080000 0x0 0x18>;
+			interrupts = <GIC_SPI 172 IRQ_TYPE_EDGE_RISING>;
+			status = "disabled";
+			clocks = <&xtal>, <&xtal>, <&xtal>;
+			clock-names = "xtal", "pclk", "baud";
+			pinctrl-names = "default";
+			pinctrl-0 = <&e_uart_pins>;
+		};
+	};
+
+	rng {
+		compatible = "amlogic,meson-rng";
+		status = "okay";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		reg = <0x0 0xfe440788 0x0 0x0c>;
+		quality = /bits/ 16 <1000>;
+		version = <2>;
+	};
+
+	wifi_pwm_conf:wifi_pwm_conf {
+		pwm_channel1_conf {
+			pwms = <&pwm_ef 0 30550 0>;
+			duty-cycle = <15270>;
+			times = <8>;
+		};
+		pwm_channel2_conf {
+			pwms = <&pwm_ef 2 30500 0>;
+			duty-cycle = <15250>;
+			times = <12>;
+		};
+	};
+
+	thermal-zones {
+		cpu_thermal: cpu-thermal {
+			polling-delay = <1000>;
+			polling-delay-passive = <100>;
+			thermal-sensors = <&cpu_temp>;
+
+			trips {
+				cpu_passive: cpu-passive {
+					temperature = <85000>; /* millicelsius */
+					hysteresis = <2000>; /* millicelsius */
+					type = "passive";
+				};
+
+				cpu_hot: cpu-hot {
+					temperature = <95000>; /* millicelsius */
+					hysteresis = <2000>; /* millicelsius */
+					type = "hot";
+				};
+
+				cpu_critical: cpu-critical {
+					temperature = <110000>; /* millicelsius */
+					hysteresis = <2000>; /* millicelsius */
+					type = "critical";
+				};
+			};
+		};
+
+		ddr_thermal: ddr-thermal {
+			polling-delay = <1000>;
+			polling-delay-passive = <100>;
+			thermal-sensors = <&ddr_temp>;
+
+			trips {
+				ddr_passive: ddr-passive {
+					temperature = <85000>; /* millicelsius */
+					hysteresis = <2000>; /* millicelsius */
+					type = "passive";
+				};
+
+				ddr_critical: ddr-critical {
+					temperature = <110000>; /* millicelsius */
+					hysteresis = <2000>; /* millicelsius */
+					type = "critical";
+				};
+			};
+		};
+	};
+};
+
+&periphs_pinctrl {
+	i2c0_pins1:i2c0_pins1 {
+		mux {
+			groups = "i2c0_sda_c",
+				"i2c0_scl_c";
+			function = "i2c0";
+			bias-disable;
+		};
+	};
+
+	i2c0_pins2:i2c0_pins2 {
+		mux {
+			groups = "i2c0_sda_h",
+				"i2c0_scl_h";
+			function = "i2c0";
+			bias-disable;
+		};
+	};
+
+	i2c0_pins3:i2c0_pins3 {
+		mux {
+			groups = "i2c0_sda_z0",
+				"i2c0_scl_z1";
+			function = "i2c0";
+			bias-disable;
+		};
+	};
+
+	i2c0_pins4:i2c0_pins4 {
+		mux {
+			groups = "i2c0_sda_z7",
+				"i2c0_scl_z8";
+			function = "i2c0";
+			bias-disable;
+
+		};
+	};
+
+	i2c1_pins1:i2c1_pins1 {
+		mux {
+			groups = "i2c1_sda_z",
+				"i2c1_scl_z";
+			function = "i2c1";
+			bias-disable;
+		};
+	};
+
+	i2c1_pins2:i2c1_pins2 {
+		mux {
+			groups = "i2c1_sda_x",
+				"i2c1_scl_x";
+			function = "i2c1";
+			bias-disable;
+		};
+	};
+
+	i2c1_pins3:i2c1_pins3 {
+		mux {
+			groups = "i2c1_sda_h2",
+				"i2c1_scl_h3";
+			function = "i2c1";
+			bias-disable;
+		};
+	};
+
+	i2c1_pins4:i2c1_pins4 {
+		mux {
+			groups = "i2c1_sda_h6",
+				"i2c1_scl_h7";
+			function = "i2c1";
+			bias-disable;
+		};
+	};
+
+	i2c2_pins1:i2c2_pins1 {
+		mux {
+			groups = "i2c2_sda_x",
+				"i2c2_scl_x";
+			function = "i2c2";
+			bias-disable;
+		};
+	};
+
+	i2c2_pins2:i2c2_pins2 {
+		mux {
+			groups = "i2c2_sda_z10",
+				"i2c2_scl_z11";
+			function = "i2c2";
+			bias-disable;
+		};
+	};
+
+	i2c2_pins3:i2c2_pins3 {
+		mux {
+			groups = "i2c2_sda_z14",
+				"i2c2_scl_z15";
+			function = "i2c2";
+			bias-disable;
+		};
+	};
+
+	i2c3_pins1:i2c3_pins1 {
+		mux {
+			groups = "i2c3_sda_h",
+				"i2c3_scl_h";
+			function = "i2c3";
+			bias-disable;
+		};
+	};
+
+	i2c3_pins2:i2c3_pins2 {
+		mux {
+			groups = "i2c3_sda_a",
+				"i2c3_scl_a";
+			function = "i2c3";
+			bias-disable;
+		};
+	};
+
+	i2c4_pins1:i2c4_pins1 {
+		mux {
+			groups = "i2c4_sda_d",
+				"i2c4_scl_d";
+			function = "i2c4";
+			bias-disable;
+		};
+	};
+
+	i2c4_pins2:i2c4_pins2 {
+		mux {
+			groups = "i2c4_sda_e",
+				"i2c4_scl_e";
+			function = "i2c4";
+			bias-disable;
+		};
+	};
+
+	a_uart_pins1:a_uart1 {
+		mux {
+			groups = "uart_a_tx_d2",
+				"uart_a_rx_d3";
+			function = "uart_a";
+		};
+	};
+
+	a_uart_pins2:a_uart2 {
+		mux {
+			groups = "uart_a_tx_d8",
+				"uart_a_rx_d9";
+			function = "uart_a";
+		};
+	};
+
+	c_uart_pins:c_uart {
+		mux {
+			groups = "uart_c_tx",
+				"uart_c_rx";
+			bias-pull-up;
+			output-high;
+			function = "uart_c";
+		};
+	};
+
+	d_uart_pins1:d_uart1 {
+		mux {
+			groups = "uart_d_tx_x6",
+				"uart_d_rx_x7";
+			function = "uart_d";
+		};
+	};
+
+	d_uart_pins2:d_uart2 {
+		mux {
+			groups = "uart_d_tx_x10",
+				"uart_d_rx_x11";
+			function = "uart_d";
+		};
+	};
+
+	e_uart_pins:e_uart {
+		mux {
+			groups = "uart_e_tx",
+				"uart_e_rx",
+				"uart_e_cts",
+				"uart_e_rts";
+			bias-pull-up;
+			output-high;
+			function = "uart_e";
+		};
+	};
+	emmc_pins: emmc {
+		mux-0 {
+			groups = "emmc_nand_d0",
+				 "emmc_nand_d1",
+				 "emmc_nand_d2",
+				 "emmc_nand_d3",
+				 "emmc_nand_d4",
+				 "emmc_nand_d5",
+				 "emmc_nand_d6",
+				 "emmc_nand_d7",
+				 "emmc_cmd";
+			function = "emmc";
+			bias-pull-up;
+		};
+
+		mux-1 {
+			groups = "emmc_clk";
+			function = "emmc";
+			bias-disable;
+		};
+	};
+
+	emmc_ds_pins: emmc-ds {
+		mux {
+			groups = "emmc_nand_dqs";
+			function = "emmc";
+			bias-pull-down;
+		};
+	};
+
+	emmc_clk_gate_pins: emmc_clk_gate {
+		mux {
+			groups = "GPIOB_8";
+			function = "gpio_periphs";
+			bias-pull-down;
+		};
+	};
+
+	all_nand_pins: all_nand_pins {
+	mux {
+			groups = "emmc_nand_d0",
+				"emmc_nand_d1",
+				"emmc_nand_d2",
+				"emmc_nand_d3",
+				"emmc_nand_d4",
+				"emmc_nand_d5",
+				"emmc_nand_d6",
+				"emmc_nand_d7",
+				"nand_ce0",
+				"nand_ale",
+				"nand_cle",
+				"nand_wen_clk",
+				"nand_ren_wr";
+			function = "nand";
+			input-enable;
+		};
+	};
+
+	nand_cs_pins: nand_cs {
+		mux {
+			groups = "nand_ce0";
+			function = "nand";
+		};
+	};
+
+	sd_to_ao_uart_clr_pins: sd_to_ao_uart_clr_pins {
+		mux {
+			groups = "GPIOD_0",
+				   "GPIOD_1";
+			function = "gpio_periphs";
+		};
+	};
+
+	sdcard_pins: sdcard_pins {
+		mux-0 {
+			groups = "sdcard_d0_c",
+				 "sdcard_d1_c",
+				 "sdcard_d2_c",
+				 "sdcard_d3_c",
+				 "sdcard_cmd_c";
+			function = "sdcard";
+			bias-pull-up;
+		};
+
+		mux-1 {
+			groups = "sdcard_clk_c";
+			function = "sdcard";
+			bias-pull-up;
+		};
+	};
+
+	sdcard_clk_gate_pins: sdio_clk_gate_pins {
+		mux {
+//			groups = "GPIOC_4";
+			groups = "sdcard_clk_c";
+//			function = "gpio_periphs";
+			function = "sdcard";
+			bias-pull-down;
+		};
+	};
+
+	sdio_pins: sdio {
+		mux-0 {
+			groups = "sdio_d0_x",
+				 "sdio_d1_x",
+				 "sdio_d2_x",
+				 "sdio_d3_x",
+				 "sdio_cmd_x";
+			function = "sdio";
+			bias-pull-up;
+		};
+
+		mux-1 {
+			groups = "sdio_clk_x";
+			function = "sdio";
+			bias-disable;
+		};
+	};
+
+	sdio_clk_gate_pins: sdio_clk_gate {
+		mux {
+			groups = "GPIOX_4";
+			function = "gpio_periphs";
+			bias-pull-down;
+		};
+	};
+
+	hdmitx_hpd: hdmitx_hpd {
+		mux {
+			groups = "hdmitx_hpd_in";
+			function = "hdmitx";
+			bias-disable;
+		};
+	};
+
+	hdmitx_hpd_gpio: hdmitx_hpd_gpio {
+		mux {
+			groups = "GPIOH_1";
+			function = "gpio_periphs";
+			bias-disable;
+		};
+	};
+
+	hdmitx_ddc: hdmitx_ddc {
+		mux {
+			groups = "hdmitx_sda",
+				"hdmitx_sck";
+			function = "hdmitx";
+			bias-disable;
+		};
+	};
+
+	eecec_a: ee_ceca {
+		mux {
+			groups = "cec_a_h";
+			function = "cec_a";
+		};
+	};
+
+	eecec_b: ee_cecb {
+		mux {
+			groups = "cec_b_h";
+			function = "cec_b";
+		};
+	};
+
+	jtag_a_pins: jtag_a_pin {
+		mux {
+			groups = "jtag_1_tdi",
+				 "jtag_1_tdo",
+				 "jtag_1_clk",
+				 "jtag_1_tms";
+			function = "jtag_1";
+		};
+	};
+
+	jtag_b_pins: jtag_b_pin {
+		mux {
+			groups = "jtag_2_tdi",
+				 "jtag_2_tdo",
+				 "jtag_2_clk",
+				 "jtag_2_tms";
+			function = "jtag_2";
+		};
+	};
+
+	pwm_a_pins1: pwm_a_pins1 {
+		mux {
+			groups = "pwm_a_e";
+			function = "pwm_a";
+		};
+	};
+
+	pwm_a_pins2: pwm_a_pins2 {
+		mux {
+			groups = "pwm_a_x";
+			function = "pwm_a";
+		};
+	};
+
+	pwm_b_pins1: pwm_b_pins1 {
+		mux {
+			groups = "pwm_b_h";
+			function = "pwm_b";
+		};
+	};
+
+	pwm_b_pins2: pwm_b_pins2 {
+		mux {
+			groups = "pwm_b_z0";
+			function = "pwm_b";
+		};
+	};
+
+	pwm_b_pins3: pwm_b_pins3 {
+		mux {
+			groups = "pwm_b_z13";
+			function = "pwm_b";
+		};
+	};
+
+	pwm_b_pins4: pwm_b_pins4 {
+		mux {
+			groups = "pwm_b_x7";
+			function = "pwm_b";
+		};
+	};
+
+	pwm_b_pins5: pwm_b_pins5 {
+		mux {
+			groups = "pwm_b_x19";
+			function = "pwm_b";
+		};
+	};
+
+	pwm_c_pins1: pwm_c_pins1 {
+		mux {
+			groups = "pwm_c_c";
+			function = "pwm_c";
+		};
+	};
+
+	pwm_c_pins2: pwm_c_pins2 {
+		mux {
+			groups = "pwm_c_x";
+			function = "pwm_c";
+		};
+	};
+
+	pwm_c_pins3: pwm_c_pins3 {
+		mux {
+			groups = "pwm_c_z";
+			function = "pwm_c";
+		};
+	};
+
+	pwm_d_pins1: pwm_d_pins1 {
+		mux {
+			groups = "pwm_d_z";
+			function = "pwm_d";
+		};
+	};
+
+	pwm_d_pins2: pwm_d_pins2 {
+		mux {
+			groups = "pwm_d_x3";
+			function = "pwm_d";
+		};
+	};
+
+	pwm_d_pins3: pwm_d_pins3 {
+		mux {
+			groups = "pwm_d_x6";
+			function = "pwm_d";
+		};
+	};
+
+	pwm_e_pins: pwm_e_pins {
+		mux {
+			groups = "pwm_e";
+			function = "pwm_e";
+		};
+	};
+
+	pwm_f_pins1: pwm_f_pins1 {
+		mux {
+			groups = "pwm_f_x";
+			function = "pwm_f";
+		};
+	};
+
+	pwm_f_pins2: pwm_f_pins2 {
+		mux {
+			groups = "pwm_f_h";
+			function = "pwm_f";
+		};
+	};
+
+	pwm_f_pins3: pwm_f_pins3 {
+		mux {
+			groups = "pwm_f_z";
+			function = "pwm_f";
+		};
+	};
+
+	pwm_g_pins: pwm_g_pins {
+		mux {
+			groups = "pwm_g";
+			function = "pwm_g";
+		};
+	};
+
+	pwm_h_pins: pwm_h_pins {
+		mux {
+			groups = "pwm_h";
+			function = "pwm_h";
+		};
+	};
+
+	pwm_i_pins1: pwm_i_pins1 {
+		mux {
+			groups = "pwm_i_d4";
+			function = "pwm_i";
+		};
+	};
+
+	pwm_i_pins2: pwm_i_pins2 {
+		mux {
+			groups = "pwm_i_d6";
+			function = "pwm_i";
+		};
+	};
+
+	pwm_j_pins1: pwm_j_pins1 {
+		mux {
+			groups = "pwm_j_e";
+			function = "pwm_j";
+		};
+	};
+
+	pwm_j_pins2: pwm_j_pins2 {
+		mux {
+			groups = "pwm_j_d5";
+			function = "pwm_j";
+		};
+	};
+
+	pwm_j_pins3: pwm_j_pins3 {
+		mux {
+			groups = "pwm_j_d10";
+			function = "pwm_j";
+		};
+	};
+
+	pwm_i_hiz_pins: pwm_i_hiz_pins {
+		mux {
+			groups = "pwm_i_hiz";
+			function = "pwm_i_hiz";
+		};
+	};
+
+	pwm_g_hiz_pins: pwm_g_hiz_pins {
+		mux {
+			groups = "pwm_g_hiz";
+			function = "pwm_g_hiz";
+		};
+	};
+
+	remote_pins: remote_pin {
+		mux {
+			groups = "remote_input_d5";
+			function = "remote_input";
+			bias-disable;
+		};
+	};
+
+	spicc0_pins_x: spicc0_pins_x {
+		mux {
+			groups = "spi_a_mosi_x",
+				 "spi_a_miso_x",
+				 //"spi_a_ss0_x",
+				 "spi_a_sclk_x";
+			function = "spi_a";
+		};
+	};
+
+	spicc0_pins_c: spicc0_pins_c {
+		mux {
+			groups = "spi_a_mosi_c",
+				 "spi_a_miso_c",
+				 //"spi_a_ss0_c",
+				 "spi_a_sclk_c";
+			function = "spi_a";
+		};
+	};
+
+	spicc1_pins_h: spicc1_pins_h {
+		mux {
+			groups = "spi_b_mosi_h",
+				 "spi_b_miso_h",
+				 //"spi_b_ss0_h",
+				 "spi_b_sclk_h";
+			function = "spi_b";
+		};
+	};
+
+	spifc_pins:spifc_pins {
+		mux {
+			groups = "nor_hold",
+				 "nor_d",
+				 "nor_q",
+				 "nor_c",
+				 "nor_wp",
+				 "nor_cs";
+			function = "nor";
+		};
+	};
+
+	irblaster_pins1:irblaster_pin1 {
+		mux {
+			groups = "remote_out_h";
+			function = "remote_out";
+		};
+	};
+
+	irblaster_pins2:irblaster_pin2 {
+		mux {
+			groups = "remote_out_z";
+			function = "remote_out";
+		};
+	};
+
+	irblaster_pins3:irblaster_pin3 {
+		mux {
+			groups = "remote_out_d4";
+			function = "remote_out";
+		};
+	};
+
+	irblaster_pins4:irblaster_pin4 {
+		mux {
+			groups = "remote_out_d9";
+			function = "remote_out";
+		};
+	};
+
+	sd_iso7816_pins:sd_iso7816_pins {
+		mux {
+			groups = "iso7816_clk_c",
+				"iso7816_data_c";
+			function = "iso7816";
+			input-enable;
+			bias-pull-down;
+		};
+	};
+
+	iso7816_pins_mode_0:iso7816_pins_mode_0 {
+		mux {
+			groups = "iso7816_data_c";
+			function = "iso7816";
+			input-enable;
+			bias-pull-down;
+		};
+	};
+
+	iso7816_pins_mode_1:iso7816_pins_mode_1 {
+		mux {
+			groups = "iso7816_data_x";
+			function = "iso7816";
+			input-enable;
+			bias-pull-down;
+		};
+	};
+
+	iso7816_pins_mode_2:iso7816_pins_mode_2 {
+		mux {
+			groups = "iso7816_data_h";
+			function = "iso7816";
+			input-enable;
+			bias-pull-down;
+		};
+	};
+
+	iso7816_pin_data_m_0_h:iso7816_pin_data_m_0_h {
+		mux {
+			groups = "GPIOC_6";
+			function = "gpio_periphs";
+			output-high;
+			bias-pull-up;
+		};
+	};
+
+	iso7816_pin_data_m_1_h:iso7816_pin_data_m_1_h {
+		mux {
+			groups = "GPIOX_9";
+			function = "gpio_periphs";
+			output-high;
+			bias-pull-up;
+		};
+	};
+
+	iso7816_pin_data_m_2_h:iso7816_pin_data_m_2_h {
+		mux {
+			groups = "GPIOH_7";
+			function = "gpio_periphs";
+			output-high;
+			bias-pull-up;
+		};
+	};
+
+	iso7816_pin_data_m_0_l:iso7816_pin_data_m_0_l {
+		mux {
+			groups = "GPIOC_6";
+			function = "gpio_periphs";
+			output-low;
+			bias-pull-up;
+		};
+	};
+
+	iso7816_pin_data_m_1_l:iso7816_pin_data_m_1_l {
+		mux {
+			groups = "GPIOX_9";
+			function = "gpio_periphs";
+			output-low;
+			bias-pull-up;
+		};
+	};
+
+	iso7816_pin_data_m_2_l:iso7816_pin_data_m_2_l {
+		mux {
+			groups = "GPIOH_7";
+			function = "gpio_periphs";
+			output-low;
+			bias-pull-up;
+		};
+	};
+};
+
+&gpu{
+	reg =   <0 0xFE400000 0 0x04000>, /*mali APB bus base address*/
+		<0 0xFE002000 0 0x01000>, /*reset register*/
+		<0 0xFF800000 0 0x01000>, /*aobus TODO update*/
+		<0 0xFF63c000 0 0x01000>, /*hiubus for clk cntl*/
+		<0 0xFE002000 0 0x01000>; /*reset register*/
+
+	interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+	interrupt-names = "gpu", "mmu", "job";
+
+	resets = <&reset RESET_MALI>, <&reset RESET_MALI_APB>;
+
+	clk_cntl_reg = <0x57>;
+
+	clocks = <&clkc CLKID_MALI>;
+	clock-names = "gpu_mux";
+
+	/*
+	 * Mali clocking is provided by two identical clock paths
+	 * MALI_0 and MALI_1 muxed to a single clock by a glitch
+	 * free mux to safely change frequency while running.
+	 */
+	assigned-clocks = <&clkc CLKID_MALI_0_SEL>,
+			  <&clkc CLKID_MALI_0>,
+			  <&clkc CLKID_MALI>; /* Glitch free mux */
+	assigned-clock-parents = <&clkc CLKID_FCLK_DIV2P5>,
+				 <0>, /* Do Nothing */
+				 <&clkc CLKID_MALI_0>;
+	assigned-clock-rates = <0>, /* Do Nothing */
+				   <800000000>,
+				   <0>; /* Do Nothing */
+
+	tbl =  <&dvfs285_cfg
+		&dvfs400_cfg
+		&dvfs500_cfg
+		&dvfs666_cfg
+		&dvfs850_cfg
+		&dvfs850_cfg>;
+};
diff --git a/arch/arm64/boot/dts/amlogic/mesong12a-bifrost.dtsi b/arch/arm64/boot/dts/amlogic/mesong12a-bifrost.dtsi
new file mode 100644
index 000000000..4e83cda20
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/mesong12a-bifrost.dtsi
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+/ {
+	gpu:bifrost {
+		compatible = "amlogic,meson-g12a-mali";
+		#cooling-cells = <2>;		/* min followed by max */
+		reg = <0 0xFFE40000 0 0x04000>, /*mali APB bus base address*/
+			<0 0xFFD01000 0 0x01000>, /*reset register*/
+			<0 0xFF800000 0 0x01000>, /*aobus for gpu pmu domain*/
+			<0 0xFF63c000 0 0x01000>, /*hiubus for gpu clk cntl*/
+			<0 0xFFD01000 0 0x01000>; /*reset register*/
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 161 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "gpu", "mmu", "job";
+
+		tbl =  <&dvfs285_cfg
+			&dvfs400_cfg
+			&dvfs500_cfg
+			&dvfs666_cfg
+			&dvfs850_cfg
+			&dvfs850_cfg>;
+
+		dvfs125_cfg:clk125_cfg {
+			clk_freq = <125000000>;
+			clk_parent = "fclk_div4";
+			clkp_freq = <500000000>;
+			clk_reg = <0xA03>;
+			voltage = <1150>;
+			keep_count = <5>;
+			threshold = <30 120>;
+		};
+
+		dvfs250_cfg:dvfs250_cfg {
+			clk_freq = <250000000>;
+			clk_parent = "fclk_div4";
+			clkp_freq = <500000000>;
+			clk_reg = <0xA01>;
+			voltage = <1150>;
+			keep_count = <5>;
+			threshold = <0 76>;
+		};
+
+		dvfs285_cfg:dvfs285_cfg {
+			clk_freq = <285714285>;
+			clk_parent = "fclk_div7";
+			clkp_freq = <285714285>;
+			clk_reg = <0xE00>;
+			voltage = <1150>;
+			keep_count = <5>;
+			threshold = <0 76>;
+		};
+
+		dvfs400_cfg:dvfs400_cfg {
+			clk_freq = <400000000>;
+			clk_parent = "fclk_div5";
+			clkp_freq = <400000000>;
+			clk_reg = <0xC00>;
+			voltage = <1150>;
+			keep_count = <5>;
+			threshold = <80 120>;
+		};
+
+		dvfs500_cfg:dvfs500_cfg {
+			clk_freq = <500000000>;
+			clk_parent = "fclk_div4";
+			clkp_freq = <500000000>;
+			clk_reg = <0xA00>;
+			voltage = <1150>;
+			keep_count = <5>;
+			threshold = <80 120>;
+		};
+
+		dvfs666_cfg:dvfs666_cfg {
+			clk_freq = <666666666>;
+			clk_parent = "fclk_div3";
+			clkp_freq = <666666666>;
+			clk_reg = <0x800>;
+			voltage = <1150>;
+			keep_count = <5>;
+			threshold = <80 120>;
+		};
+
+		dvfs800_cfg:dvfs800_cfg {
+			clk_freq = <800000000>;
+			clk_parent = "fclk_div2p5";
+			clkp_freq = <800000000>;
+			clk_reg = <0x600>;
+			voltage = <1150>;
+			keep_count = <5>;
+			threshold = <80 255>;
+		};
+
+		dvfs850_cfg:dvfs850_cfg {
+			clk_freq = <846000000>;
+			clk_parent = "gp0_pll";
+			clkp_freq = <846000000>;
+			clk_reg = <0x200>;
+			voltage = <1150>;
+			keep_count = <5>;
+			threshold = <80 255>;
+		};
+	};
+
+};
--
2.43.0.windows.1


From 2a52e21e2d5a87c1d54a7fd3b44e60238ea8b689 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 18:31:52 +0200
Subject: [PATCH 23/26] add fd6551 driver Signed-off-by: Heiner Kallweit
 <hkallweit1@gmail.com>

---
 drivers/auxdisplay/Kconfig  |   7 +
 drivers/auxdisplay/Makefile |   1 +
 drivers/auxdisplay/fd6551.c | 364 ++++++++++++++++++++++++++++++++++++
 3 files changed, 372 insertions(+)
 create mode 100644 drivers/auxdisplay/fd6551.c

diff --git a/drivers/auxdisplay/Kconfig b/drivers/auxdisplay/Kconfig
index 9a1b08df7..a0347c7b1 100644
--- a/drivers/auxdisplay/Kconfig
+++ b/drivers/auxdisplay/Kconfig
@@ -238,6 +238,13 @@ config OPENVFD

 	    Sources: https://github.com/arthur-liberman/linux_openvfd

+config FD6551
+	tristate "FD6551 driver for LED 7 segment displays"
+	depends on I2C_GPIO
+	depends on OF || COMPILE_TEST
+	help
+	  Say Y to enable support for FD6551
+
 menuconfig PARPORT_PANEL
 	tristate "Parallel port LCD/Keypad Panel support"
 	depends on PARPORT
diff --git a/drivers/auxdisplay/Makefile b/drivers/auxdisplay/Makefile
index 6d6f32f0f..cdcd53f9f 100644
--- a/drivers/auxdisplay/Makefile
+++ b/drivers/auxdisplay/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_LCD2S)		+= lcd2s.o
 obj-$(CONFIG_LINEDISP)		+= line-display.o
 obj-$(CONFIG_TM1628)		+= tm1628.o
 obj-$(CONFIG_OPENVFD)		+= openvfd/
+obj-$(CONFIG_FD6551)            += fd6551.o
diff --git a/drivers/auxdisplay/fd6551.c b/drivers/auxdisplay/fd6551.c
new file mode 100644
index 000000000..58e981315
--- /dev/null
+++ b/drivers/auxdisplay/fd6551.c
@@ -0,0 +1,364 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Fuda Hisi FD6551 LED controller
+ *
+ * Copyright (c) 2022 Heiner Kallweit
+ */
+
+
+#include <linux/ctype.h>
+#include <linux/i2c.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/property.h>
+#include <uapi/linux/map_to_7segment.h>
+
+#define NUM_LED_SEGS	7
+
+enum {
+	FD6551_GRID_0,
+	FD6551_GRID_1,
+	FD6551_GRID_2,
+	FD6551_GRID_3,
+	FD6551_SYMBOLS,
+	FD6551_GRID_SIZE
+};
+
+struct fd6551_led {
+	struct led_classdev	leddev;
+	struct i2c_client	*client;
+	u8			segment;
+};
+
+struct fd6551_priv {
+	struct i2c_client	*grid_clients[FD6551_GRID_SIZE];
+	struct mutex		lock;
+	int			grid_size;
+	char			display_data[FD6551_GRID_SIZE];
+	char			text[FD6551_GRID_SIZE];
+	u8			segment_mapping[NUM_LED_SEGS];
+	struct fd6551_led	leds[];
+};
+
+static int fd6551_send(struct i2c_client *client, char data)
+{
+	int ret = i2c_transfer_buffer_flags(client, &data, 1, I2C_M_IGNORE_NAK);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int fd6551_display_on(struct i2c_client *client, bool enable)
+{
+	char cmd = enable ? 1 : 0;
+
+	return fd6551_send(client, cmd);
+}
+
+static int fd6551_write_display_data(struct i2c_client *client)
+{
+	struct fd6551_priv *priv = i2c_get_clientdata(client);
+	int i, ret;
+
+	for (i = 0; i < FD6551_GRID_SIZE; i++) {
+		if (!priv->grid_clients[i])
+			continue;
+
+		ret = fd6551_send(priv->grid_clients[i], priv->display_data[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int fd6551_create_grid(struct i2c_client *client)
+{
+	static const char *grid_names[FD6551_GRID_SIZE] = {
+		"grid_0",
+		"grid_1",
+		"grid_2",
+		"grid_3",
+		"symbols",
+	};
+	struct fd6551_priv *priv = i2c_get_clientdata(client);
+	struct device_node *np = client->dev.of_node;
+	int i;
+
+	for (i = 0; i < FD6551_GRID_SIZE; i++) {
+		struct i2c_client *cl;
+		int idx, ret;
+		u32 addr;
+
+		idx = of_property_match_string(np, "reg-names", grid_names[i]);
+		if (idx < 1)
+			continue;
+
+		ret = of_property_read_u32_index(np, "reg", idx, &addr);
+		if (ret)
+			return ret;
+
+		cl = devm_i2c_new_dummy_device(&client->dev, client->adapter, addr);
+		if (IS_ERR(cl))
+			return PTR_ERR(cl);
+
+		priv->grid_clients[i] = cl;
+	}
+
+	return 0;
+}
+
+static int fd6551_get_grid_size(struct i2c_client *client)
+{
+	struct fd6551_priv *priv = i2c_get_clientdata(client);
+	int i, num_digits = 0;
+
+	for (i = FD6551_GRID_0; i <= FD6551_GRID_3; i++) {
+		if (priv->grid_clients[i])
+			num_digits++;
+		else
+			break;
+	}
+
+	return num_digits;
+}
+
+static int fd6551_show_text(struct i2c_client *client)
+{
+	static SEG7_CONVERSION_MAP(map_seg7, MAP_ASCII7SEG_ALPHANUM);
+	struct fd6551_priv *priv = i2c_get_clientdata(client);
+	int msg_len, i, ret;
+
+	msg_len = strlen(priv->text);
+
+	mutex_lock(&priv->lock);
+
+	for (i = 0; i < priv->grid_size; i++) {
+		char char7_raw, char7;
+		int j;
+
+		if (i >= msg_len) {
+			priv->display_data[i] = 0;
+			continue;
+		}
+
+		char7_raw = map_to_seg7(&map_seg7, priv->text[i]);
+
+		for (j = 0, char7 = 0; j < NUM_LED_SEGS; j++) {
+			if (char7_raw & BIT(j))
+				char7 |= BIT(priv->segment_mapping[j]);
+		}
+
+		priv->display_data[i] = char7;
+	}
+
+	ret = fd6551_write_display_data(client);
+
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+
+static ssize_t display_text_show(struct device *dev, struct device_attribute *attr,
+				 char *buf)
+{
+	struct fd6551_priv *priv = dev_get_drvdata(dev);
+
+	return sysfs_emit(buf, "%s\n", priv->text);
+}
+
+static ssize_t display_text_store(struct device *dev, struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct fd6551_priv *priv = dev_get_drvdata(dev);
+	struct i2c_client *client = to_i2c_client(dev);
+	int ret, i;
+
+	for (i = 0; i < count && i < priv->grid_size && isprint(buf[i]); i++)
+		priv->text[i] = buf[i];
+
+	priv->text[i] = '\0';
+
+	ret = fd6551_show_text(client);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static const DEVICE_ATTR_RW(display_text);
+
+static int fd6551_led_set_brightness(struct led_classdev *led_cdev,
+				     enum led_brightness brightness)
+{
+	struct fd6551_led *led = container_of(led_cdev, struct fd6551_led, leddev);
+	struct i2c_client *client = led->client;
+	struct fd6551_priv *priv = i2c_get_clientdata(client);
+	u8 bit = BIT(led->segment);
+	int ret;
+
+	mutex_lock(&priv->lock);
+
+	if (brightness == LED_OFF)
+		priv->display_data[FD6551_SYMBOLS] &= ~bit;
+	else
+		priv->display_data[FD6551_SYMBOLS] |= bit;
+
+	ret = fd6551_write_display_data(client);
+
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+
+static enum led_brightness fd6551_led_get_brightness(struct led_classdev *led_cdev)
+{
+	struct fd6551_led *led = container_of(led_cdev, struct fd6551_led, leddev);
+	struct i2c_client *client = led->client;
+	struct fd6551_priv *priv = i2c_get_clientdata(client);
+	u8 bit = BIT(led->segment);
+	bool on;
+
+	mutex_lock(&priv->lock);
+	on = priv->display_data[FD6551_SYMBOLS] & bit;
+	mutex_unlock(&priv->lock);
+
+	return on ? LED_ON : LED_OFF;
+}
+
+static int fd6551_register_led(struct i2c_client *client, struct fwnode_handle *node,
+			       u8 segment, struct fd6551_led *led)
+{
+	struct led_init_data init_data = { .fwnode = node };
+
+	led->client = client;
+	led->segment = segment;
+	led->leddev.max_brightness = LED_ON;
+	led->leddev.brightness_set_blocking = fd6551_led_set_brightness;
+	led->leddev.brightness_get = fd6551_led_get_brightness;
+
+	return devm_led_classdev_register_ext(&client->dev, &led->leddev, &init_data);
+}
+
+static int fd6551_probe(struct i2c_client *client)
+{
+	struct fwnode_handle *child;
+	struct fd6551_priv *priv;
+	int i, num_leds, ret;
+
+	num_leds = device_get_child_node_count(&client->dev);
+
+	priv = devm_kzalloc(&client->dev, struct_size(priv, leds, num_leds), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	mutex_init(&priv->lock);
+	i2c_set_clientdata(client, priv);
+
+	ret = fd6551_create_grid(client);
+	if (ret)
+		return ret;
+
+	priv->grid_size = fd6551_get_grid_size(client);
+
+	ret = device_property_read_u8_array(&client->dev, "fudahisi,segment-mapping",
+					    priv->segment_mapping, NUM_LED_SEGS);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < NUM_LED_SEGS; i++) {
+		if (priv->segment_mapping[i] >= NUM_LED_SEGS)
+			return -EINVAL;
+	}
+
+	priv->display_data[0] = 0x66;
+	fd6551_write_display_data(client);
+
+	num_leds = 0;
+
+	if (!IS_REACHABLE(CONFIG_LEDS_CLASS))
+		goto no_leds;
+
+	device_for_each_child_node(&client->dev, child) {
+		u32 reg;
+
+		ret = fwnode_property_read_u32(child, "reg", &reg);
+		if (ret) {
+			dev_err(&client->dev, "Reading %s reg property failed (%d)\n",
+				fwnode_get_name(child), ret);
+			continue;
+		}
+
+		if (reg >= sizeof(u8) * 8) {
+			dev_err(&client->dev, "Invalid segment %u at %s\n",
+				reg, fwnode_get_name(child));
+			continue;
+		}
+
+		ret = fd6551_register_led(client, child, reg, priv->leds + num_leds);
+		if (ret) {
+			dev_err(&client->dev, "Failed to register LED %s (%d)\n",
+				fwnode_get_name(child), ret);
+			continue;
+		}
+		num_leds++;
+	}
+
+no_leds:
+	ret = device_create_file(&client->dev, &dev_attr_display_text);
+	if (ret)
+		return ret;
+
+	ret = fd6551_display_on(client, true);
+	if (ret) {
+		device_remove_file(&client->dev, &dev_attr_display_text);
+		return ret;
+	}
+
+	dev_info(&client->dev, "Set up FD6551 LED controller with %d digits and %d symbols.\n",
+		 priv->grid_size, num_leds);
+
+	return 0;
+}
+
+static int fd6551_remove(struct i2c_client *client)
+{
+	device_remove_file(&client->dev, &dev_attr_display_text);
+
+	return fd6551_display_on(client, false);
+}
+
+static void fd6551_shutdown(struct i2c_client *client)
+{
+	fd6551_display_on(client, false);
+}
+
+static const struct i2c_device_id fd6551_i2c_ids[] = {
+	{ "fd6551" },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, fd6551_i2c_ids);
+
+static const struct of_device_id fd6551_of_matches[] = {
+	{ .compatible = "fudahisi,fd6551" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, fd6551_of_matches);
+
+static struct i2c_driver fd6551_driver = {
+	.driver = {
+		.name   = "fd6551",
+		.of_match_table = fd6551_of_matches,
+	},
+	.probe_new	= fd6551_probe,
+	.remove		= fd6551_remove,
+	.shutdown	= fd6551_shutdown,
+	.id_table	= fd6551_i2c_ids,
+};
+
+module_i2c_driver(fd6551_driver);
+
+MODULE_DESCRIPTION("FD6551 LED controller driver");
+MODULE_AUTHOR("Heiner Kallweit <hkallweit1@gmail.com>");
+MODULE_LICENSE("GPL");
+
--
2.43.0.windows.1


From 8f5e04f1e38f049d962b9275e9493399d75ed29c Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 18:53:01 +0200
Subject: [PATCH 24/26] thermal: amlogic: Support reading trim_info on SC2 On
 SC2 platform the trim_info registers seem to not be part of ao-secure. Vendor
 driver uses a second IOMEM resource for specifying the register location. So
 let's mimic this approach.

Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
---
 drivers/thermal/amlogic_thermal.c | 21 ++++++++++++++-------
 1 file changed, 14 insertions(+), 7 deletions(-)

diff --git a/drivers/thermal/amlogic_thermal.c b/drivers/thermal/amlogic_thermal.c
index d30cb791e..ec6399f17 100644
--- a/drivers/thermal/amlogic_thermal.c
+++ b/drivers/thermal/amlogic_thermal.c
@@ -100,6 +100,7 @@ struct amlogic_thermal {
 	const struct amlogic_thermal_data *data;
 	struct regmap *regmap;
 	struct regmap *sec_ao_map;
+	void __iomem *trim_info_reg;
 	struct clk *clk;
 	struct thermal_zone_device *tzd;
 	u32 trim_info;
@@ -141,7 +142,10 @@ static int amlogic_thermal_initialize(struct amlogic_thermal *pdata)
 	int ret = 0;
 	int ver;

-	regmap_read(pdata->sec_ao_map, pdata->data->u_efuse_off,
+	if (!IS_ERR(pdata->trim_info_reg))
+		pdata->trim_info = readl(pdata->trim_info_reg);
+	else
+		regmap_read(pdata->sec_ao_map, pdata->data->u_efuse_off,
 		    &pdata->trim_info);

 	ver = TSENSOR_TRIM_VERSION(pdata->trim_info);
@@ -231,7 +235,7 @@ static const struct of_device_id of_amlogic_thermal_match[] = {
 		.data = &amlogic_thermal_g12a_ddr_param,
 	},
 	{
-		.compatible = "amlogic,g12a-cpu-thermal",
+	.compatible = "amlogic,g12a-cpu-thermal",
 		.data = &amlogic_thermal_g12a_cpu_param,
 	},
 	{ /* sentinel */ }
@@ -269,11 +273,14 @@ static int amlogic_thermal_probe(struct platform_device *pdev)
 		return PTR_ERR(pdata->clk);
 	}

-	pdata->sec_ao_map = syscon_regmap_lookup_by_phandle
-		(pdev->dev.of_node, "amlogic,ao-secure");
-	if (IS_ERR(pdata->sec_ao_map)) {
-		dev_err(dev, "syscon regmap lookup failed.\n");
-		return PTR_ERR(pdata->sec_ao_map);
+	pdata->trim_info_reg = devm_platform_ioremap_resource(pdev, 1);
+	if (IS_ERR(pdata->trim_info_reg)) {
+		pdata->sec_ao_map = syscon_regmap_lookup_by_phandle
+			(pdev->dev.of_node, "amlogic,ao-secure");
+		if (IS_ERR(pdata->sec_ao_map)) {
+			dev_err(dev, "syscon regmap lookup failed.\n");
+			return PTR_ERR(pdata->sec_ao_map);
+		}
 	}

 	pdata->tzd = devm_thermal_of_zone_register(&pdev->dev,
--
2.43.0.windows.1


From 90ac604f246624c3508d4cae908f37f763bef025 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 19:13:38 +0200
Subject: [PATCH 25/26] Fix incomplete file

---
 .../dts/amlogic/meson-sc2-s905x4-ah212.dts    | 140 +++++++++++++++++-
 1 file changed, 136 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212.dts b/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212.dts
index 09c721e53..2db2113b6 100644
--- a/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212.dts
+++ b/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-ah212.dts
@@ -1,4 +1,29 @@
-	i2c1 = &i2c1;
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include "meson-sc2.dtsi"
+
+/ {
+	model = "Amlogic SC2 AH212 ";
+	compatible = "amlogic,sc2";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart_B;
+		serial1 = &uart_E;
+		serial2 = &uart_C;
+		serial3 = &uart_D;
+		serial4 = &uart_A;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
 		i2c2 = &i2c2;
 		i2c3 = &i2c3;
 		i2c4 = &i2c4;
@@ -155,6 +180,62 @@ cpufreq-meson {
 		compatible = "amlogic,cpufreq-meson";
 		status = "okay";
 	};
+
+	i2c-led {
+		compatible = "i2c-gpio";
+		sda-gpios = <&gpio GPIOA_14 GPIO_ACTIVE_HIGH>;
+		i2c-gpio,sda-output-only;
+		scl-gpios = <&gpio GPIOA_15 GPIO_ACTIVE_HIGH>;
+		i2c-gpio,scl-output-only;
+		i2c-gpio,delay-us = <5>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		disp_7seg@24 {
+			compatible = "fudahisi,fd6551";
+			reg = <0x24>, <0x37>, <0x36>, <0x35>, <0x34>, <0x33>;
+			reg-names = "cmd", "grid_0", "grid_1", "grid_2", "grid_3", "symbols";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			fudahisi,segment-mapping = /bits/ 8 <0 1 2 3 4 5 6>;
+
+			led@0 {
+				reg = <0>;
+				function = LED_FUNCTION_ALARM;
+			};
+
+			led@1 {
+				reg = <1>;
+				function = LED_FUNCTION_USB;
+			};
+
+			led@2 {
+				reg = <2>;
+				function = "pause";
+			};
+
+			led@3 {
+				reg = <3>;
+				function = "play";
+			};
+
+			led@4 {
+				reg = <4>;
+				function = "colon";
+			};
+
+			led@5 {
+				reg = <5>;
+				function = LED_FUNCTION_LAN;
+			};
+
+			led@6 {
+				reg = <6>;
+				function = LED_FUNCTION_WLAN;
+			};
+		};
+	};
 };

 &pwm_ij {
@@ -180,6 +261,39 @@ &vddcpu0 {
 };

 &periphs_pinctrl {
+
+/*****/
+	eth_pins: eth {
+		mux {
+			groups = "eth_mdio",
+				 "eth_mdc",
+				 "eth_rgmii_rx_clk",
+				 "eth_rx_dv",
+				 "eth_rxd0",
+				 "eth_rxd1",
+				 "eth_txen",
+				 "eth_txd0",
+				 "eth_txd1";
+			function = "eth";
+			drive-strength-microamp = <4000>;
+			bias-disable;
+		};
+	};
+
+	eth_rgmii_pins: eth-rgmii {
+		mux {
+			groups = "eth_rxd2_rgmii",
+				 "eth_rxd3_rgmii",
+				 "eth_rgmii_tx_clk",
+				 "eth_txd2_rgmii",
+				 "eth_txd3_rgmii";
+			function = "eth";
+			drive-strength-microamp = <4000>;
+			bias-disable;
+		};
+	};
+/*****/
+
 	tdm_a: tdm_a {
 		mux { /* GPIOX_11, GPIOX_10, GPIOX_8, GPIOX_9 */
 			groups = "tdm_sclk0",
@@ -389,8 +503,27 @@ &saradc {

 &ethmac {
 	status = "okay";
-	phy-handle = <&internal_ephy>;
-	phy-mode = "rmii";
+
+	pinctrl-0 = <&eth_pins>, <&eth_rgmii_pins>;
+	pinctrl-names = "default";
+	phy-mode = "rgmii";
+	phy-handle = <&external_phy>;
+};
+
+&ext_mdio {
+	external_phy: ethernet-phy@0 {
+		/* Realtek RTL8211F (0x001cc916) */
+		reg = <0>;
+		max-speed = <1000>;
+
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		reset-gpios = <&gpio GPIOZ_15 (GPIO_ACTIVE_LOW | GPIO_OPEN_DRAIN)>;
+
+		interrupt-parent = <&gpio_intc>;
+		/* MAC_INTR on GPIOZ_14 */
+		interrupts = <26 IRQ_TYPE_LEVEL_LOW>;
+	};
 };

 &spicc0 {
@@ -417,4 +550,3 @@ &uart_E {
 	status = "okay";
 	uart-has-rtscts;
 };
-
--
2.43.0.windows.1


From e890ce98686a575e67536ad732dfc364d1b98511 Mon Sep 17 00:00:00 2001
From: Luigi Capriotti <lcapriotti@gmail.com>
Date: Tue, 15 Aug 2023 20:39:57 +0200
Subject: [PATCH 26/26] fix incompatible type

---
 drivers/auxdisplay/fd6551.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/auxdisplay/fd6551.c b/drivers/auxdisplay/fd6551.c
index 58e981315..233d84891 100644
--- a/drivers/auxdisplay/fd6551.c
+++ b/drivers/auxdisplay/fd6551.c
@@ -321,11 +321,11 @@ static int fd6551_probe(struct i2c_client *client)
 	return 0;
 }

-static int fd6551_remove(struct i2c_client *client)
+static void fd6551_remove(struct i2c_client *client)
 {
 	device_remove_file(&client->dev, &dev_attr_display_text);

-	return fd6551_display_on(client, false);
+	fd6551_display_on(client, false);
 }

 static void fd6551_shutdown(struct i2c_client *client)
--
2.43.0.windows.1


From 4991db9085a69e79dc3877aa86afd94667351a21 Mon Sep 17 00:00:00 2001
From: liushengpeng <lspvic@qq.com>
Date: Fri, 12 Jan 2024 01:38:19 +0800
Subject: [PATCH 1/1] Add sc2_s905x4_ 4g_1gbit dtb files

---
 arch/arm64/boot/dts/amlogic/Makefile          |   1 +
 .../dts/amlogic/meson-sc2-s905x4-gbit.dts     | 499 ++++++++++++++++++
 arch/arm64/boot/dts/amlogic/sc2_s905x4_2g.dts |  37 ++
 .../boot/dts/amlogic/sc2_s905x4_2g_1gbit.dts  |  60 +++
 .../boot/dts/amlogic/sc2_s905x4_4g_1gbit.dts  |   9 +
 5 files changed, 606 insertions(+)
 create mode 100644 arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-gbit.dts
 create mode 100644 arch/arm64/boot/dts/amlogic/sc2_s905x4_2g.dts
 create mode 100644 arch/arm64/boot/dts/amlogic/sc2_s905x4_2g_1gbit.dts
 create mode 100644 arch/arm64/boot/dts/amlogic/sc2_s905x4_4g_1gbit.dts

diff --git a/arch/arm64/boot/dts/amlogic/Makefile b/arch/arm64/boot/dts/amlogic/Makefile
index dc19f9b89..7ca39a425 100644
--- a/arch/arm64/boot/dts/amlogic/Makefile
+++ b/arch/arm64/boot/dts/amlogic/Makefile
@@ -132,5 +132,6 @@ dtb-$(CONFIG_ARCH_MESON) += meson-sm1-x96-max-plus-q1.dtb
 dtb-$(CONFIG_ARCH_MESON) += meson-sm1-x96-max-plus-q2.dtb
 dtb-$(CONFIG_ARCH_MESON) += meson-sm1-x96-max-plus-2101.dtb
 dtb-$(CONFIG_ARCH_MESON) += meson-sc2-s905x4-ah212.dtb
+dtb-$(CONFIG_ARCH_MESON) += sc2_s905x4_4g_1gbit.dtb

 subdir-y       := $(dts-dirs) overlay
diff --git a/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-gbit.dts b/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-gbit.dts
new file mode 100644
index 000000000..745985d2f
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/meson-sc2-s905x4-gbit.dts
@@ -0,0 +1,499 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+*
+* sibondt
+*/
+
+/dts-v1/;
+
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include "meson-sc2.dtsi"
+
+/ {
+	model = "Amlogic S905X4";
+	compatible = "amlogic,sc2";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart_B;
+		serial1 = &uart_E;
+		serial2 = &uart_C;
+		serial3 = &uart_D;
+		serial4 = &uart_A;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		spi1 = &spicc0;
+		spi2 = &spicc1;
+	};
+
+	memory {
+		device_type = "memory";
+		linux,usable-memory = <0x0 0x000000 0x0 0x80000000>;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	emmc_pwrseq: emmc-pwrseq {
+		compatible = "mmc-pwrseq-emmc";
+		reset-gpios = <&gpio GPIOB_12 GPIO_ACTIVE_LOW>;
+	};
+
+	wifi32k: wifi32k {
+		compatible = "pwm-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		pwms = <&pwm_ef 0 30518 0>; /* PWM_E at 32.768KHz */
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpio GPIOX_6 GPIO_ACTIVE_LOW>;
+		clocks = <&wifi32k>;
+		clock-names = "ext_clock";
+	};
+
+	vdd_3v3: regulator-vdd_3v3 {
+                compatible = "regulator-fixed";
+                regulator-name = "VDD_3V3";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+        };
+
+	vdd_1v8: regulator-vdd_1v8 {
+                compatible = "regulator-fixed";
+                regulator-name = "VDD_1V8";
+                regulator-min-microvolt = <1800000>;
+                regulator-max-microvolt = <1800000>;
+        };
+
+	vbus_pwr: regulator-vbus_pwr {
+		compatible = "regulator-fixed";
+		regulator-name = "VBUS_PWR";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&gpio GPIOH_6 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* 16 MiB reserved for Hardware ROM Firmware */
+		hwrom_reserved: hwrom@0 {
+			reg = <0x0 0x0 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* Reserved for ARM Trusted Firmware (BL31) */
+		secmon_reserved1: secmon@10000000 {
+			reg = <0x0 0x10000000 0x0 0x200000>;
+			no-map;
+		};
+
+		/* Reserved for ARM Trusted Firmware (BL31) */
+		secmon_reserved2: secmon@5000000 {
+			reg = <0x0 0x05000000 0x0 0x3400000>;
+			no-map;
+		};
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0xbc00000>;
+			alignment = <0x0 0x400000>;
+			linux,cma-default;
+		};
+
+	};
+
+	cpu_opp_table0: cpu_opp_table0 {
+		compatible = "operating-points-v2";
+		status = "okay";
+		opp-shared;
+
+		opp00 {
+			opp-hz = /bits/ 64 <100000000>;
+			opp-microvolt = <779000>;
+		};
+		opp01 {
+			opp-hz = /bits/ 64 <250000000>;
+			opp-microvolt = <779000>;
+		};
+		opp02 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <779000>;
+		};
+		opp03 {
+			opp-hz = /bits/ 64 <667000000>;
+			opp-microvolt = <799000>;
+		};
+		opp04 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-microvolt = <799000>;
+		};
+		opp05 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <809000>;
+		};
+		opp06 {
+			opp-hz = /bits/ 64 <1404000000>;
+			opp-microvolt = <839000>;
+		};
+		opp07 {
+			opp-hz = /bits/ 64 <1500000000>;
+			opp-microvolt = <849000>;
+		};
+		opp08 {
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <879000>;
+		};
+		opp09 {
+			opp-hz = /bits/ 64 <1704000000>;
+			opp-microvolt = <919000>;
+		};
+		opp10 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <959000>;
+		};
+		opp11 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <989000>;
+		};
+		opp12 {
+			opp-hz = /bits/ 64 <2004000000>;
+			opp-microvolt = <1019000>;
+		};
+	};
+
+	cpufreq-meson {
+		compatible = "amlogic,cpufreq-meson";
+		status = "okay";
+	};
+
+	i2c-led {
+		compatible = "i2c-gpio";
+		sda-gpios = <&gpio GPIOA_14 GPIO_ACTIVE_HIGH>;
+		i2c-gpio,sda-output-only;
+		scl-gpios = <&gpio GPIOA_15 GPIO_ACTIVE_HIGH>;
+		i2c-gpio,scl-output-only;
+		i2c-gpio,delay-us = <5>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		disp_7seg@24 {
+			compatible = "fudahisi,fd6551";
+			reg = <0x24>, <0x37>, <0x36>, <0x35>, <0x34>, <0x33>;
+			reg-names = "cmd", "grid_0", "grid_1", "grid_2", "grid_3", "symbols";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			fudahisi,segment-mapping = /bits/ 8 <0 1 2 3 4 5 6>;
+
+			led@0 {
+				reg = <0>;
+				function = LED_FUNCTION_ALARM;
+			};
+
+			led@1 {
+				reg = <1>;
+				function = LED_FUNCTION_USB;
+			};
+
+			led@2 {
+				reg = <2>;
+				function = "pause";
+			};
+
+			led@3 {
+				reg = <3>;
+				function = "play";
+			};
+
+			led@4 {
+				reg = <4>;
+				function = "colon";
+			};
+
+			led@5 {
+				reg = <5>;
+				function = LED_FUNCTION_LAN;
+			};
+
+			led@6 {
+				reg = <6>;
+				function = LED_FUNCTION_WLAN;
+			};
+		};
+	};
+};
+
+&pwm_ij {
+	status = "okay";
+};
+
+&i2c2 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&i2c2_pins3>;
+	clock-frequency = <300000>;
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0=<&i2c3_pins2>;
+	clock-frequency = <300000>; /* default 100k */
+};
+
+&vddcpu0 {
+	status = "okay";
+};
+
+&periphs_pinctrl {
+	tdm_a: tdm_a {
+		mux { /* GPIOX_11, GPIOX_10, GPIOX_8, GPIOX_9 */
+			groups = "tdm_sclk0",
+				"tdm_fs0",
+				"tdm_d3",
+				"tdm_d4";
+			function = "tdm";
+		};
+	};
+
+	tdmin_a: tdmin_a {
+		mux { /* GPIOX_8 */
+			groups = "tdma_din1";
+			function = "tdma_in";
+		};
+	};
+
+	tdmb_mclk: tdmb_mclk {
+		mux {
+			groups = "mclk0_a";
+			function = "mclk0";
+		};
+	};
+	tdmout_b: tdmout_b {
+		mux { /* GPIOA_1, GPIOA_2, GPIOA_3 */
+			groups = "tdmb_sclk",
+				"tdmb_fs",
+				"tdmb_dout0";
+			function = "tdmb_out";
+		};
+	};
+
+	tdmin_b:tdmin_b {
+		mux { /* GPIOA_4 */
+			groups = "tdmb_din1"
+				/*,"tdmb_slv_sclk", "tdmb_slv_fs"*/;
+			function = "tdmb_in";
+		};
+	};
+
+	tdmc_mclk: tdmc_mclk {
+		mux { /* GPIOA_11 */
+			groups = "mclk1_a";
+			function = "mclk1";
+		};
+	};
+
+	tdmout_c:tdmout_c {
+		mux { /* GPIOA_12, GPIOA_13 */
+			groups = "tdmc_sclk_a",
+				"tdmc_fs_a"
+				/*, "tdmc_dout0_a"
+				 *,	"tdmc_dout2"
+				 *, "tdmc_dout3"
+				 */;
+			function = "tdmc_out";
+		};
+	};
+
+	tdmin_c:tdmin_c {
+		mux { /* GPIOA_10 */
+			groups = "tdmc_din0_a";
+			function = "tdmc_in";
+		};
+	};
+
+	spdifin: spdifin {
+		mux {/* GPIOH_5 */
+			groups = "spdif_in_h";
+			function = "spdif_in";
+		};
+	};
+
+	pdmin: pdmin {
+		mux { /* GPIOC_0, GPIOC_4 */
+			groups = "pdm_din0_c",
+				"pdm_dclk_c";
+			function = "pdm";
+		};
+	};
+
+	spdifout: spdifout {
+		mux { /* GPIOD_10 */
+			groups = "spdif_out_d";
+			function = "spdif_out";
+		};
+	};
+
+	spdifout_a_mute: spdifout_a_mute {
+		mux { /* GPIOD_10 */
+			groups = "GPIOD_10";
+			function = "gpio_periphs";
+			output-low;
+		};
+	};
+
+	dvb_s_ts0_pins: dvb_s_ts0_pins {
+		tsin_a {
+			groups = "tsin_a_sop_d",
+				"tsin_a_valid_d",
+				"tsin_a_clk_d",
+				"tsin_a_din0_d";
+			function = "tsin_a";
+		};
+	};
+
+	dvb_s_ts1_pins: dvb_s_ts1_pins {
+		tsin_b {
+			groups = "tsin_b_sop",
+				"tsin_b_valid",
+				"tsin_b_clk",
+				"tsin_b_din0";
+			function = "tsin_b";
+		};
+	};
+
+	dvb_s_ts2_pins: dvb_s_ts2_pins {
+		tsin_c {
+			groups = "tsin_c_sop_z",
+				"tsin_c_valid_z",
+				"tsin_c_clk_z",
+				"tsin_c_din0_z";
+			function = "tsin_c";
+		};
+	};
+
+	dvb_s_ts3_pins: dvb_s_ts3_pins {
+		tsin_d {
+			groups = "tsin_d_sop_z",
+				"tsin_d_valid_z",
+				"tsin_d_clk_z",
+				"tsin_d_din0_z";
+			function = "tsin_d";
+		};
+	};
+}; /* end of periphs_pinctrl */
+
+&usb {
+	status = "okay";
+};
+
+/* SDIO */
+&sd_emmc_a {
+	status = "okay";
+	pinctrl-0 = <&sdio_pins>;
+	pinctrl-1 = <&sdio_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	sd-uhs-sdr104;
+	max-frequency = <200000000>;
+
+	non-removable;
+	disable-wp;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+	vmmc-supply = <&vdd_3v3>;
+	vqmmc-supply = <&vdd_1v8>;
+};
+
+/* SD card */
+&sd_emmc_b {
+	status = "okay";
+	pinctrl-0 = <&sdcard_pins>;
+	pinctrl-1 = <&sdcard_clk_gate_pins>;
+	pinctrl-names = "sd_default", "clk-gate";
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	max-frequency = <200000000>;
+	disable-wp;
+
+	cd-gpios = <&gpio GPIOC_6 GPIO_ACTIVE_HIGH>;
+	cd-inverted;
+	vmmc-supply = <&vdd_3v3>;
+	vqmmc-supply = <&vdd_1v8>;
+};
+
+&sd_emmc_c {
+	status = "okay";
+	pinctrl-0 = <&emmc_pins>, <&emmc_ds_pins>;
+	pinctrl-1 = <&emmc_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+
+	bus-width = <8>;
+	cap-mmc-highspeed;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	max-frequency = <200000000>;
+	non-removable;
+	disable-wp;
+
+	mmc-pwrseq = <&emmc_pwrseq>;
+	vmmc-supply = <&vdd_3v3>;
+	vqmmc-supply = <&vdd_1v8>;
+};
+
+&saradc {
+	status = "okay";
+};
+
+&ethmac {
+	status = "okay";
+	phy-handle = <&internal_ephy>;
+	phy-mode = "rgmii";
+};
+
+&spicc0 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spicc0_pins_x>;
+	cs-gpios = <&gpio GPIOX_10 0>;
+};
+
+&spicc1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spicc1_pins_h>;
+	cs-gpios = <&gpio GPIOH_6 0>;
+};
+
+&pwm_ef {
+	pinctrl-0 = <&pwm_e_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&uart_E {
+	status = "okay";
+	uart-has-rtscts;
+};
diff --git a/arch/arm64/boot/dts/amlogic/sc2_s905x4_2g.dts b/arch/arm64/boot/dts/amlogic/sc2_s905x4_2g.dts
new file mode 100644
index 000000000..e7a88561a
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/sc2_s905x4_2g.dts
@@ -0,0 +1,37 @@
+#include "meson-sc2-s905x4-ah212.dts"
+
+/ {
+	model = "Amlogic";
+	coreelec-dt-id = "sc2_s905x4_2g";
+
+	auge_sound {
+		/delete-property/ avout_mute-gpios;
+	};
+
+	gpioleds {
+		sys_led {
+			label = "sys_led";
+			gpios = <&gpio GPIOD_11 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "default-on";
+		};
+	};
+
+	gpio_keypad {
+		status = "disabled";
+	};
+
+	adc_keypad {
+		status = "disabled";
+	};
+};
+
+&i2c2 {
+	status = "disabled";
+};
+
+&sd_emmc_b {
+	max-frequency = <150000000>;
+	card-detect-delay = <800>;
+	supports-sd;
+	cap-mmc-highspeed;
+};
diff --git a/arch/arm64/boot/dts/amlogic/sc2_s905x4_2g_1gbit.dts b/arch/arm64/boot/dts/amlogic/sc2_s905x4_2g_1gbit.dts
new file mode 100644
index 000000000..5528f3718
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/sc2_s905x4_2g_1gbit.dts
@@ -0,0 +1,60 @@
+#include "sc2_s905x4_2g.dts"
+
+/ {
+	coreelec-dt-id = "sc2_s905x4_2g_1gbit";
+};
+
+&periphs_pinctrl {
+	eth_pins: eth {
+		mux {
+			groups = "eth_mdio",
+				"eth_mdc",
+				"eth_rgmii_rx_clk",
+				"eth_rx_dv",
+				"eth_rxd0",
+				"eth_rxd1",
+				"eth_txen",
+				"eth_txd0",
+				"eth_txd1";
+			function = "eth";
+			drive-strength-microamp = <4000>;
+			bias-disable;
+		};
+	};
+
+	eth_rgmii_pins: eth-rgmii {
+		mux {
+			groups = "eth_rxd2_rgmii",
+				"eth_rxd3_rgmii",
+				"eth_rgmii_tx_clk",
+				"eth_txd2_rgmii",
+				"eth_txd3_rgmii";
+			function = "eth";
+			drive-strength-microamp = <4000>;
+			bias-disable;
+		};
+	};
+};
+
+&ext_mdio {
+	external_phy: ethernet-phy@0 {
+		reg = <0>;
+		max-speed = <1000>;
+
+		reset-assert-us = <10000>;
+		reset-deassert-us = <30000>;
+		reset-gpios = <&gpio GPIOZ_15 (GPIO_ACTIVE_LOW |
+					GPIO_OPEN_DRAIN)>;
+	};
+};
+
+&ethmac {
+	pinctrl-0 = <&eth_pins>, <&eth_rgmii_pins>;
+	pinctrl-names = "default";
+	phy-handle = <&external_phy>;
+	phy-mode = "rgmii";
+	internal_phy = <2>;
+	cali_val = <0x80000>;
+	amlogic,tx-delay-ns = <2>;
+	/delete-property/ mc_val;
+};
diff --git a/arch/arm64/boot/dts/amlogic/sc2_s905x4_4g_1gbit.dts b/arch/arm64/boot/dts/amlogic/sc2_s905x4_4g_1gbit.dts
new file mode 100644
index 000000000..fbe3642f4
--- /dev/null
+++ b/arch/arm64/boot/dts/amlogic/sc2_s905x4_4g_1gbit.dts
@@ -0,0 +1,9 @@
+#include "sc2_s905x4_2g_1gbit.dts"
+
+/ {
+	coreelec-dt-id = "sc2_s905x4_4g_1gbit";
+
+	memory@00000000 {
+		linux,usable-memory = <0x0 0x000000 0x0 0xf1000000>;
+	};
+};
--
2.43.0.windows.1

